--- Page 1 ---
*****  THANK GOD THAT WE HAVE AVEVA PDMS BECAUSE ALL OTHE R PLANT SOFTWARE REALLY SUCK *****  
 
 
 
 
PML  
(Programmable Macro Language) 
 
Manual 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Description:  This manual describes the AVEVA PDMS PML language.  
 
Purpose:  As source materials have been used internal AVEVA guide lines 
supplemented with references from AVEVA world forum  web page and other 
web pages. This manual has no copyrights and it was  created only for 
educational purposes. All data are only informative .  
 
Inscription:  All self-educated users please feel free to use an d improve your own skills. 
Sharing your knowledges could improve our community  and it could change 
the world in the result. 
 
  Created:   03/2016 
 
  

--- Page 2 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 2/178  CONTENT 
CONTENT ........................................... ................................................... .................... 2  
1.  PML - PROGRAMMABLE MACRO LANGUAGE ................. .......................... 9  
1.1.  CUSTOMIZING A GRAPHICAL USER INTERFACE ................................................... ............ 10  
1.2.  NOTE FOR USERS FAMILIAR WITH OO  CONCEPTS  .................................................. ....... 10  
2.  PML VARIABLES ..................................... ................................................... .. 11  
2.1.  PML2  VARIABLES  .................................................. ................................................... ....... 11  
 The built-in object types ......................... ................................................... ................ 11  2.1.1. 
 The system-defined object types.................... ................................................... ........ 12  2.1.2. 
 The user-defined object types ..................... ................................................... ........... 12  2.1.3. 
2.2.  CREATION OF VARIABLES  .................................................. .............................................. 13  
2.2.1.  PML1 variables creation ........................... ................................................... ............. 13  
2.2.2.  PML2 variables creation ........................... ................................................... ............. 13  
2.3.  MEMBERS AND ATTRIBUTES ................................................... ......................................... 14  
2.4.  NAMING CONVENTIONS  .................................................. ................................................. 1 5  
3.  PML EXPRESSIONS ................................... .................................................. 17  
3.1.  PML  1 EXPRESSIONS  .................................................. ................................................... . 17  
3.2.  PML  2 EXPRESSIONS  .................................................. ................................................... . 17  
3.3.  CREATING UNSET AND UNDEFINED VARIABLE  .................................................. ............... 18  
3.4.  DELETING PML  VARIABLES  .................................................. ........................................... 18  
3.5.  MIXING OF THE VARIABLES TYPES  .................................................. ................................. 18  
3.6.  EXPRESSION OPERATORS  .................................................. ............................................. 19  
3.7.  BOOLEAN OPERATORS ................................................... ................................................. 2 0  
3.8.  CONCATENATION OPERATOR  .................................................. ........................................ 20  
3.9.  COMMUNICATING WITH AVEVA  PRODUCTS IN PML................................................ ....... 21  
3.10.  PARAMETERIZED MACROS  .................................................. ............................................ 21  
3.11.  SYNONYMS  .................................................. ................................................... ................. 21  
3.12.  CREATING OTHER TYPES OF VARIABLE  .................................................. ........................ 22  
3.13.  USING THE MEMBER VALUES OF AN OBJECT  .................................................. ................ 22  
3.14.  PML  FUNCTIONS AND METHODS  .................................................. .................................. 22  
3.15.  STORING AND LOADING PML  FUNCTIONS ................................................... .................... 23  
3.16.  ARGUMENTS OF TYPE ANY ............................................... .............................................. 23  
3.17.  PML  PROCEDURES  .................................................. ................................................... .... 24  
3.18.  USING THE METHODS OF AN OBJECT  .................................................. ........................... 25  
3.19.  METHODS ON USER -DEFINED OBJECT TYPES ................................................... ............. 25  
3.20.  METHOD OVERLOADING  .................................................. ................................................ 26  
3.21.  CONSTRUCTOR METHODS WITH ARGUMENTS  .................................................. .............. 26  
3.22.  OVERLOADING WITH ANY ............................................... ................................................ 27  
3.23.  INVOKING A METHOD FROM ANOTHER METHOD  .................................................. ........... 27  
3.24.  DEVELOPING A PML  OBJECT WITH METHODS  .................................................. .............. 27  
3.25.  FORMS AS GLOBAL VARIABLES  .................................................. ..................................... 27  
4.  ARRAYS IN PML ..................................... ................................................... ... 28  
4.1.  ARRAY METHODS ................................................... ................................................... ....... 29  
4.2.  SORTING ARRAYS USING THE VAR  COMMAND  .................................................. ............. 31  
4.3.  SUBTOTALING ARRAYS WITH THE VAR  COMMAND  .................................................. ....... 31  

--- Page 3 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 3/178  5.  COLLECTIONS ....................................... ................................................... .... 32  
5.1.  THE COLLECTION SYNTAX PML  1 ................................................. .................................. 32  
5.2.  THE OBJECT COLLECTION SYNTAX PML  2 ................................................. .................... 32  
5.3.  THE COLLECTION EXAMPLES  .................................................. ......................................... 32  
5.4.  ARRAY SORTING  .................................................. ................................................... ......... 35  
5.4.1.  PML 1 array sorting ............................... ................................................... ................ 35  
6.  PML GENERAL FUTURES ............................... ............................................ 38  
6.1.  FUNCTIONS , MACROS AND OBJECT DEFINITIONS  .................................................. ......... 38  
6.2.  COMMENTS IN PML  FILES  .................................................. ............................................. 38  
6.3.  LEAVING A PML  FILE WITH THE RETURN  COMMAND  .................................................. .. 38  
6.4.  CASE INDEPENDENCE  .................................................. ...................................................  38  
6.5.  ABBREVIATIONS ................................................... ................................................... ......... 39  
6.6.  SPECIAL CHARACTER $ ................................................. .................................................. 39  
6.7.  TEXT DELIMITERS  .................................................. ................................................... ....... 39  
6.8.  FILENAME EXTENSIONS  .................................................. ................................................. 4 0  
6.9.  STORING AND LOADING PML  FILES  .................................................. .............................. 40  
6.10.  REBUILDING ALL PML  FILE INDEXES  .................................................. ............................ 40  
6.11.  QUERYING THE LOCATION OF PML  FILES  .................................................. ..................... 40  
7.  PML CONTROL LOGIC ................................. ................................................ 41  
7.1.  IF  CONSTRUCT  .................................................. ................................................... ........... 41  
7.1.1.  Nesting if-constructs ............................. ................................................... ................. 41  
7.1.2.  IF, THEN, ELSEIF and ELSE Statements .............. ...................................................  42  
7.1.3.  BOOLEAN Expressions and if Statements ............. ...................................................  42  
7.1.4.  IF TRUE Expression ................................ ................................................... .............. 43  
7.1.5.  Boolean expressions PML1 upward compatibility ..... ................................................. 4 3  
7.2.  DO  LOOPS  .................................................. ................................................... ................. 44  
7.2.1.  Stopping a DO loop: break and breakif ............. ................................................... ..... 44  
7.2.2.  Skipping Commands in a DO Loop using Skip or Skip i f............................................ 44  
7.2.3.  Nested DO Loops ................................... ................................................... ............... 45  
7.2.4.  DO Index and DO Values ............................ ................................................... .......... 45  
7.2.5.  DO Loops Examples ................................. ................................................... ............. 45  
7.2.6.  DO Values with Arrays of Objects .................. ................................................... ........ 46  
7.3.  JUMPING TO A LABELLED LINE  .................................................. ...................................... 46  
7.3.1.  Conditional Jumping to a Labelled Line ............ ................................................... ...... 46  
7.3.2.  Illegal Jumping ................................... ................................................... ................... 47  
7.4.  ERRORS AND ERROR HANDLING  .................................................. ................................... 47  
7.4.1.  Error Conditions .................................. ................................................... .................. 47  
7.4.2.  Handling Errors ................................... ................................................... .................. 47  
7.4.3.  Setting the ONERROR Behavior....................... ................................................... ..... 48  
7.4.4.  Other Responses to an Error ....................... ................................................... .......... 48  
7.5.  HANDLING FILES AND DIRECTORIES  .................................................. ............................. 49  
7.5.1.  Creating a File Object ............................ ................................................... ................ 49  
7.5.2.  Reading from Files ................................ ................................................... ................ 50  
7.5.3.  Writing to Files................................... ................................................... .................... 50  
7.5.4.  Reading and Writing ARRAYS ........................ ................................................... ....... 50  
7.5.5.  Error Handling When Using a File Object ........... ................................................... .... 50  
8.  MACROS ............................................ ................................................... ........ 51  
8.1.  PML  MACROS  .................................................. ................................................... ............ 51  
8.1.1.  Naming and Running Macros.......................... ................................................... ....... 51  
8.1.2.  Macros with Arguments ............................. ................................................... ............ 51  

--- Page 4 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 4/178  8.2.  USING MACROS AND FUNCTIONS TOGETHER  .................................................. ............... 52  
8.3.  SYNONYMS IN PML  MACROS AND FUNCTIONS  .................................................. ............. 52  
8.4.  PML  1 HIERARCHY ................................................... ................................................... .... 53  
8.5.  PML2  FUNCTIONS AND OBJECTS  .................................................. ................................. 53  
8.5.1.  The pmllib environment variable ................... ................................................... ......... 53  
8.5.2.  Modifications to pmllib ........................... ................................................... ................ 53  
8.5.3.  Updating PDMSUI and PMLLIB ........................ ................................................... ..... 54  
8.5.4.  PML2 Objects ...................................... ................................................... .................. 54  
8.5.5.  PML2 Methods ...................................... ................................................... ................ 54  
8.5.6.  Method Concatenation............................... ................................................... ............ 55  
8.5.7.  The !!CE Object ................................... ................................................... .................. 55  
8.5.8.  PML2 Functions .................................... ................................................... ................ 56  
9.  USING PML IN AVEVA PRODUCTS........................ ..................................... 57  
9.1.  COMPOSING TEXT  .................................................. ................................................... ...... 57  
9.2.  DEFINING VARIABLES FOR LATE EVALUATION (R ULES ) ................................................. . 57  
9.3.  USING PML  IN PDMS .............................................. ................................................... .... 58  
9.3.1.  Accessing DB Elements As Objects .................. ................................................... ..... 58  
9.3.2.  Assigning Values to Element Attributes ............ ................................................... ...... 58  
9.3.3.  Accessing Information About a Session ............. ................................................... .... 59  
9.3.4.  Evaluating Selected DB Elements.................... ................................................... ...... 59  
9.3.5.  RAW keyword When setting Variables with VAR........ ............................................... 60  
9.3.6.  Undo and Redo ..................................... ................................................... ................ 60  
10.  COPIES AND REFERENCES ............................. ........................................... 61  
10.1.  ASSIGNMENT  .................................................. ................................................... .............. 61  
10.2.  FORM AND GADGET REFERENCES  .................................................. ................................ 61  
10.3.  DB  REFERENCES  .................................................. ................................................... ....... 61  
10.3.1.  Deep Copy involving References: ................... ................................................... ....... 61  
10.4.  FUNCTION ARGUMENTS  .................................................. ................................................ 62  
10.4.1.  Constants as Function Arguments ................... ................................................... ...... 62  
10.4.2.  Form and Gadget Properties Passed as Function Argum ents ................................... 62  
10.5.  DATABASE ATTRIBUTES  .................................................. ................................................ 62  
11.  DEVELOPING PML CODE ............................... ............................................. 63  
11.1.  USING UNICODE TEXT  .................................................. ...................................................  63  
11.1.1.  Textual File Handling ............................. ................................................... ................ 63  
11.1.2.  File Transcoding Utility .......................... ................................................... ................ 64  
11.1.3.  Using Unicode as the new PDMS Internal Format ..... ................................................ 64  
11.2.  PML  TRACING  .................................................. ................................................... ............ 65  
11.3.  DIAGNOSTIC MESSAGES FROM WITHIN PML  FILES  .................................................. ..... 65  
11.4.  ALPHA LOG  .................................................. ................................................... ................. 65  
11.5.  ALPHA LOG AND PML  TRACING  .................................................. .................................... 65  
11.6.  SUSPENDING A RUNNING PML  MACRO  .................................................. ........................ 65  
11.7.  QUERYING PML ............................................... ................................................... ............ 66  
11.7.1.  Querying the Currently Running PML File Stack ..... .................................................. 66  
11.7.2.  Querying the Values of PML Variables .............. ................................................... ..... 66  
11.7.3.  Querying What Can Be Typed Next ................... ................................................... .... 66  
12.  UPGRADING FROM PML1 TO PML2 ....................... .................................... 67  
12.1.  DIFFERENCE BETWEEN PML  1 AND PML2 .............................................. ....................... 67  
12.1.1.  PML1 advantages.................................... ................................................... .............. 67  
12.1.2.  PML2 advantages.................................... ................................................... .............. 67  
12.2.  IMPORTANT DIFFERENCES  .................................................. ............................................. 68  

--- Page 5 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 5/178  13.  PML FORM CONCEPTS ................................. .............................................. 70  
13.1.  OVERVIEW  .................................................. ................................................... .................. 70  
13.2.  NAMING FORMS AND THEIR MEMBERS  .................................................. .......................... 70  
13.3.  SIMPLE FORM  .................................................. ................................................... ............. 71  
13.3.1.  Adding a Gadget Callback .......................... ................................................... ........... 71  
13.4.  FORM DEFINITION FILE ................................................... ................................................. 7 2  
13.5.  HOW FORMS ARE LOADED AND DISPLAYED  .................................................. .................. 72  
13.6.  PML  DIRECTIVES  .................................................. ................................................... ....... 73  
13.7.  REVISITING OUR SIMPLE FORM  .................................................. ..................................... 74  
14.  FORMS AND GADGET CALLBACKS ........................ .................................. 76  
14.1.  CALLBACKS : EXPRESSIONS ................................................... .......................................... 76  
14.2.  CALLBACKS : FORM METHODS / PML  FUNCTIONS ................................................... ........ 76  
14.3.  PML  OPEN CALLBACKS  .................................................. ................................................ 77  
14.3.1.  Events ............................................ ................................................... ....................... 77  
14.3.2.  Open Callbacks at Meta-events ..................... ................................................... ........ 77  
14.3.3.  Using a PML Function in an Open Callback .......... ................................................... . 79  
14.3.4.  Objects That Can Have Open Callbacks .............. ................................................... .. 79  
15.  FORMS ............................................. ................................................... .......... 80  
15.1.  MODULES AND APPLICATIONS ................................................... ...................................... 80  
15.2.  DEFINING A FORM  .................................................. ................................................... ...... 80  
15.2.1.  Form Attributes ................................... ................................................... ................... 80  
15.2.2.  Form Type ......................................... ................................................... .................... 81  
15.2.3.  Layout Modes ...................................... ................................................... .................. 81  
15.2.4.  Minimum Size and Resizability ..................... ................................................... ......... 82  
15.2.5.  Intelligent Resizable Forms ....................... ................................................... ............. 82  
15.2.6.  Gadget Alignment Control........................... ................................................... ........... 82  
15.2.7.  No Alignment ...................................... ................................................... ................... 82  
15.3.  FORM MEMBERS  .................................................. ................................................... ........ 83  
15.3.1.  Form Title and Icon Title ......................... ................................................... ............... 83  
15.3.2.  Form Initialisation Callback ...................... ................................................... .............. 83  
15.3.3.  Form OK and CANCEL Callbacks....................... ................................................... ... 83  
15.3.4.  Quit/Close Callback ............................... ................................................... ................ 84  
15.3.5.  FIRSTSHOWN callback ............................... ................................................... .......... 85  
15.3.6.  KILLING callback .................................. ................................................... ................. 85  
15.3.7.  Form Variables: PML Variables within a Form ....... ................................................... . 85  
15.3.8.  Querying Form Members ............................. ................................................... .......... 86  
15.4.  LOADING , SHOWING , AND HIDING FORMS  .................................................. ..................... 86  
15.4.1.  Free Forms and Form Families ...................... ................................................... ........ 86  
15.4.2.  Loading and Showing Forms ......................... ................................................... ........ 87  
15.4.3.  Position of Forms on the Screen ................... ................................................... ......... 87  
15.4.4.  Hiding Forms ...................................... ................................................... ................... 88  
15.4.5.  Killing Forms...................................... ................................................... .................... 88  
15.4.6.  NOQUIT Form Status ................................ ................................................... ............ 88  
16.  MENUS ............................................. ................................................... .......... 89  
16.1.  MENU TYPES AND RULES ................................................... ............................................. 89  
16.2.  DEFINING A BAR MENU GADGET  .................................................. ................................... 89  
16.2.1.  Defining a Menu Object ............................ ................................................... ............. 90  
16.2.2.  Window Menu........................................ ................................................... ................ 91  
16.2.3.  Online Help Menu .................................. ................................................... ................ 91  
16.2.4.  Popup Menus ....................................... ................................................... ................. 91  
16.2.5.  Finding Who Popped up a Menu ...................... ................................................... ...... 92  
16.2.6.  Toggle Menus....................................... ................................................... ................. 92  

--- Page 6 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 6/178  16.3.  EDITING BARS AND MENUS  .................................................. ........................................... 93  
16.3.1.  Inserting Menus into a Bar ........................ ................................................... ............. 93  
16.3.2.  Inserting New Menu Fields ......................... ................................................... ........... 93  
16.3.3.  Changing the State of Menufields .................. ................................................... ........ 94  
16.3.4.  Implied Menu-field Groups ......................... ................................................... ............ 95  
16.3.5.  Creating Menus Dynamically ........................ ................................................... ......... 96  
17.  FORM LAYOUT ....................................... ................................................... ... 97  
17.1.  SYSTEM FONT AND UNICODE CHARACTERS  .................................................. ................. 97  
17.2.  LAYOUT MODES  .................................................. ................................................... ......... 97  
17.3.  CONTAINERS , GRID CO-ORDINATES AND GADGET BOXES  ............................................. 98  
17.4.  POSITIONING , ALIGNMENT AND SIZE OF GADGETS  .................................................. ....... 99  
17.5.  AUTO -PLACEMENT  .................................................. ................................................... .... 100  
17.5.1.  Positioning Gadgets on a Defined Path ............. ................................................... ... 100  
17.5.2.  Setting the Auto-displacement between Gadgets ..... ............................................... 100  
17.5.3.  Gadget Alignment .................................. ................................................... .............. 101  
17.5.4.  How It All Works .................................. ................................................... ................ 101  
17.5.5.  Default Positions in Gadget Containers ............ ................................................... .... 102  
17.6.  RELATIVE PLACEMENT USING THE AT-SYNTAX  .................................................. ........... 102  
17.6.1.  Positioning Relative to a Previous Gadget ......... ................................................... .. 102  
17.6.2.  Positioning Relative to the Form Extremities ...... ................................................... .. 103  
17.7.  MIXING AUTO AND RELATIVE PLACEMENT  .................................................. .................. 104  
17.8.  ABSOLUTE GADGET POSITIONING  .................................................. ............................... 104  
17.9.  AT  SYNTAX ................................................... ................................................... .............. 104  
17.10.  GADGET SIZE MANAGEMENT  .................................................. ...................................... 105  
17.10.1.  Tag Width ......................................... ................................................... ............... 105  
17.10.2.  The Meaning of Size for the PML Gadget Types ...... ........................................... 106  
17.10.3.  Specifying Gadget Size Relative to a Previous Gadge t ........................................ 106  
17.10.4.  Gadget Size Syntax ................................ ................................................... ......... 106  
17.11.  INTELLIGENT POSITIONING AND RESIZING  .................................................. .................. 107  
17.11.1.  ANCHOR Attribute .................................. ................................................... ......... 107  
17.11.2.  DOCK Attribute .................................... ................................................... ............ 108  
17.12.  USEFUL FORM LAYOUT QUICK CHECKLIST  .................................................. ................. 108  
18.  FRAME.............................................. ................................................... ........ 109  
18.1.  TYPES OF FRAME  .................................................. ................................................... ..... 109  
18.1.1.  Normal Frames...................................... ................................................... .............. 109  
18.1.2.  Tabset Frames ..................................... ................................................... ............... 109  
18.1.3.  Toolbar Frames .................................... ................................................... ............... 109  
18.1.4.  PANEL Frames ...................................... ................................................... ............. 109  
18.1.5.  Fold Up Panel Frames .............................. ................................................... ........... 109  
19.  GADGETS AND THEIR ATTRIBUTES....................... ................................. 110  
19.1.  GADGET DEFINITION COMMANDS  .................................................. ............................... 110  
19.2.  SOME GENERIC GADGET MEMBERS AND METHODS ................................................... .. 111  
19.3.  GADGETS THAT SUPPORT PIXMAPS  .................................................. ............................ 111  
19.3.1.  Selected and Unselected States .................... ................................................... ...... 111  
19.3.2.  AddPixmap Method .................................. ................................................... ........... 111  
19.4.  DE-ACTIVATING GADGETS : GREYING OUT  .................................................. .................. 112  
19.4.1.  Greying Out Gadgets on Forms ...................... ................................................... ..... 112  
19.5.  MAKING GADGETS VISIBLE AND INVISIBLE  .................................................. .................. 112  
19.6.  SETTING KEYBOARD FOCUS  .................................................. ....................................... 113  
19.7.  REFRESHING GADGETS ................................................... .............................................. 113  
19.8.  GADGET BACKGROUND COLOUR  .................................................. ................................ 114  

--- Page 7 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 7/178  20.  GADGET SET ........................................ ................................................... ... 115  
20.1.  EXAMPLES  .................................................. ................................................... ................ 115  
20.1.1.  Complex Form Layout ............................... ................................................... .......... 115  
20.1.2.  Multi-lingual Form ................................ ................................................... ................ 121  
20.2.  FRAME GADGETS  .................................................. ................................................... ..... 123  
20.2.1.  Defining a Frame .................................. ................................................... ............... 123  
20.2.2.  Frame Radio Groups ................................ ................................................... ........... 123  
20.2.3.  Managing Pages in Tabset Frames.................... ................................................... .. 125  
20.2.4.  Managing the Fold Up Panel......................... ................................................... ....... 126  
20.3.  CONTAINER  GADGET  .................................................. ............................................... 127  
20.3.1.  Example of Container Gadget ....................... ................................................... ....... 127  
20.4.  PARAGRAPH GADGETS  .................................................. ............................................... 129  
20.4.1.  Textual Paragraph Gadgets ......................... ................................................... ........ 129  
20.4.2.  Pixmap Paragraph Gadgets .......................... ................................................... ....... 130  
20.4.3.  Textual Paragraph Gadgets ......................... ................................................... ........ 130  
20.5.  BUTTON GADGETS  .................................................. ................................................... ... 130  
20.5.1.  Buttons of Type Toggle ............................ ................................................... ............ 130  
20.5.2.  Buttons of type LINKLABEL ......................... ................................................... ........ 131  
20.5.3.  Form Control Attributes ........................... ................................................... ............. 131  
20.5.4.  Defining a Dismiss Button ......................... ................................................... ........... 132  
20.6.  TOGGLE GADGETS  .................................................. ................................................... ... 132  
20.7.  RT OGGLE GADGETS  .................................................. ...................................................  132  
20.8.  OPTION AND COMBOBOX GADGETS  .................................................. ............................ 134  
20.8.1.  Textual Option Gadgets ............................ ................................................... ........... 134  
20.8.2.  Combobox Gadgets .................................. ................................................... ........... 135  
20.8.3.  Pixmap Option Gadgets ............................. ................................................... .......... 135  
20.8.4.  Setting and Getting the Current Selection ......... ................................................... ... 135  
20.9.  SLIDER GADGETS  .................................................. ................................................... ..... 136  
20.10.  LINE GADGETS  .................................................. ................................................... ......... 136  
20.11.  NUMERIC INPUT GADGET  .................................................. ............................................ 137  
20.12.  LIST GADGETS ................................................... ................................................... ......... 137  
20.12.1.  Single Choice List Gadgets ........................ ................................................... ...... 138  
20.12.2.  Multiple Choice List Gadgets ...................... ................................................... ...... 139  
20.12.3.  Multi-Column List Gadgets ......................... ................................................... ...... 141  
20.13.  DATABASE SELECTOR GADGETS  .................................................. ................................ 142  
20.14.  TEXT GADGETS  .................................................. ................................................... ........ 143  
20.14.1.  Controlling Text Gadgets’ Editing ................. ................................................... .... 144  
20.14.2.  Copying and Pasting into Text Fields .............. ................................................... . 145  
20.14.3.  Formatting in Text Input Gadgets: Imperial Units .. ............................................... 145  
20.14.4.  Unset Text Fields ................................. ................................................... ............ 146  
20.14.5.  Validating Input to Text Fields ................... ................................................... ....... 147  
20.14.6.  Setting the Value of a Text Field ................. ................................................... ..... 148  
20.15.  TEXT PANE GADGETS  .................................................. .................................................. 148  
20.15.1.  Fixed Width Font................................... ................................................... ........... 150  
20.16.  FAST ACCESS TO LISTS , SELECTORS AND TEXTPANES USING DO  LOOPS  .................. 151  
20.17.  VIEW GADGETS  .................................................. ................................................... ........ 151  
20.17.1.  Defining a View Gadget ............................ ................................................... ....... 152  
20.17.2.  Resizable View Gadgets ............................ ................................................... ...... 152  
20.17.3.  Pop-up Menus in Views ............................. ................................................... ...... 152  
20.17.4.  Defining Alpha Views .............................. ................................................... ......... 152  
20.17.5.  Graphical Views ................................... ................................................... ............ 154  
20.17.6.  Defining PLOT Views ............................... ................................................... ........ 156  
20.17.7.  Defining DRAFT’s Area (2D) Views .................. ...................................................  156  
20.17.8.  Defining DESIGN’s Volume (3D) Views ............... ................................................ 15 7  

--- Page 8 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 8/178  21.  FMSYS OBJECT AND ITS METHODS ...................... ................................. 160  
21.1.  MANAGING THE DEFAULT FORM LAYOUT MODE  .................................................. ......... 160  
21.2.  SWAPPING APPLICATIONS  .................................................. ........................................... 160  
21.3.  PROGRESS AND INTERRUPT METHODS ................................................... ...................... 160  
21.4.  REFRESHING VIEW GADGETS  .................................................. ..................................... 161  
21.5.  CHECKING REFERENCES TO OTHER FORMS  .................................................. .............. 161  
21.6.  SPLASH SCREEN  .................................................. ................................................... ...... 161  
21.7.  DEFAULT FORM POSITIONING  .................................................. ..................................... 162  
21.8.  CURRENT DOCUMENT ()  METHOD  .................................................. ................................ 162  
21.9.  LOAD FORM ()  METHOD  .................................................. ................................................ 16 2  
21.10.  CURSOR FUNCTION SUPPORT  .................................................. .................................... 162  
21.11.  SETTING THE DEFAULT FORMAT OBJECT FOR TEXT FIELDS  ........................................ 163  
22.  PML ADD-INS ....................................... ................................................... .... 164  
22.1.  APPLICATION SWITCHING  .................................................. ............................................ 164  
22.1.1.  Main Form ......................................... ................................................... .................. 164  
22.1.2.  Callbacks.......................................... ................................................... ................... 165  
22.1.3.  Defining an Add-in ................................ ................................................... ............... 165  
22.1.4.  Add-in Object...................................... ................................................... ................. 166  
22.1.5.  Initialisation .................................... ................................................... ..................... 166  
22.2.  MENUS  .................................................. ................................................... ..................... 166  
22.2.1.  APPMENU Object .................................... ................................................... ........... 166  
22.2.2.  Addition of Menu Items ............................ ................................................... ............ 166  
22.2.3.  Removing Menu Items ............................... ................................................... .......... 167  
22.2.4.  Modifying the Bar Menu ............................ ................................................... ........... 167  
22.3.  TOOLBARS  .................................................. ................................................... ................ 168  
22.3.1.  Toolbar Control.................................... ................................................... ................ 168  
22.3.2.  Removing Gadgets from a Toolbar ................... ................................................... ... 169  
22.3.3.  Deactivating Gadgets on a Toolbar ................. ................................................... ..... 169  
22.4.  FORMS ................................................... ................................................... ..................... 169  
22.4.1.  Registering a Form ................................ ................................................... .............. 169  
22.4.2.  Hiding Forms when Exiting Applications............. ................................................... .. 169  
22.4.3.  Storing Data Between Sessions ..................... ................................................... ...... 170  
22.5.  CONVERTING EXISTING USER -DEFINED APPLICATIONS  ................................................ 1 71  
22.5.1.  Replacement of the DBAR File ...................... ................................................... ...... 171  
22.5.2.  Menu Name Clashes ................................. ................................................... .......... 171  
22.5.3.  Converting the DBAR File .......................... ................................................... .......... 171  
22.6.  EXAMPLE APPLICATION  .................................................. ............................................... 172  
22.6.1.  Adding a Menu Field ............................... ................................................... ............. 172  
22.6.2.  Creating a Custom Delete Callback ................. ................................................... .... 172  
23.  EVENT DRIVEN GRAPHICS (EDG) ....................... ..................................... 174  
24.  PML.NET............................................ ................................................... ....... 176  
24.1.  IMPORT AN ASSEMBLY INTO PDMS .............................................. ................................ 176  
24.1.1.  PML.Net syntax .................................... ................................................... ............... 176  
24.2.  CREATING A PML  FORM CONTAINING THE .NET  CONTROL  .......................................... 177  
24.3.  GRID CONTROL  .................................................. ................................................... ........ 178  
24.3.1.  Applying Data to the Grid ......................... ................................................... ............ 178  
24.3.2.  Events and Callbacks .............................. ................................................... ............ 178  
  

--- Page 9 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 9/178  1. PML - Programmable Macro Language 
 PML is a file-based interpreted language that enab les an application developer to design 
macro files, programmable macros or Microsoft Windows  form-based add-ins that can be 
included within an Aveva product such as Plant Design Management System  (PDMS). There 
are currently three iterations of the PML language:  
 
• PML1 - Basic macro / command language with Window form capabilities. 
• PML2 - Advanced ver. of PML1, include object-orien ted capability for forms and 
menus. 
• PML.NET - An alternative PML mechanism to facilita te the use of Microsoft .NET 
controls into a PML environment. 
 
* Macro is a group of commands written to a file. B y asking PDMS to run a macro, you are 
really asking PDMS to run a series of commands in a  set order (as defined in the macro file). 
* Programmable Macro is containing program construc ts such as IF statements and loops. 
* Forms-based add-ins most applications are driven by forms and menus.  
* PML Programmable Macro Language. 
* PML1 First version of PML including loops, IF sta tements, string handling, labels etc. 
* PML2 Object orientated language builds on PML1 an d extends the facilities to be like other 
object based languages (C++, Smalltalk). 
 
 The current version of PML, sometimes referred to as PML2, may simply be seen as an 
extension to the original PML1 facilities. However,  the more powerful techniques that are 
available mean that many programming tasks are carr ied out in different ways. There are 
some tasks which are carried out more efficiently u sing PML 1 facilities. PML 2 has been 
specifically designed for writing and customizing t he Forms and Menus for AVEVA products. 
 
 PML2 is an enhanced version of PML and is more lik e other modern languages that you 
may be familiar with. PML2 is almost an object orie nted language. It provides most features 
of other Object Orientated Programming (OOP) langua ges except for inheritance. It provides 
for classes of built-in, system-defined and user-de fined object types. Objects have members 
(their own variables) and methods (their own functi ons). All PML variables are an instance of 
a built-in, system-defined or user-defined object t ype. Both PML1 and PML2 have their 
advantages and disadvantages. However, PML2 has not  completely replaced PML1. 
 
Picture Nr.1. - PML File hierarchy 
 Typically, fewer lines of code needed with PML2 wh en compared to traditional PML 
(PML1) and it has been designed to be easier to rea d/write. While most PML1 macros will 
still run within PDMS, PML2 bring many new features  that were previously unavailable. Built 
in methods for different variable types remove seve ral multi line procedures used in old style 
macros. Use of $ characters is dramatically reduced  with a more readable format for 
expressions. 
 
 $-style macros will still work provided the syntax  has been followed correctly. It is possible 
to convert traditional PML code to include newer PM L2 features, but it is important that users 
maintain compatibility at all times.   


--- Page 10 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 10/178   The main features of PML2 are: 
 
• Available Variable Types - STRING, REAL, BOOLEAN, ARRAY 
• Built in Methods for commonly used actions 
• Global Functions supersede old style macros 
• User Defined Object Types 
• PML Search Path (PMLLIB) 
• Dynamic Loading of Forms, Functions and Objects 
• Aid objects for geometric modeling 
 
 PML is now more consistent with other programming languages and more structured in 
form. The new data types are now OBJECTS which can be operated by running METHODS . 
The old $ based variables are still valid, but are always treated as strings. Global functions 
are macros which can be called more like subroutine s than traditional macros. e.g. a function 
can be called between the brackets of an IF stateme nt and return a BOOLEAN result User-
defined object types enable a group of mixed variab les to be combined into packages. The 
resulting object can then be used as a simple varia ble and the separate parts set or used as 
attributes of the variable. Search paths and dynami c loading mean that it is no longer 
necessary to pre load forms or have synonyms for ca lling macros. A large number of new 
aid objects have been created so that users can do more graphical construction. 
1.1. Customizing a Graphical User Interface 
 Most AVEVA products make use of a Graphical User Interface (GUI) to drive the 
software. PML 2 has been specifically designed for writing and customizing the Forms and 
Menus for AVEVA products. Almost all the facilities avail able in PML 1 and the older Forms 
and Menus facilities continue to function as before  even if they are not documented here. 
Before you begin customizing a GUI, you must have a  good working knowledge of the 
command syntax for the AVEVA product you are workin g with. 
1.2. Note for Users Familiar with OO Concepts 
 PML2 is almost an object-oriented language. Its ma in deficiency is that it lacks 
inheritance. However, it does provide for classes o f built-in, system-defined and user-defined 
object types. Objects have members (their own variables) and methods (their own 
functions ). All PML Variables are an instance of a built-in,  system-defined or user-defined 
object type. Operators and methods are polymorphic - what they do (their behavior) 
depends on the type of the variable. Overloading of functions and operators is supported for 
all variable types. There is no concept of private members or methods, everything is public . 
There are only two levels of scope for variables: Global and Local . Arguments to PML 
Functions are passed-by-reference with Read/Write a ccess so any argument can potentially 
be used as an output argument. 
 
Note: From PDMS12.1, all textual information in PDMS is represented as Unicode. Unicode 
is a computing industry standard for the consistent  encoding, representation and handling of 
text expressed in most of the world's writing syste ms. Developed in conjunction with the 
Universal Character Set standard and published in b ook form as The Unicode Standard, the 
latest version of Unicode consists of a repertoire of more than 109,000 characters covering 
93 scripts. The PML Internal Format for string data  is Unicode UTF8 format. This means that 
all PML string variables support Unicode values. Yo u can use Unicode characters in PML 
variable names, PML object form and gadget names, P ML method and function names. All 
PML language files should either be UTF8 format wit h a BOM present or else strictly ASCII 
7-bit (decimal 32 to 127) format. 
  

--- Page 11 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 11/178  2. PML Variables 
 Variables are used to store values (numbers, text,  Boolean, arrays, information’s, data). 
PML variables are two of kinds, global and local. G lobal variables last for a whole session (or 
until you delete them). They are loaded from pmllib  every time when the pml index is rebuilt, 
in normal way always when the PDMS starts. A local variable can be used only from within 
one PML function or macro. These two kinds of varia ble are distinguished by their names. 
Names beginning ‘!!’ are global; names beginning ‘! ’ are local.  
 
GLOBAL variable -  !!ThisIsGLOBALvariable 
LOCAL variable -  !ThisIsLOCALvariable 
 
 PML variable names may be any combination of lette rs and digits, starting with a letter, 
up to a maximum of 64 Unicode characters (plus the ‘!!’ or ‘!’). Names are allowed to contain 
a dot (.) but this is now strongly discouraged as a  dot has a special meaning in PML2 as a 
separator between an object and its methods, and be tween the components of form and 
gadget names. Therefore NEVER use dot (.) in names and NEVER start a variable name 
with a number! Rather than using a dot as part of a  name is recommend that you use a 
mixture of upper and lower case to make variable na mes more meaningful, for 
example:!!StartInUpperCase . Numbered variables are  set by typing a number then value 
after the command VAR. VAR 1 NAME, VAR 2 ‘hello’ . The available variable numbers only 
go to 119 (there is no 120) and they are module dep endent. For these reasons, this 
technique is no longer commonly used. 
2.1. PML2 variables 
 The variables used in PML 2 are objects: 
 
• Every object (variable) has a unique name.  
• An object has a set of functions associated with i t, which can be called to manipulate 
this data. These functions are called methods. 
• Some methods change the data held by the object, s ome return a result derived from 
the data, and some methods do both.  
• The data that an object can hold and the functions  that are available are fixed by the 
object type (sometimes called the object’s class). 
• Before you can create an object, the object type m ust have been defined. The object 
type definition specifies what the members and meth ods are for that type of object. 
 
 Every PML2 variable has an object type which is se t when the variable is created and 
remains fixed as long as the variable exists. Attem pting to store a value of the wrong type in 
an existing variable will cause an error. The objec t type must exist before you can create a 
variable of that type. PML 2 is supplied with: 
 
• built-in object types 
• system-defined object types 
• user-defined object types. 
 The built-in object types 2.1.1. 
• STRING  holds any text, including newline and multi-byte c haracters. In macros written 
with PML1 where variables are created with the VAR command, all variables are of 
type STRING, even when they are storing numbers. 
• REAL  is used for all numeric values including do loop c ounters. The values stored are 
(nearly) always in the current working units of the  quantity 
• BOOLEAN  is used for the result of logical expressions and holds the value TRUE or 
FALSE (Note these are not the same as the STRING va lues ‘TRUE’ and ‘FALSE’). 

--- Page 12 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 12/178  • ARRAY  holds many values of any type. An ARRAY variable c an contain many values, 
each of which is called an array element. An Array is created automatically by 
creating one of its array elements. 
 The system-defined object types 2.1.2. 
• Position, Orientation, DirE, P0, P1 … 
• Bore, Hbore, Href … 
• Dbref, Dbname, Dbfile … 
 
Examples: 
BLOCK  blocks are used to store commands for a special fo rm of working on arrays. The 
block contains a list of commands and “block Evalua tion” is used to perform the actions on 
an array 
FILE  file is in principle a file name, but the file obj ect contains built in methods for working on 
the file. 
DATETIME  returns current Date and Time information 
DB  a DB object is an object representing a database. Can be used to interrogate information 
about type, team, access, claim type 
DBREF  a dbref object a ref to a database it has members (access, file, name, number, 
foreign, type, description, claim (string) and team  (team)) 
DIRECTION  a Direction object has members (direction, origin (dbref), up, east, north (real)) 
MDB  MDB object has members (name and description, both  strings) 
ORIENTATION  an orientation object has members (alpha (real), o rigin (dbref), Gamma and 
beta(reals)) 
POSITION  a position object has members (origin (dbref) up, east, north (reals) 
PROJECT  a project object has one member (evar (string)) 
TEAM  a team object has members (name and description (r eals)) 
USER  a user object has members (access, name, descripti on (strings)) 
FORMAT  is a way of formatting data for example metric or imperial] 
 The user-defined object types 2.1.3. 
 You may find that the object types supplied with P ML 2 are enough. However, you can 
define new object types if you need to. In any case , the following example may help you 
understand objects, their members and how they are used. It is a good idea to use upper 
case for object-type names, and mixed upper and low er case for variable names, the objects 
themselves. For example, a type might be Employee, and a variable name might be 
NumberOfEmployees. 
 
define object COMPANY 
 member .Name   is STRING 
 member .Address   is STRING 
 member .Employees   is REAL 
 member .NumberOfEmpliyees is REAL 
endobject 
 
 The user-defined object type should by normally st ored in a file with a lowercase name 
matching the name of the object type and a .pmlobj  suffix in PMLLIB  directory. PML will 
load a definition automatically when it is needed. Example above should have name 
company.pmlobj . 
  

--- Page 13 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 13/178  2.2. Creation of variables 
2.2.1. PML1 variables creation 
For creating variable is used VAR command. As value  in variable could be used text or 
some attribute. As you may see there are used text delimiters to define any text as value. 
These delimiters could be used '' or vertical bars || as well. The most important fact is that 
using the VAR command always create variable as str ing() object. Even if you use numbers 
or Booleans. Of course that you can create an array  by VAR command but array itself 
contain array members. Through command VAR you just  fill an array by string elements. 
REMEMBER THAT VAR COMMAND ALWAYS CREATES STRING OBJ ECT TYPE!!! 
 
Text - as string in PML2: 
 
 VAR !PML1text 'THISisTEXT' 
 VAR !PML1attribute1 NAME 
 VAR !PML1attribute2 POS WRT /* 
 
Numbers - as real in PML2: 
 
 VAR !x (32) 
 VAR !y (52) 
 VAR !z1 (!x + !y) 
 VAR !z2 ('!x' + '!y') 
 VAR !z3 ('$!x' + '$!y') 
 VAR !z4 (23 * 1.8 + 32) 
 
Boolean - as  Boolean in PML2: 
 
 VAR !T1 TRUE 
 VAR !F1 FALSE 
 VAR !T2 T 
 VAR !F2 F 
 VAR !T3 YES 
 VAR !F3 NO 
 VAR !T4 Y 
 VAR !F4 N 
 
There are no BOOLEAN () object variables in PML1. V AR command always creates the 
STRING () object type. 
 
Array - as array in PML2: 
 
 VAR !ARRAY[1] 'AVEVA' 
 VAR !ARRAY[10] NAME 
 VAR !ARRAY[20] (12) 
 
2.2.2. PML2 variables creation 
Using the PML2 syntax you will create not only the value for variable but you 
automatically assign the object type according to d efined data. If it is simply text, then results 
as string object but some data as position are alre ady defined as some other object type. In 
this case the position is system defined object typ e therefore results as POSITION. This is 
the most important difference between PML1 and PML2  because PML2 is object orientated 
language. 
  

--- Page 14 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 14/178  String: 
 
!PML2string = 'THISisTEXT' 
 !PML2attribute1 = NAME 
 !PML2attribute2 = POS WRT /* (in PML1 will be stri ng in PML2 position object type) 
 
Real: 
 
 !x = 32 
 !y = 52 
 !z1 = (!x + !y) 
 !z2 = ('!x' + '!y') 
 !z3 = ('$!x' + '$!y') 
 !z4 = (23 * 1.8 + 32) 
 
Boolean: 
 
 !T1 = TRUE 
 !F1 = FALSE 
 !T2 = T 
 !F2 = F 
 !T3 = YES 
 !F3 = NO 
 !T4 = Y 
 !F4 = N 
 
Array: 
 
 !ARRAY = ARRAY() 
 !ARRAY[1] = 'AVEVA' 
 !ARRAY[2] = NAME 
 !ARRAY[3] = 12 
 !ARRAY[4] = N 
 !ARRAY[5] = TRUE 
2.3. Members and Attributes 
 An object can contain one or more items of data re ferred to as its members or attributes. 
Each member has a name. 
 
• STRING, REAL and BOOLEAN variables just have a val ue - no members. 
• ARRAY variables have numbered elements, not member s. 
 
 User Defined Objects can contain any variable or o bject type as attributes or members. 
Information is grouped with an object for ease of r eference and standard reference. User-
defined objects can also contain user-defined metho ds that will use the information stored 
within the object. These methods may represent a ca lculation, or information retrieval. After 
an object has been declared as a variable, the meth ods can be applied to the variable. For 
example: 
 
define object ELEMENT 
  member .Type is STRING 
  member .Material is STRING 
endobject 
 
define method .FullDesc() is STRING 
  return !this.Type & ‘ ‘ & !this.Material 
endmethod 

--- Page 15 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 15/178  Once a variable is declared as an ELEMENT object th en the method can be applied. 
 
!item = object ELEMENT() 
!Item.Type = |Flange| 
!Item.Material = |Carbon Steel| 
!name = !item.FullDesc() 
 
 A method with no arguments but the same name as th e type of the object is called the 
default constructor method. More than one method ca n be given the same name as the 
object, provide only one has no arguments. The foll owing lists the methods available to all 
objects. The list gives the name of each method and  the type of result you get back from it. 
The third column of the table describes what the me thod does. 
 
 Name Result  Purpose 
Attribute( 'Name') ANY To set or get a member of an  object, providing 
   the member name as a STRING. 
Attributes() ARRAY OF STRINGS To get a list of the names of the members of an 
   object as an array of STRING. 
Delete() NO RESULT  Destroy the object - make it un defined 
EQ(any) BOOLEAN  Type-dependent comparison 
LT(any) BOOLEAN  Type-dependent comparison (convert ing first to 
   STRING if all else fails) 
Max(any) ANY  Return maximum of object and second o bject 
Min(any) ANY  Return minimum of object and second o bject 
NEQ(any) BOOLEAN  TRUE if objects do not have the s ame value(s) 
ObjectType() STRING  Return the type of the object as a string 
Set() BOOLEAN  TRUE if the object has been given a value(s) 
String() STRING  Convert the object to a STRING 
Unset() BOOLEAN  TRUE if the object does not have a  value 
2.4. Naming conventions 
 Use a naming convention to avoid 'polluting the na mespace’ of global variables. All global 
names beginning with the letters CD are reserved fo r AVEVA system use. Note: The most 
recent AVEVA Application ware (AppWare) does not us e a prefix. When creating new PML 
Macros you are responsible for avoiding name-clashe s, for example, by using your own 
prefix. Here are some guidelines on naming variable s: 
 
• Use each variable for one purpose only and give it  a meaningful name. 
• Limit your use of global variables. 
• Where possible use PML object methods and Form met hods instead of PML functions 
and macros so as to make use of their members and m ethods which do not global 
variables. 
• Remember that within the methods of PML Objects an d Forms you generally need 
only local variables. Any values which are to be ex ported should be made available 
as members or as method values or returned argument s. 
• Only use PML Functions (necessarily global) for ta sks which are genuinely globally 
accessible, i.e. independent of a specific object o r form, or which need to be shared 
by several objects or forms. 
 
Note:  Do not use these prefixes for global or local vari ables. These prefixes are already 
used by other applications. 
  

--- Page 16 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 16/178  Application Prefix Comments 
Area BasedADP !!ABA  Add-in application 
Administration !!ADM  Plus !!CDA 
Application Switching !!APP  
Batch Handling !!BAT  
CADCentre !!CADC  
Draft !!CDR  
Draft Icon Location  !!CD2D  Icon pathnames 
Defaults !!DFLTS  
General !!CDC  Plus !!CDD, E, F, G, H, I, L, M, N, P, S, U, V, W 
Specialized !!CE  Plus !!ERROR, !!FMSYS 
 
The majority of the existing PML2 code has been giv en a 3or4 letter prefix to the full name. 
 
Application Prefix Comments 
Accommodation ACC 
Administration ADM 
Access, Stairs & Ladders ASL 
Area Based ADP ABA Add-in application 
Assembly ASSY 
Associations ASSOC None apparent 
Common COMM Mixed 
Design DES Mixed 
Draft DRA Plus ADP, DGN, DXF 
Global GLB 
Hull Design HULL 
Hull Drafting HDRA None 
Integrator INT 
 
Application Prefix Comments 
Isometric ADP ISO Add-in application 
Marine Diagrams DIAG No appware except main form 
Monitor MON 
Paragon CAT 
Review Interface REVI None - Single file 
Spooler SPL 
Vantage Marine VMAR No appware except start-up 
 
Icons are named without regard to any rules, except  on odd occasions. 
 
Application Prefix Comments 
Design DES Various 
Profile PRFL Various 
Schematic Model Viewer SMV Various 
Styles STY Plus FSTY 
  

--- Page 17 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 17/178  3. PML expressions 
3.1. PML 1 expressions 
• Text values 
VAR !CEname NAME  takes the current element’s (ce) name attribute as  string 
VAR !BRhbore HBORE  takes bran bore on hbore, even if its number varia ble is string 
VAR !X ‘NAME’ or VAR !X |NAME|  sets the variable to the text string ‘NAME’ 
 
Note:  Quotes ‘ ‘ or vertical bars | | may be used as tex t delimiters. 
 
• Number values 
VAR !x (32)  VAR !y (52) 
Expression VAR !z (!x + !y)  results as STRING 84  !!! 
Expression VAR !z (‘!x’ + ‘!y’)  results as STRING !x!y !!!  
Expression VAR !z (‘$!x’ + ‘$!y’ ) results as STRING 3252  !!! 
VAR !temp (23 * 1.8 + 32)  calculate a value and result is STRING 73.4 !!! 
 
Note:  VAR always obtain STRING (text) value even if expr ession calculate numbers!!! 
 
• Boolean values 
VAR !x TRUE 
 
Note:  This expression set variable!x as true. But this i s string text. This is not as PML2 
Boolean where condition is TRUE or FALSE or 0 or 1.  Booleans could be used as parameter 
in IF statement but from VAR evaluate STRING!!! 
 
• ARRAY  (array is variable with many values in rows) 
  VAR !ARRAY[1] 'AVEVA'   VAR !ARRAY[10] NAME 
 
Note:  VAR always obtain STRING (text) value even if coll ecting DB elements. The result is 
string value. 
3.2. PML 2 expressions 
• STRING 
!Name = ‘Fred’  create STRING variable 
 
• REAL 
!!Answer = 42  create REAL variable: 
Expression !z = !x + !y where !x=32 !y=52  results as REAL 84  !!! 
 
• BOOLEAN 
!!Flag = TRUE  create BOOLEAN variable. If false than is Boolean 0. 
 
• ARRAY 
!newarray = ARRAY()  create an empty ARRAY 
!newarray[1] = |xxx|  or !newarray[1] = ‘xxx ’ add first value to the empty ARRAY 
  

--- Page 18 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 18/178  3.3. Creating Unset and undefined variable 
 Each new data type supports a String() method that  returns a string representing the 
value of the variable. For example: 
 
!X = 2.5   $* defines a variable X of type REAL wit h 2.5 as its numeric value 
!S = !X.String()  $* will be a variable of type STR ING, with the value “2.5” 
!X = REAL()!  $* yields the string ’(the empty stri ng) 
!S = !X.String() 
!X = BOOLEAN() $* yields the string ‘’ (the empty s tring) 
!S = !X.String() 
!X = STRING()  $* yields the string ‘Unset’ 
!S = !X.String() 
!X = ARRAY()  $* yields the string ‘ARRAY 
!S = !X.String() 
 
 Other variable types are system-defined variables.  Most of these have adopted the unset 
string ‘Unset’. User-defined data types can also pr ovide a String() method. These also 
support an UNSET representation, and usually adopt the UNSET representation ‘Unset’.  
For example: 
 
!X = DIRECTION() $* yields the string ‘Unset’ 
!S = !X.String() 
 
 All data types can have the value UNSET which indi cates that a variable does not have a 
value. A variable created without giving it an init ial value in fact has the value UNSET: 
 
!!Answer  = REAL()  !Name   = STRING() 
!Grid   = BOOLEAN()  !Lengths  = ARRAY() 
 
 Variables with an UNSET value can be passed around  and assigned, but use of an 
UNSET value where a valid item of data is required will always result in a PML error. The 
presence of an UNSET value may be tested either wit h functions or methods: 
 
if ( Unset(!X) ) then if ( !X.Unset() ) then 
if ( Set(!X) ) then if ( !X.Set() ) then 
 
An UNDEFINED variable is one that does not exist. T he existence of a variable may be 
tested with these functions: 
 
if ( Undefined(!!Y) ) then  
if ( Defined(!!Y) ) then 
 
There is no equivalent method call. If the variable  does not exist, attempting to call a method 
would result in an error. 
3.4. Deleting PML Variables 
 A variable that exists can be explicitly made UNDE FINED with the Delete() method : 
 
!!Y.Delete()  Warning: You must not attempt to delete members of  objects or forms. 
3.5. Mixing of the variables types 
 Mixing PML1 and PML2 expressions could cause mixin g the variables types. Mixing the 
variables types give error for example: „Cannot ass ign variable to result - incompatible types 
(REAL=STRING)”. With VAR you will always obtain a S TRING. You could have defined 
variable type before you assign any value to the va riable: 

--- Page 19 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 19/178  !x = 64  this returns a REAL 
VAR !y (64)  this returns a STRING 
IF (!x eq !y)THEN  is invalid syntax because the comparison is mixing  variable types. In this 
case is necessary to put a dollar in front of mixed  variable, this forces STRING value  
IF (!x eq $!y) THEN  valid because the dollar in front of !y forces it to be a value not text. 
 
 Setting variables using PML2 method is more readab le when compared to PML1. PML 2 
expressions may be of any complexity, they may cont ain calls to PML Functions and 
Methods and include Form gadget values ,object memb ers and methods. $ and quotes are 
not necessary when using the value of a variable in  a PML2 expression. Calculations in 
expressions can be done in PML1 or PML2 style as fo llows: 
 
• PML1 
VAR !X (64) VAR !Y (32) VAR !Z (|$!X| + |$!Y|) 
• PML2 
!X = 64  !Y = 32  !Z = !X + !Y 
 
 In the PML1 example, !Z is set as a STRING variabl e as well as !X and !Y are STRING. 
In the PML2 example, !Z is returned as a REAL, if ! X and !Y are REAL. You cannot convert 
string variable to real if is defined as string typ e. You need to create another variable and 
convert text to number into this variable or you ne ed to delete and then reset variable as new 
variable type. See follow examples: 
 
VAR !BRhbore HBORE  takes hbore of bran in variable !BRhbore, but the result will be text 
string not number. In PDMS up to v.12 the result wi ll looks as (100) and from PDMS v12.1 
will looks as (100mm). With text string you cannot use mathematic formulas (+,-,/,*…). It’s 
necessary to convert this string to real. Syntax wi ll looks like : 
VAR !BRhbore REPLACE ('$!BRHBORE', 'mm', ' ')  …. take 100mm and removes mm 
Q VAR !BRhbore  check variable type, variable is text string with value 100  
!NR = !BRhbore.Real()  convert text string 100 to number 100 
q VAR !NR  check variable type, 100 is real (number) now. 
VAR !SUM ($!NR + 50)  now it is possible to add +50 to value 100. The re sult of variable !SUM 
will looks as 150 but the RESULT is STRING. 150 is now text value !!! Another expression is 
VAR !VALUE ($!BRhbore)  the RESULT is STRING. 
 
!x = REAL() !y = REAL()  this is PML2 form to create 2 REAL variables 
VAR !x (32) var !y (52)  now you have mixed PML1 to assign values, you will  obtain error : 
“(41,357)  Value being assigned or variable being a ssigned to is not of type STRING” !  
In this case is necessary to delete variables and c reate them again with new types as string. 
!x.delete() !y.delete() AND create again as new typ e !x=STRING() !y= STRING() 
3.6. Expression operators 
 There are a number of expression operators which a re available for use. The actual 
syntax will depend on whether a PML1 or PML2 style has been adopted. Operators are 
evaluated in the order of the following list: the o nes at the top of the list are evaluated first. 
 
• Brackets () are used to control the order in which  operators are evaluated (!A+!B)*2 
• Numeric operators: + - / * 
• Comparison operators: EQ NE LE GE LT GT 
• Logic operators: AND NOT OR 
• Numeric functions: SIN COS TAN SQR POW NEGATE ASIN  ACOS ATAN LOG 
ALOG ABS INT NINT 
 
Note:  Some examples of expressions in use: 

--- Page 20 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 20/178  !s = 30 * sin(45) 
!t = pow(20,2) (raise 20 to the power 2 (=400)) 
!f = (match (name of owner, |LPX|) GT 0) 
3.7. Boolean Operators 
 The Boolean, sometimes called Logical, operators h ave the following meanings: 
 
• EQ TRUE if two expressions have the same value. 
• NE TRUE if two expressions have different values. 
• LT TRUE if the first expression is less than the s econd. 
• GT TRUE if the first expression is greater than th e second. 
• LE OR LEQ TRUE if the first expression is less tha n or equal to the second. 
• GE OR GEQ TRUE if the first expression is greater than or equal to the second. 
• NOT TRUE if the expression is FALSE. 
• AND TRUE if both expressions are TRUE 
• OR TRUE if either or both expressions are TRUE. 
 
Note:  The operators EQ, NE, LT, GT, LE and GE are someti mes referred to as comparator 
or relational operators; NOT, AND, and OR are somet imes referred to as Boolean operators. 
Refer to Precisions of Comparisons for tolerances i n comparing numbers. 
 
Several different types of expressions examples: 
 
Logical expressions  - PDMS attributes 
Logical constants 
TRUE, ON, YES for true / FALSE, OFF, NO for false 
Logical Operators 
Comparator operators (EQ, NEQ, LT, GT, LEQ, GEQ) 
Boolean operators (NOT, AND, OR) 
Logical functions 
BADREF, DEFINED, UNDEFINED, CREATE, DELETED, EMPTY,  MATCHWILD, 
MODIFIED, UNSET, VLOGICAL…. 
Logical array expressions 
PDMS attributes e.g. XLEN YLEN POHE POSITION ORIENT ATION 
Numeric operator  -- + Add, - Subtract, * Multiply, / Divide 
Numeric function 
ABS, ACOS, ASIN, ATAN, SIN, COS, TAN, MATCH, MAX, S QRT.. 
Real expressions  - See numeric functions 
Text expressions  - A text string, PDMS attributes, Text operators, Text functions 
3.8. Concatenation Operator 
 Values to be concatenated are automatically conver ted to STRING by the ‘&’ operator. 
Type the following onto the command line: 
 
!a = 64 !b = 32 !m = ‘mm’ 
!c = !a & !b & !m 
q var !c 
 
Compare this against the results of typing 
!d = !a + !b 
q var !d 
  

--- Page 21 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 21/178  3.9. Communicating with AVEVA Products in PML 
 All commands need to be supplied to the command pr ocessor as STRINGS. This is 
important when working with element creation (using  the NEW syntax) to expand the 
contents of a PML variable into a string - put a $ in front of it! 
 
!CompType = |ELBO| !dist = 5600 
NEW $!CompType 
DIST $!dist 
3.10. Parameterized Macros 
 Macros can be parameterized. This means instead of  hard coding the values through the 
macro, the values can be referenced, allowing them to be varied. Simplemac.mac can be 
parameterized as follows: 
 
NEW EQUIP /$1 
NEW BOX 
XLEN $2 YLEN $3 ZLEN $4 
NEW CYL DIA $3 HEI $4 
CONN P1 TO P2 OF PREV 
 
 If no parameters are specified, the macro will fai l. To avoid this, default values can be put 
inside the macro. This is done by specified $d1= at  the top of the macro. For example: 
$d1=ABCDEF $d2=300 $d3=400 $d4=600  
3.11. Synonyms 
 Synonyms are abbreviations of longer commands. The y are created by assigning the 
command to a synonym variable: 
 
e.g. $SNewBox=NEW BOX XLEN 100 YLEN 200 ZLEN 300  
e.g. $SNewBox=NEW BOX XLEN $S1 YLEN $S2 ZLEN $S3  (A parameterized synonym) 
 
To call the first version, type NewBox. For the second version, type NewBox 100 200 300 
 
 If all synonyms are killed, the synonyms needed to  run PDMS will be removed. This 
means PDMS will no longer work properly and will re quire restarting. If synonyms are turned 
off, some PDMS functionality will also be removed. The return this functionality, the 
synonyms should be turned back on. 
 
To kill a synonym, type $SXXX= & all synonyms $sk 
To switch synonyms off and on $S- and $S+  
 
Note:  If all synonyms are killed, the synonyms needed to  run PDMS will be removed. This 
means PDMS will no longer work properly and will re quire restarting. If synonyms are turned 
off, some PDMS functionality will also be removed. The return this functionality, the 
synonyms should be turned back on. 
 
$S - defines a local synonym 
$G - defines a global synonym 
$U - prevents the deletion of a global synonym whic h has already been defined 
Global synonym ($G) works inside pml functions/meth ods while local ($S) does not. 
  

--- Page 22 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 22/178  3.12. Creating Other Types of Variable 
 You create variables of types that are system-defi ned or user-defined, using the OBJECT 
keyword. For example, to create a variable of type FACTORY: 
 
!NewPlant = object FACTORY() 
3.13. Using the Member Values of an Object 
 The way to set individual members of an object is to use the dot notation as follows: 
 
!NewPlant = object FACTORY() 
!NewPlant.Name = ProcessA 
!NewPlant.Workers = 451 !NewPlant.Output = 2001 
 
The dot notation is used in a similar way to access  the value of a member of an object: 
 
!People = !NewPlant.Workers  sets the variable !People to 451. 
3.14. PML Functions and Methods 
 Functions and Methods may optionally have argument s that can be used to return values. 
Arguments have a data type which is specified in th e function or method definition and they 
are checked when the Function or Method is called. An argument may be one of the built-in 
types REAL, STRING or BOOLEAN; an ARRAY; a built-in  object or a user-defined object or 
specified as ANY. Functions and methods can optiona lly return values as their results. 
Functions that do not return values are known as PM L Procedures. 
Here is a definition of a PML Function that has two  REAL arguments. It also has a REAL 
return value, as shown by the final is REAL. Inside  a function, the arguments are referenced 
just as if they were local PML Variables. The RETUR N keyword is used to specify the 
variable that stores the return value: 
 
define function !!Area( !Length is REAL, !Width is REAL ) is REAL 
  !Area = !Length * !Width 
  return !Area 
endfunction 
 
Note:  You cannot switch to a different PDMS module if a PML Function is running. Use EXIT 
to exit from the function if it has failed to compl ete. 
 
When a PML Function is called, all the PML Variable s passed as arguments must already 
exist. In addition, arguments used for input must h ave a value, which could be a constant, 
when the function is called: 
 
define function !!LengthOfName(!Name is STRING) is REAL 
  !TidyName = !Name.trim() 
  return !TidyName.Length() 
endfunction 
 
The function is called to set the value of a variab le !Length as follows: 
 
!Length = !!LengthOfName( ' FRED ') 
 
Here ' FRED ' is a string constant passed as an arg ument. We could rewrite this function so 
that it returns its results by changing its argumen ts. The output argument, !Length, will be set 
to the value required when the function is called: 
 

--- Page 23 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 23/178  define function !!LengthAndTrim(!Name is STRING, !L ength is REAL) 
  !Name = !Name.Trim() 
  !Length = !Name.Length() 
endfunction 
 
Arguments used for output must exist prior to the c all and one that is also used as an input 
argument must also have a value: 
 
!Name = ' FRED ' !Length = REAL() 
 
The function is called to set the value of a variab le !Length as follows: 
 
!!LengthAndTrim(' FRED ', !Length) 
 
When an argument value is changed within a PML Func tion its value outside the function is 
also changed. The following call is incorrect, as t he function cannot modify a constant: 
 
!!LengthAndTrim(' FRED ' ,4 ) $* WRONG 
 
A PML Function returning a value may be used wherev er an expression or PML Variable 
can be used, for example, this call to the !Area fu nction defined above: 
 
!PartLength = 7 !PartWidth = 6 
!SurfaceArea = !!Area(!PartLength, !PartWidth) 
3.15. Storing and Loading PML Functions 
 When a PML Function is called it is loaded automat ically from its source file in a directory 
located via the environment variable PMLLIB. The na me of the external file must be 
lowercase and must have the .pmlfnc suffix. The sou rce of a PML Function invoked as 
!!AREA or !!Area or !!area all correspond to the fi le named area.pmlfnc. 
 
Note:  The !! signifies that the function is user-defined  and that it is global - but !! does not 
form part of the external filename. All user-define d functions are global and only one may be 
defined per file. The define function must be the f irst line in the file and that its name and the 
file name must correspond. 
3.16. Arguments of type ANY 
 You may specify ANY as the type of an argument (an d even as the type of the function 
return value). 
 
Note:  The use of ANY should be the exception rather than  the rule as it switches off 
argument type checking - an important feature of PM L Functions to help ensure correct 
functioning of your PML. 
 
In the case an argument of type ANY, a value of any  type may be passed as the argument to 
the function: 
 
define function !!Print(!Argument is ANY) 
  $P $!Argument 
endfunction 
 
Where an argument of type ANY is used, you may need  to find out its actual type before you 
can do anything with it. The ObjectType() method ca n be used for this purpose: 
  

--- Page 24 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 24/178  define function !!AnyType(!Argument is ANY) 
  Type = !Argument.pmlobjectType() 
  if ( !Type EQ 'STRING' ) then 
    - - do something with a STRING 
  elseif ( !Type EQ 'REAL' ) then 
    - - do something with a REAL 
  elseif ( !Type EQ 'DBREF' ) then 
    - - do something with a DB Reference 
  else 
    - - do something with all other types or give a n error 
  endif 
endfunction 
3.17. PML Procedures 
 A PML Procedure is a PML Function that does not re turn a result. A function is defined as 
a procedure by omitting the data type at the end of  the define function statement: 
 
define function !!Area( !Length is REAL, !Width is REAL, !Result is REAL) 
  !Result = !Length * !Width 
endfunction 
 
Here we are using an output argument, !Result, to r eturn the result rather than using a 
function return value. The arguments to the !!Area procedure can be set as follows, and then 
the procedure invoked with the call command. 
 
!SurfaceArea = REAL() 
!Partlength = 7 
!PartWidth = 6 
call !!Area(!PartLength, !PartWidth, !SurfaceArea) 
 
There will be an error if you attempt to assign the  result of a PML Procedure because there 
is no return value to assign. So, for example you c an say: 
 
call !!Area(!PartLength, !PartWidth, !SurfaceArea) 
!Answer = !SurfaceArea 
 
But you cannot say: 
 
!Answer = !!Area(!PartLength, !PartWidth, !SurfaceA rea) 
$* WRONG 
 
The ( ) parentheses after the name of a procedure o r function must always be present even 
for procedures that do not need arguments: 
 
define function !!Initialize() 
  !TotalWeight = 0 
  !!MaxWeight = 0 
endfunction 
call !!Initialize() 
 
Although the call keyword is strictly speaking opti onal, its use is recommended with 
procedures. 
 
Note:  As well as procedures, you can invoke a PML Functi on that has a return value using 
call, in which case the function result value is di scarded. 

--- Page 25 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 25/178  3.18. Using the Methods of an Object 
 A method is a function that is specific to an obje ct. The Software Customization 
Reference Manual contains a table of the object typ es supplied as part of PML 2. For each 
object type, there is a list of the associated meth ods and members. For each object type, the 
table shows: 
 
Name  The name of the method or member. For example, a R EAL object has a method 
named Cosine. If there are any arguments, they are indicated in the brackets () after the 
name. For example, the REAL object has a method nam ed BETWEEN which takes two 
REAL arguments. 
Result or Type  For members, we use the heading Type; for methods,  we use the heading 
Result. The type of the member or the result descri bes what kind of object we are expecting 
to see as a member or result of the method. For exa mple, the result of the method Cosine is 
a REAL value. Some methods do not return a value: t hese are shown as NO RESULT. 
Status This column is used to give other information about  the method or member. For 
methods, this column tells you whether the method m odifies the state of the object. For 
members, this column tells you whether the member i s Mutable (by the user) or Read Only. 
Note that for the system-defined PDMS object types,  members correspond to PDMS 
attributes 
Purpose  This column tells you what the member or method do es. 
 
 This section explains how to use methods, using a STRING variable as an example. 
Although the STRING is a simple object type, it has  a large number of methods which can 
be called. For example, if you are interested in th e length of the string value, look under the 
list in the Software Customization Reference Manual  for STRING objects, and you will find 
a method named Length. This method returns a REAL v alue (the number of characters in 
the string), but has no effect on the variable itse lf. You can extract the number of characters 
in the string and store it in a new variable, !Ncha rs, by calling the method as follows: 
 
!Nchars = !MyString.length() $* A method call 
 
Notice the dot separator between the name of the va riable and the name of the method. Also 
note the ( ) brackets following the name of the met hod. The brackets are used to enclose the 
arguments of the method, but they must be present e ven if there are no arguments. 
3.19. Methods on User-Defined Object Types 
 When you define a new object type, you can also de fine methods which can be used to 
handle all objects created with the new type. PML M ethod definitions are stored in the same 
file as the object definition, after the endobject command. Here is an example of an object 
which defines three methods to illustrate the main ideas. Note that within a method, !This 
represents the object which invoked the method and !This.Answer is the way to refer to 
member Answer of this object. 
 
Defines the object, with a single member, Answer. 
 
define object LIFE 
  member .Answer is REAL 
endobject 
 
Defines a method with no arguments but the same nam e as the type of the object is called 
the default constructor method. If the default cons tructor method is present, PML will call it 
automatically to initialize the object whenever an object of that type is created. 
  

--- Page 26 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 26/178  define method .Life() 
  !This.Answer = 42 
Endmethod 
 
A method may return a result in just the same way a s a PML Function using the return 
command. Set a member of the object using !This.mem bername. 
 
define method .Answer() IS REAL 
  return !This.Answer 
endmethod 
 
define method .Answer( !Value Is REAL) 
  !This.Answer = !Value 
Endmethod 
 
These methods might be used in the following way: 
 
!Marvin = object LIFE() 
-- The method .Life() was called automatically 
!Number = !Marvin.Answer() 
-- !Number is set to the value 42 
!Marvin.Answer(40) 
!Number = !Marvin.Answer() 
-- !Number now has the value 40 
 
Warning: When you create a new object type, or chan ge an existing definition, you 
must load the definition by giving the command: 
 
pml reload object _name_ 
3.20. Method Overloading 
 Two or more methods on an object may share the sam e name providing they have 
different arguments. This is called method overload ing. PML will invoke the method with the 
arguments which match the method call. It is common  practice: 
 
• To use a method with the same name as a member and  one argument of the same 
type to set the member’s value. For example: 
 
!Marvin.Answer(65) 
 
• To use a method of the same name as a member retur ning a value of the same type 
but with no arguments to get the member’s value. Fo r example: 
 
!Number = !Marvin.Answer() 
3.21. Constructor Methods with Arguments 
 When an object is created, it is possible to suppl y arguments that are passed by PML to a 
constructor method with matching arguments instead of the default constructor method: 
 
!Marvin = object LIFE(40) 
 
This would invoke a method: 
 
define method .Life(!Value IS REAL) 

--- Page 27 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 27/178  3.22. Overloading with ANY 
 As with PML Functions, the type of a method argume nt may be specified as ANY. If 
method overloading is being used, PML will invoke t he method with a matching set of 
explicitly typed arguments in preference to calling  a method with arguments of type ANY, 
irrespective of the order the methods appeared in t he object definition file: 
 
define method .SetValue( !Argument Is ANY) 
define method .SetValue( !Argument Is REAL) 
 
Then: !SomeObject.SetValue(100)  will invoke the method with the REAL argument, but  
!SomeObject.SetValue(‘Priceless’ ) will invoke the method with the ANY argument. 
3.23. Invoking a Method from Another Method 
 Within a method !This.Methodname() refers to anoth er method on the same object. So 
our second LIFE constructor method, the one with an  argument, could be defined as: 
 
define method .Life(!Value IS REAL) 
  !This.Answer(!Value) 
endmethod 
3.24. Developing a PML Object with Methods 
 Whenever you add a new method to an object, you ne ed to tell PML to re-read the object 
definition, by giving the command: 
 
pml reload object life 
 
It is not necessary to use this command if you are simply editing an existing method 
(although you will have to use it if you edit a for m definition file, and change the default 
constructor method, described in Form Definition Fi le.) 
3.25. Forms as Global Variables 
 In PML 2, forms are a type of global variable. Thi s means that a form cannot have the 
same name as any other global variable or any other  form. Note that a form definition is also 
the definition of an object, so a form cannot have the same name as any other object type. 
 
  

--- Page 28 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 28/178  4. ARRAYs in PML 
 An ARRAY variable can contain many values, each of  which is called an array element. 
An Array is created automatically by creating one o f its array elements. 
 
!Array = Array() 
 
This is an empty variable but it has been defined a s an array. Adding elements to the array: 
 
Type 1 
!Array[1] = ‘BOB’  !Array[2] = 45  !Array[10] = !!C E 
Type 2 
!Array.Append(‘BOB’)  !Array.Append(45) !Array.Appe nd(!!CE) 
 
 Type 1 adds string values into exact position of a rray element (1,2 and 10). Type2 add 
string values to the end of lists (11,12,13). To ch eck array list query : 
 
q var !Array 
<ARRAY> 
[1]   <STRING> 'BOB' 
[2]   <REAL> 45 
[10]  <DBREF> 'KELLY' 
[11]  <STRING> 'BOB' 
[12]  <REAL> 'GEORGE' 
[13]  <DBREF> 'KELLY' 
 
To check exact array member query: 
 
q var !Array[1] 
<STRING> 'BOB' 
 
Note:  How array elements are referred to by means of a s ubscript expression in [ ] square 
brackets and that there must be no space between th e end of the array name and the 
subscript. Array elements are accessed in the same way when using the value in an 
expression: 
 
!Average = ( !Sample[1] + !Sample[2] + !Sample[3] )  / 3 ) 
 
The individual elements of an array variable can be  set independently and in any order. Thus 
you can set !X[1] and !X[10] without setting any of  the intervening elements !X[2] to !X[9]. In 
other words PML arrays are allowed to be ‘sparse’ a nd to have gaps between the subscript 
numbers which have values set. Negative subscripts are no longer permitted. An array 
subscript of zero is allowed but you are advised ag ainst using it as many of the array 
facilities ignore array element zero. An array subs cript may be an expression of any 
complexity provided it evaluates to a positive REAL  result and may even include a call to a 
PML Function: 
 
!Value = !MyArray[!A + (!B * !!MyFunction() ) + !C ] 
 
PML Arrays may be heterogeneous. That is to say the  elements of a PML array do not have 
to be all of the same type. Array elements may even  be user-defined objects. Values to be 
concatenated are automatically converted to STRING by the ‘&’ operator. Type the following 
onto the command line: Non-existent array elements - after the last set element of the array 
and the non-existent elements in the gaps of a spar se array - are all UNDEFINED: the 
function Undefined() will return TRUE and the funct ion Defined() will return FALSE for all 
these subscripts.  

--- Page 29 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 29/178  4.1. Array methods 
 Array methods are built-in functions for performin g a variety of operations on the array. 
These methods are invoked with a dot following the array name. The method name must be 
followed by ( ) parentheses - even if the function has no arguments. Array methods : 
 
• !Array.Size() 
• !Array.Clear() 
• !Array.RemoveFrom(x,y) 
• !Array.Append() 
• !Array.Delete() or !Array[N].Delete() 
• !Array.Split() 
• !Array.Width() 
• !Array.Sort() 
• !Array.Inver() 
• !Array.SortUnique() 
• !Array.Unique() 
 
Note:  Always use an array method, if one is available, i n preference to constructing a do 
loop as it is far more efficient. 
 
!Nelements = !MyArray.Size() 
This method sets !Nelements to the number of elemen ts currently in the array. Its returns a 
REAL result which can be assigned to another variab le. 
 
!MyArray.Clear() 
This is an example of a method which modifies the a rray by deleting all the array elements 
but produces no-result value, so there is nothing t o assign to another variable. 
 
!NewArray = !OldArray.RemoveFrom(5,10) 
This is an example of a method result which modifie s the array by removing 10 elements, 
starting at element 5. NewArray value is a new arra y containing the 10 removed elements. If 
not required, the result can be simply discarded by  invoking the method as a command and 
not assigning the result to a variable: !OldArray.RemoveFrom(5,10)  
 
!Result.Append(!NewValue) 
To set a new element at the end of an existing arra y without needing to know which 
elements are already set, use the Append() method. The new array element to be created is 
determined automatically by adding 1 to the highest  existing index for the array !Result. The 
data are stored in !Result[1] if the array does not  yet contain any elements. The array !Result 
must exist before you can call this method. If nece ssary you can create an empty array (with 
no elements) beforehand: !Result = ARRAY() .If !Res ult exists already as a simple variable, 
you will get an error and the command is ignored. 
 
!MyArray[N].Delete() 
To destroy an array element use the Delete() method . The deleted array element would test 
as UNDEFINED. Note that the array continues to exis t even when you have deleted all its 
elements. Deleting the entire array, together with any existing array elements, use the Delete 
method on the array itself: !MyArray.Delete()  
 
!ArrayOfFields = !Line.split() 
You can split a text string into its component fiel ds and store each field in a separate array 
element using a text string’s Split() method. This can be useful after reading a record from a 
file into a variable. By default, the delimiter is any white-space character (tab, space or 

--- Page 30 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 30/178  newline): !Line = '123 456 789' The white-space is treated as a special case since 
consecutive white-spaces are treated as a single de limiter and white-spaces at the start or 
finish of the string are ignored. The result is to create the array-variable !ArrayOfFields (if it 
does not already exist) with the element !FIELDS[1]  set to '123', !FIELDS[2] set to '456', and 
!FIELDS[3] set to '789'. To specify a different del imiter, specify the required (single) 
character as the argument to the Split() method: 
 
!Line = '123 ,456 ,,789' 
!ArrayOfFields = !Line.split(',') 
In this example, comma is used as the delimiter. !A rrayOfFields is created if it does not 
already exist with the element !FIELDS[1] set to '1 23', !FIELDS[2] set to '456', !FIELDS[3] 
created but set to zero length, and !FIELDS[4] set to '789'. Note that in this case, unlike the 
white-space delimiter, consecutive occurrences of t he comma define empty elements. Note: 
The only way to set the special white-space delimit er is by default; that is, by not specifying 
any delimiter as an argument to the Split() method.  If a space is specified explicitly as the 
delimiter (as ' '), it will behave in the same way as comma in this example. You can combine 
an array-append method with a text-string Split() m ethod in a single command to append the 
fields of a text string to the end of an existing a rray variable, thus: 
!ArrayOfFields.AppendArray(!Line.Split()) 
 
!Width = !List.width() 
The length of the longest element in an array can b e a useful thing to know, for example 
when you are outputting the values in table form. Y ou can do this using the Width() method. 
For example, in the array !LIST: 
!LIST[1]'One' !LIST[2]'Two' !LIST[3]'Three' 
The command: 
!Width = !List.width() would set to !Width to the v alue 5, the length of the longest element in 
!LIST, which is ‘Three'. Note: If the array contain ed elements that were not strings, these are 
ignored when calculating the maximum width. 
 
!MyArray.Sort() & !MyArray.Sort().Invert() 
The simplest way of sorting an array is to use the Sort() method: !MyArray.Sort() This is a 
no-result method that modifies the array by perform ing a sort in-situ. The sort is into 
ascending order and will be an ASCII sort on an arr ay of STRING elements and a NUMERIC 
sort on an array of REAL values. The Sort() method returns the array itself as a list result, so 
it is possible to follow the call to the Sort() met hod immediately with a call to the Invert() 
method, which will return a descending sort: !MyArr ay.Sort().Invert(). An alternative 
approach is an indirect sort using the method Sorte dIndices() which returns a REAL array 
representing new index positions for the array elem ents in their sorted positions: 
!NewPositions = !MyArray.SortedIndices() The array can be sorted by applying the new 
index values using the ReIndex() method: !MyArray.R eIndex(!NewPositions) More important, 
the index values in !NewPositions can be used to so rt other arrays as well. 
 
To use some simple examples, imagine we had the arr ay !Animals that contained: 
[1] Wombat [2] Kangaroo [3] Gnu [4] Aardvark [5] An telope 
 
The command:  !Animals.Sort ()  
 
Would move the array elements so that they now appe ared in the following order: 
[1] Aardvark [2] Antelope [3] Gnu [4] Kangaroo [5] Wombat 
 
The command: !Animals.Invert () invert the sort to following order : 
[1] Antelope [2] Aardvark [3] Gnu [4] Kangaroo [5] Wombat 
  

--- Page 31 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 31/178  4.2. Sorting Arrays using the VAR Command 
 These facilities were designed to work with arrays  of STRINGS. Where a multi-level sort 
is required it is still necessary to use the older facilities of the VAR command to perform the 
sort. Using a different example, look at the arrays  !Car, !Colour and !Year: 
 
VAR !Index SORT !Car CIASCII !Colour !Year NUMERIC 
 
 Sorting   Option Effect  
CIASCII Sorts in ascending case-independent alphabe tic order. 
DESCENDING Sorts in alphabetic in reverse order 
CIASCII DESCENDING Sorts in descending case-indepen dent alphabetic order. 
NUMERIC Forces an ascending numerical sort on numbe rs held as strings. 
NUMERIC DESCENDING Forces a descending numerical so rt on numbers held as strings. 
 
You can also modify the array to eliminate empty or  repeated elements: 
 
UNIQUE  - Eliminates instances of duplicated data. For exa mple: 
 
VAR !Index SORT UNIQUE !Car CIASCII !Colour !Year N UMERIC 
 
NOUNSET NOEMPTY  - Eliminates rows that contain only UNSET values. 
 
VAR !Index SORT NOUNSET !Car CIASCII !Colour !Year NUMERIC 
 
To sort these arrays and identify the last occurren ce of each group of the same car type, use 
the LASTINGROUP  option: 
 
VAR !Index SORT !Car LASTINGROUP !Group 
4.3. Subtotaling Arrays with the VAR Command 
Suppose we had sorted the array !Car and another ar ray !Value using the command: 
 
VAR !Index SORT !Car !Value LASTINGROUP !Group 
 
We can then generate an array of subtotals for each  type of car with the following command: 
 
VAR !Totals SUBTOTAL !Values !Index !Group 
 
VAR !variable SUBTOTAL  - This will sum value strings that contain values with or without 
unit qualifiers. Unit qualifiers within the strings  will be ignored. This is to allow REPORTER to 
still operate with unit qualified value strings tha t may have been introduced by other VAR or 
$!variable commands. 
 
VAR !variable EVALUATE  - Will return string variables and arrays of unit qualified values if 
the evaluation generates quantities with physical d imensions. VAR !D EVAL (DIAM) for all 
CYLI - sets !D to a set of strings such as '90cm' ' 60cm' etc. - when cm are the current length 
units). The unit will be the current working unit. 
 
VAR !variable ATTRIBUTE  This sets the variable to a string that contains t he value AND 
the unit qualifier for attributes with of a physica l quantity VAR !X XLEN sets !X to '46cm' if 
current units are cm) The unit will be the current working unit. 
  

--- Page 32 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 32/178  5. Collections 
 A very powerful feature of the PDMS database is th e ability to collect and evaluate data 
according to rules. There are two available methods  for collection PML1 syntax PML2 
objects. Both methods are still valid. Before typin g out the following onto the command, 
ensure the STABILISER plant is the CE. 
5.1. The Collection Syntax PML 1 
var !zone collect all zones for site 
var !name eval name for all from !zone 
q var !zone !name 
var !equi coll all equi with owner eq /EQUIP 
q var !equi 
!!CE = !equi[1].dbref() 
var !box coll all box for ce 
var !volume eval (xlen * ylen * zlen) for all from !box 
q var !volume 
5.2. The Object Collection Syntax PML 2 
!equiColl = object COLLECTION() 
!equiColl.type(‘EQUI‘) 
!equiColl.scope(!!ce) 
!expr = object EXPRESSION(|PURP eq ‘PUMP’|) 
!equiColl.filter(!expr) 
!results = !equiColl.results() 
q var !results 
 
Note:  For this method to work, a collection object must be declared and used. For the 
COLLECTION’s .filter() method to be used, it must b e given an EXPRESSION object as an 
argument. Using a collection object makes its built -in methods available for users. 
 
 PML2 can be easier to manage. Also being object or ientated, there is room for extensions 
to be added as new methods to the object with no ch ange to the basic definition, whereas 
with the PML1 version, this could be done, but you command line syntax might get a little 
long and verbose. The following examples are basica lly the same collection one using PML1 
the other using the PML 2 object. Both have their a dvantages and disadvantages. 
5.3. The collection examples 
Example 1 : 
 
PML 1 collection 
 
var !!sectionPML1 collect all (SCTN) with (GTYP eq 'BEAM') for World 
 
PML 2 Collection 
 
Scope element in the hierarchy collection it done f rom equates to "for World" 
!scope = World 
 
Type element(s) type to look for equates to "all (S CTN)" 
!elementType = 'SCTN' 
  

--- Page 33 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 33/178  Expression search criteria applied to collection eq uates to "with (GTYP eq 'BEAM')" 
!expression = object EXPRESSION() 
!expression.expression('GTYP eq ''BEAM''') 
Define Collection 
!collection = object COLLECTION() 
!collection.scope(!scope) 
!collection.addType(!elementType) 
!collection.filter(!expression) 
!!sectionPML2 = !collection.results() 
 
Example 2 : 
 
PML 1 collection 
 
var !myColl collect ALL (VALV INST) WITH (spec of s pref eq /INST ) FOR /TUB_PRUEBA 
/Tuberias_para_aplicaciones 
 
PML 2 Collection 
 
!myColl = !!CollectAllFor('VALV INST', 'spec of spr ef eq /INST', /TUB_PRUEBA 
/Tuberias_para_aplicaciones 
!coll = object COLLECTION() 
!coll.type('<gtype>') 
!coll.scope(<dbref>) 
!coll.filter(<expression>) 
!coll.initialise() 
!ListOfItems = !coll.results() 
 
Note:  Remember that this returns an array of DBREFS and not STRINGS 
 
Example 3 : 
 
PML 1 collection 
 
var !test coll all pipe with matchw (purp,'*yourpur pose*') within vol ce 1000 
var !test1 eval name for all from !test 
!dat = 'c:/temp/excel.csv' 
!output = object file (!dat) 
!output.writefile ('WRITE',!test1) 
!output.close() 
syscom 'c:/temp/excel.csv&' 
 
Example 4 : 
 
PML 2 collection 
 
!coll = object COLLECTION() 
!coll.type('TRFAIL') 
!coll.scope(!trinco) 
!coll.filter( object EXPRESSION('OWNER eq TRMLST') ) 
!coll.initialise() 
!scope = !coll.results() 
 
-- Create an array of list names (for the dropdown)  
!listNames = object ARRAY() 
!listNames.append('ExampleList') 
!listNames.append('AnotherList') 
-- Create a corresponding list of numbers (the RTEX T in the dropdown) 

--- Page 34 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 34/178  !listNumbers = object ARRAY() 
!listNumbers.append('1') 
!listNumbers.append('2') 
 
-- Create an array of strings for contents of the f irst list (names or refnos) 
!listContents = object ARRAY() 
!listContents.append('/P-MA') 
!listContents.append('/P-GA') 
!listContents.append('/P-16B') 
 
-- Add the array of contents to a global variable 
!!cdlist1 = object ARRAY() 
!!cdlist1.appendarray(!listContents) 
 
-- Repeat for a second list (optional) 
!listContents = object ARRAY() 
!listContents.append('/E-13') 
!listContents.append('/S-13') 
!listContents.append('/P-16B') 
!!cdlist2 = object ARRAY() 
!!cdlist2.appendarray(!listContents) 
 
-- Update the form with the DTEXT and RTEXT 
!!cdcList.name.dText = !listNames 
!!cdcList.name.rText = !listNumbers 
 
-- Store the names in a global variable 
!!cdList = !listNames 
 
Example 5 : 
 
PML 2 collection 
 
!e = !!CollectAllFor('SCTN','', !!ce ) 
!e = !!CollectAllFor('PIPE','Pspec eq |/A3|', world  ) 
!e = object COLLECT() 
!e.classes = 'ALL' 
!e.types = 'sctn' 
!tmp = !!collect(!e) 
 
Note:  There are more options, like !e.expression - this lets you add an expression to the 
object, etc. The easiest way to see the options I t hink is to create the object then query it. 
 
!e = object COLLECT() 
q var !e 
!a = Object Collection() 
!a.scope(/VALIDELEMENT) 
!a.type('TYPE') 
 
Example 6 : 
 
Conditions : 
 
Type: TEE 
Stype: RDTE (reducing tee in our DB) 
Bore: DN100 
Cbore: DN50 (bore of tee connection) 
Spec: /SOME_SPEC 

--- Page 35 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 35/178  PML 1 collection 
 
var !tees coll all SPCO with ((GTYPE of catref eq ' TEE') and (STYPE eq 'RDTE' and PARAM1 of 
catref eq 100)) for /SOME_SPEC 
 
Note:  What you get is an array of specifications matchin g criteria. In this case this would be 
all reducing tees in catalog. You still don't know how to select the tee with correct reduced 
DN.  
 
PML 2 collection 
 
!elbows = !!collectallfor(|ELBO|,|gtype of catref i nset('ELBO') AND stype inset('PPBA') AND 
P1BORE eq 50mm|,!!ce) 
 
!directory = object file (|C:\FOLDER|) 
!dirFiles = !directory.files() 
-- Query !dirFiles: 
q var !dirFiles 
 
-- If you want to get only the filenames: 
!fileList = object array() 
do !i indices !dirFiles 
!file = !dirFiles[!i].entry() 
!fileList.append(!file) 
Enddo 
 
q var !fileList 
5.4. Array sorting 
5.4.1. PML 1 array sorting 
!Project = CURRENT PROJECT 
!MyProj = !Project.code() 
$p 
$p Project: $!MyProj 
$p 
!xTab = | | 
 
var !Pipes collect all (PIPE) 
!asz = ArraySize(!Pipes) 
$P Array size: $!asz 
 
!output = object ARRAY() 
!xRec = |'PIPE| & |$!xTab| & |ZONE| & |$!xTab| & |P SPEC| & |$!xTab| & |ISPEC| & |$!xTab| & 
|:STATUS'| 
!output.append($!xRec) 
var !names evaluate (name) for all from !Pipes 
!NewPositions = !names.SortedIndices() 
!names.sort() 
 
var !zones evaluate (name of zone) for all from !Pi pes 
var !pspes evaluate (pspe) for all from !Pipes 
var !ispes evaluate (ispe) for all from !Pipes 
var !stats evaluate (:status) for all from !Pipes 
 
!zones.ReIndex(!NewPositions) 
!pspes.ReIndex(!NewPositions) 
!ispes.ReIndex(!NewPositions) 
!stats.ReIndex(!NewPositions) 

--- Page 36 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 36/178  do !Pipe index !Pipes 
  !record = !names[!Pipe] & |$!xTab| & !zones[!Pipe ] & |$!xTab| & !pspes[!Pipe] & 
  |$!xTab| & !ispes[!Pipe] & |$!xTab| & !stats[!Pip e] 
  !output.append(!record) 
Enddo 
 
!file = object FILE('%PDMSuser%\$!MyProj_PipeList.t xt') 
!file.writefile('OVERWRITE',!output) 
$p 
$p Macro finished 
 
Resulting sample output of PML report (623 records) : 
PIPE ZONE PSPEC ISPEC :STATUS 
/1"-D173015-11180-H4-0001 /PIP-17000-71 /11180-H4 = 0/0 1 
/1"-R172002-11085-R /PIP-17000-FLARE /11180-H4 =0/0  1 
/1"-R17200X-11085-R /PIP-17000-FLARE /11180-H4 =0/0  1 
/10"-B172001-11380-H1-0001-1 /PIP-17000-FLARE /1138 0-H1 =0/0 1 
/10"-B172002-11380-H1-0001-1 /PIP-17000-FLARE /1138 0-H1 =0/0 1 
/10"-B172035-11380-H1-0001 /PIP-17000-FLARE /11380- H1 =0/0 1 
/10"-B172036-11380-H1-0001 /PIP-17000-FLARE /11380- H1 =0/0 1 
PML 2 array sorting 
!Project = CURRENT PROJECT 
!MyProj = !Project.code() 
 
$p 
$p Project: $!MyProj 
$p 
 
!TwldX = |*| 
!xTab = | | 
!output = object ARRAY() 
!xRec = |'PIPE| & |$!xTab| & |ZONE| & |$!xTab| & |P SPEC| & |$!xTab| & |ISPEC| & |$!xTab| & 
|:STATUS'| 
!output.append($!xRec) 
 
!Collect = object COLLECTION() 
!Collect.scope(WORLD) 
!Collect.type('PIPE') 
!Collect.expression(object EXPRESSION('SUBSTR(NAME, 1,1) eq |/|') ) 
 
!Pipes = !Collect.results() 
!Names = object ARRAY() 
do !Pipe values !Pipes 
  !Names.append(!Pipe.name) 
Enddo 
 
!Indices = !Names.sortedindices() 
!Pipes.reindex(!Indices) 
 
!Zones = ARRAY() 
!PSpecs = ARRAY() 
!ISpecs = ARRAY() 
!udaSTATUS = ARRAY() 
 
!i = 1 
do !Pipe values !Pipes 
  -- $p $!Pipe.name 
  !Zones.append(!Pipe.owner.name) 
  -- q var !Zones 
  !PSpecs.append(!Pipe.pspec.name) 

--- Page 37 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 37/178    !ISpecs.append(!Pipe.ispec) 
  handle ANY 
    $p $!!Error.text 
  Endhandle 
  !udaSTATUS.append(!Pipe.:STATUS) 
  !record = !Pipe.name & |$!xTab| & !Zones[!i] & |$ !xTab| & !PSpecs[!i] & |$!xTab| & !ISpecs[!i] & 
  |$!xTab| & !udaSTATUS[!i] 
  !output.append(!record) 
  !i = !i + 1 
Enddo 
 
!file = object FILE('%PDMSuser%\$!MyProj_PipeList2. txt') 
!file.writefile('OVERWRITE',!output) 
 
$p 
$p Macro finished 
 
Resulting sample output of PML2 report (314 records ): 
PIPE ZONE PSPEC ISPEC :STATUS 
/1"-D173015-11180-H4-0001 /PIP-17000-71 /11180-H4 U nset 1 
/1"-R172002-11085-R /PIP-17000-FLARE /11180-H4 Unse t 1 
/1"-R17200X-11085-R /PIP-17000-FLARE /11180-H4 Unse t 1 
/10"-B172001-11380-H1-0001-1 /PIP-17000-FLARE /1138 0-H1 Unset 1 
/10"-B172002-11380-H1-0001-1 /PIP-17000-FLARE /1138 0-H1 Unset 1 
/10"-B172035-11380-H1-0001 /PIP-17000-FLARE /11380- H1 Unset 1 
/10"-B172036-11380-H1-0001 /PIP-17000-FLARE /11380- H1 Unset 1 
 
Note:  The reason for the different number of records is that the PML2 collection object only 
searches the current database i.e. that given by q refno of WORLD. The var collect syntax 
without for clause gives all worlds including catal ogue databases. You could get round this in 
PML2 by doing a var collect for sites first but it is a bit of a limitation of the COLLECTION 
object! 
  

--- Page 38 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 38/178  6. PML general futures 
6.1. Functions, Macros and Object Definitions 
 Functions and Macros are PML Files that contain st ored sequences of commands. The 
PML File is invoked whenever this sequence of comma nds is required. The PML file may 
also include control logic which alters the order i n which the commands are carried out and 
special commands for handling errors. PML Files are  normally created using a text editor. 
PML Functions and methods on objects (including for ms) are the recommended way of 
storing command sequences because: 
 
• There is a check that they have been called with t he right type of arguments. 
• Arguments can return values. 
• A PML Function or method can return a result of an y type. 
 
 Most new AppWare code is written as methods on obj ects. PML Macros are explained in 
Macros as they are the basis of the older AppWare c ode. PML Macros are normally stored in 
a directory under the PDMSUI search-path. PML Funct ions are automatically loaded from a 
directory under the PMLLIB search-path. 
6.2. Comments in PML Files 
 Comments are additional text included in a PML Fil e for the benefit of someone reading 
the PML code. The PML processor ignores comments an d so they do not affect the way the 
code executes. For a simple one line comment, begin  the line with - - (two dashes) or $* 
(dollar and asterisk). 
 
- - This is a new-style PML comment 
- - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - 
$* The following lines calculate the new angle 
 
You can also use $* to add an inline comment to any  line of PML. A comment may extend 
over several lines provided it is enclosed in the e scape sequences : 
$( and $) 
$( A comment containing 
skip if (!X EQ !Y) 
more than one line $) 
6.3. Leaving a PML File with the RETURN Command 
 At any point within a PML File a return command wi ll stop further execution of the file and 
return to the calling PML File, if there is one: 
 
if ( count EQ 0 ) then 
  return 
endif 
 
For clarity, return can be used as the final line o f a PML Macro. However, the use of this 
command is not essential and there will be no error  if it is not used. Note: This is a different 
use of return from the command used to set return v alues of variables. 
6.4. Case Independence 
 Everything written in PML, including keywords such  as if, do and else means the same 
thing in upper or lower case. The exception is text  enclosed between quotes or vertical bars, 
which is used exactly as it is typed. Throughout th is document you will see examples of PML 
code using a mixture of upper and lower case for re adability.  

--- Page 39 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 39/178  6.5. Abbreviations 
 Many commands have a minimum abbreviation which ca n be used in place of the full 
command. For readability it is recommended that you  use the full form of the command — 
note that it is not less efficient than using the a bbreviation. PML keywords such as if, else 
and do have no abbreviations. 
6.6. Special Character $ 
 The $ character has a special meaning in PML. It i s an escape character, which means 
that together with the character which follows it a re treated as a special instruction to PML. 
The pair of characters beginning with $ is known as  an escape sequence. $P is a commonly 
encountered example, which is used to output a mess age to the screen: 
$P This text will be output to the screen 
 
 A number of other escape sequences will be describ ed later in this manual. The important 
point to note here that if you need the dollar char acter itself as part of a command, you will 
need to double it ($$). As the last character on a line, $ means that the next line is a 
continuation line. For example: 
$P This is an example of a much longer message that  will be $ output to the screen 
 
$! The PML variable following the ! (or !!) is expa nded as a string by using its own .STRING() 
method. 
 
Note:  Real values are automatically expanded with any un it qualifier appended if the value is 
a physical quantity. This is useful on $P lines or converting real values to strings in 
commands. $newline command continues on next line w ithout being automatically closed. 
 
$M/filename execute a text file as a sequence of co mmands or an input macro. Named 
using its filename or pathname. 
 
The Dollar $ symbol and its meanings 
 
$M = Runs a macro in pdms 
$! = Evaluate a variable 
$. = Terminates a macro 
$S = Defines a synonym 
$G = Defines a global synonym 
$S- = Turns synonyms off 
$S+ = Turns synonyms On $QS = Query’s the synonyms 
$H = Help 
$Q = Another syntax help 
$P = Prints a line to your command line 
$$ = Adds a $ symbol 
$D = Default argument value 
 
To turn the pml trace on and off I use 
 
$R<n> 
$R0 = Turn trace Off 
$R6 = Turn trace On 
$R1 = Tracing to shell window (default) 
$R2 = Tracing to requests window 
$R4 = Tracing of only input lines executed 
$R8 = Tracing of all input lines $R16 = Tracing without $ expression 
(default off) 
$R32 = Tracing includes line numbers 
$R64 = Tracing of macro/function changes 
$R100 = General Debugging 
$R102 = capture trace in ALPHA LOG 
6.7. Text delimiters 
 Text strings must be enclosed in either single quo tes, or apostrophes, or vertical bars: 
('apostrophes' or |vertical bars| ). The apostrophe s and vertical bars are known as delimiters. 
Take great care to avoid unmatched delimiters as th is can lead to many lines of PML code 
being included as part of the text string, and so l ost. 

--- Page 40 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 40/178  6.8. Filename Extensions 
 The naming conventions are as follows: 
 
Extension Use for 
 
.pmlfnc PML Function definition files 
.pmlobj PML object type definition files 
.pmlfrm PML Form definition files 
 
Note:  All filename extensions must be entered in lower c ase. 
6.9. Storing and Loading PML Files 
 PML Files must be stored in directories pointed to  by the PMLLIB environment variable. 
When an AVEVA product is started up, PML scans each  directory in the PMLLIB search 
path and creates a file named pml.index in each dir ectory. This index file contains a list of all 
the PML Files in all the directories under the dire ctory given in the PMLLIB search path. All 
the PML Files listed in the pml.index files are loa ded automatically when the product is 
started up. When you are working on PML Files, you should store them in your own PML 
working directory, and add the path of your PML wor king directory as the first entry in your 
PMLLIB search path. Then, when you add a new PML Fi le (after you have started up an 
AVEVA product), you will need to tell PML to rebuil d its file index by giving the command:  
 
pml rehash 
This command scans all the files under the first di rectory in your PMLLIB path, and updates 
the pml.index file. If other users have added PML F iles and updated the appropriate 
pml.index files, you can access the new files by gi ving the command: 
 
pml index 
This command re-reads all the pml.index files in yo ur search path without rebuilding 
them. When you are not running an AVEVA product, yo u can update the pml.index file in a 
given directory by giving the command: 
 
pmlscan directory_name 
This command runs a utility supplied with AVEVA pro ducts. 
 
Note:  The commands pml rehash and pml index are a type o f command known as PML 
directives: they are used outside PML Files to dire ct PML itself to take certain actions. More 
information about using PML directives with form de finitions is given in PML Directives 
6.10. Rebuilding All PML File Indexes 
 This process can take some time, and it is possibl e that if another user gives the 
command at the same time, the index files may not b e re-built properly. Hence it is 
recommended that this command should only be used w hen necessary. System 
Administrators are advised to maintain firm control  over the directories in the PMLLIB search 
path by removing write access for most users. The f ollowing command scans all the files in 
all the directories in your PMLLIB path, and update s the pml.index files. pml rehash all 
6.11. Querying the Location of PML Files 
 If you are not sure where a given file is stored, you can query the path by giving the 
following command, using the appropriate file suffi x: 
q var !!PML.getpathname( 'filename.pmlobj' )  

--- Page 41 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 41/178  7. PML Control logic 
 There are four types of construct for implementing  control logic within a PML Function or 
Macro. These are: 
• The if construct for conditional execution of comm ands. 
• The do command for looping and the associated brea k and skip. 
• The golabel for jumping to a line with a label. 
• The handle construct for dealing with errors. 
7.1. IF Construct 
The full form of an if-construct is as follows: 
 
if (!Word EQ 'Peanuts' OR !Word EQ 'Crisps') then 
  !Snacks = !Snacks + 1 
  !Meal = FALSE 
elseif ( !Word EQ 'Soup') then 
  !Starters = !Starters + 1 
  !Meal = TRUE 
elseif (!Word EQ 'Fruit' Or !Word EQ 'IceCream' ) t hen 
  !Puddings = !Puddings + 1 
  !Meal = TRUE 
else 
  !MainCourse = !MainCourse + 1 
  !Meal = TRUE 
endif 
 
 Each BOOLEAN expression, such as (!Word EQ 'Soup') , is examined in turn to see 
whether it is TRUE or FALSE. As soon as an expressi on that is TRUE is encountered, the 
following block of commands is executed. Once a blo ck of commands has been executed, 
everything else up to the endif is ignored. The els e command is optional. If it is included, you 
can be sure that exactly one command block within t he if-construct will be executed. The 
elseif commands are also optional. Once one of the elseif expressions has been found to be 
TRUE, any remaining elseif commands are ignored. Th us the simplest form of the if-
construct is: 
 
if ( !Number LT 0 ) then 
  !Negative = TRUE 
endif 
 
You may not concatenate the commands into one line,  so the following expressions are not  
if ( !TrueValue OR !UnsetValue) 
if ( !FalseValue AND !UnsetValue) 
ignore !UnsetValue if the value is not required to determine the outcome of the expression. 
The same is true for PML Functions which have retur ned an error. 
 
7.1.1. Nesting if-constructs 
Any if-construct may contain further if ... elseif … endif constructs: 
 
if (!Number LT 0) then 
  !Negative = TRUE 
  if (!Number EQ -1 ) then 
    !OnlyJustNegative = TRUE 
  endif 
endif 
It is particularly helpful with nested if construct s to indent the code so that the logic is clear. 

--- Page 42 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 42/178  7.1.2. IF, THEN, ELSEIF and ELSE Statements 
 An IF construct can be extended by adding addition al conditions. This is done by adding 
either ELSEIF or ELSE to it. When an IF construct i s encountered, PML will evaluate its 
condition. If the condition is FALSE, PDMS will loo k to the next ELSEIF condition. Once a 
condition is found to be TRUE, that code will be ru n that proportional of the code and the IF 
construct is complete. If an ELSE condition is adde d, this portion of code will only be run if 
the other conditions are never met. This is a way o f ensuring some code is always run.  
 
if ($1 EQ 0) THEN 
  $p Your value is zero 
elseif ($1 LT 0) THEN 
  $p Your value is less than zero 
else  
  $p Your value is Greater than zero 
endif 
 
The ELSEIF and ELSE commands are optional, but ther e can only be one ELSE command 
in an IF construct. 
7.1.3. BOOLEAN Expressions and if Statements 
 New expressions based on the operators such as EQ and GT give a BOOLEAN result 
that can be used directly in a PML2 if test: 
if (!NewValue - 1 GT 0) then 
 
The expression can be a simple variable provided it  is a BOOLEAN type variable: 
!Success = !NewValue GT 0 
 
if (!Success) then 
The expression could be a user-defined PML Function  provided it returns a BOOLEAN 
result: if (!!MyFunction() ) then  
 
Note: 
The BOOLEAN constants TRUE, FALSE, YES and NO and t heir single-letter abbreviations 
not enclosed in quotes return BOOLEAN results and s o can be used directly in expressions. 
For example: 
 
Code  Result Type 
if ( TRUE ) BOOLEAN 
if ( FALSE ) 
if ( T ) BOOLEAN 
if ( F ) 
if ( YES ) BOOLEAN 
if ( NO ) 
if ( Y ) BOOLEAN 
if ( N ) 
 
The following do not return BOOLEAN values and are therefore invalid: 
 
Code Result Type 
if ( 1 ) REAL 
if ( 0 ) 
if ( ‘TRUE’ ) STRING 
if ( ‘FALSE’ ) 
if ( ‘T’ ) STRING 
if ( ‘F’ ) 
Variable = 1 REAL 
if ($Variable) 

--- Page 43 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 43/178  For upward compatibility with PML1, STRING variable s set to ‘TRUE’, ‘FALSE’, ‘YES’ or 
‘NO’ or their single-letter abbreviations can be us ed in an if-test as long as they are 
evaluated with a preceding $. For example: 
 
Code Result Type 
Variable = ‘TRUE‘ STRING 
if ($Variable) 
 
There is a built-in PML Method and a function for c onverting a value to BOOLEAN: 
 
!MyString = ‘TRUE’ 
if (!MyString.Boolean() ) then 
 
The Boolean conversion is as follows: 
 
Code Result 
REAL zero FALSE 
$* All other positive and negative REAL values TRUE  
STRING ‘FALSE, ‘F’, ‘NO’ and ‘N’ FALSE 
STRING ‘false, ‘f’, ‘no’ and ‘n’ FALSE 
STRING ‘TRUE’, ‘T’, ‘YES’ AND ‘Y’ TRUE 
STRING ‘true’, ‘t’, ‘yes’ and ‘y’ TRUE 
7.1.4. IF TRUE Expression 
 IF TRUE will return a value of the type defined by  the second and third arguments. If the 
initial Boolean expression is true, the result of t he first expression is returned. If false, the 
result of the second expression is returned. Both t he second and third arguments are fully 
evaluated regardless of the value of the Boolean. T his is because the function is evaluated 
using reverse polish procedure (as is the case of t he expression design). This allows the IF 
statement to be nest able with any of the arguments  to IF capable of including other IF 
functions. 
 
If logical1 expression is set to true, then value o f typeX1expression is returned  If logical1 
expression is set to false, then value of typeX1 ex pression is returned typeX1 and typeX2 
are two arguments of the same type which may be: 
 
Logical 
Logical Array 
Real 
Real Array 
ID 
ID Array 
Text 
Position 
Direction 
7.1.5. Boolean expressions PML1 upward compatibilit y 
 For upward compatibility with PML1, STRING variabl es set to ‘TRUE’, ‘FALSE’, ‘YES’ or 
‘NO’ or their single letter abbreviations can be us ed in an if test as long as they are 
evaluated with a preceding $. For example: 
 
if ($Variable) where Variable = ‘TRUE’ STRING OK 
 
  

--- Page 44 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 44/178  7.2. DO Loops 
 A do-loop enables a series of commands to be repea ted more than once. The number of 
times the series is repeated is controlled by a cou nter. Control is passed to the line following 
the enddo command after executing the commands with in the loop with the counter variable 
at its final value. The full format of the do-loop is as follows: 
 
do !x from 10 to 100 by 10 
  !Total = !Total + !X 
enddo 
 
The enddo must be present at the end of the loop. T he !X , from, to and by are optional, 
therefore in its simplest form you may use: 
 
do 
  commands block 
enddo 
 
This will loop forever unless something in the comm ands block stops the loop. 
 
!X  A PML local (or global) variable that is automatic ally updated with the value of the loop-
counter every time round the loop. If you do not su pply a loop variable, a hidden unnamed 
variable will be used for the counter. Note that th e loop variable is REAL. PML will delete any 
pre-existing variable of the same name. After the l oop has finished, the counter variable will 
retain the value it had last time through the loop.  
from Defines the value of the counter for the first time  round the loop. If you do not give a 
value, it will default to 1. 
to  Defines the value of the counter for the final tim e round the loop. The default is infinity. 
by  Defines the step size (positive or negative) by wh ich the counter value is changed each 
time round the loop. The default value is +1. 
7.2.1. Stopping a DO loop: break and breakif 
 If the two option is not given, the command block within the loop will be repeated 
indefinitely. To stop looping, use either the break  or break if command: 
 
do !Number 
  if (!Number GT 100) then 
    break 
  endif 
  !Result = !Result + !Number 
enddo 
 
do !Number 
  break if (!Number GT 100) 
  !Result = !Result + !Number 
enddo 
 
Any expression may be used with the breakif command , even a PML Function, provided the 
result is BOOLEAN (i.e. TRUE or FALSE). The ( ) par entheses are optional but 
recommended. The loop counter variable retains the value it had when the break from the 
loop occurred. 
7.2.2. Skipping Commands in a DO Loop using Skip or  Skip if 
 A skip command is used to go back to the beginning  of the do loop, to repeat the loop 
with the next value of the do loop counter, omittin g any commands following the skip 
command. The following example skips odd numbers: 
 

--- Page 45 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 45/178  do !X 
  !Number = !Sample[!X] 
  if ((INT(!Number/2) NE (!Number/2)) then 
    skip 
  endif 
  !Result = !Result + !Number 
enddo 
 
The skip if command can sometimes be more convenien t: 
 
do !X 
  !Number = !Sample[!X] 
  skip if (INT(!Number/2) NE (!Number/2)) 
  !Result = !Result + !Number 
enddo 
7.2.3. Nested DO Loops 
 You can nest do-loops one inside the other. The co unter for each loop must have a 
different name. 
 
do !X to 10 
  do !Y 
    !Z = !X + !Y 
    break if (!Y GT 5) 
  enddo 
enddo 
 
The inner-most loop goes through all the values of !Y before the outer loop moves on to the 
second value of !X. Note that the break (or skip) c ommand acts just on the loop containing it 
- in this case the inner-most loop. 
7.2.4. DO Index and DO Values 
 DO Index and DO Values are ways of looping through  arrays. This is an effective method 
for controlling the values used for the loops. Typi cally values are collected into an ARRAY 
variable then looped through using the following: 
 
do !X values !ARRAY 
     !X takes each ARRAY element (!x is an element !!!) 
enddo 
 
do !X index !ARRAY 
     !X takes a number from 1 to !ARRAY size (!x is  a number !!!) 
enddo 
7.2.5. DO Loops Examples 
Type out the following as an example of looping thr ough an ARRAY of values. 
 
VAR !Zones COLL ALL ZONES FOR SITE 
VAR !Names EVAL NAME FOR ALL FROM !Zones 
q var !Names 
 
do !x VALUES !Names 
  q var !x 
enddo 
 
do!x INDEX !Names 
  q var !Names[!x] 
enddo 

--- Page 46 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 46/178  7.2.6. DO Values with Arrays of Objects 
 Imagine that we have already defined an object typ e EMPLOYEE which contains a 
member of type STRING. We create an array of EMPLOY EE objects and set the Name 
member of each of each object. 
 
!MyEmployees[1] = object EMPLOYEE() 
!MyEmployees[2] = object EMPLOYEE() 
!MyEmployees[3] = object EMPLOYEE() 
!MyEmployees[1].Name = ‘James’ 
!MyEmployees[2].Name = ‘Joe’ 
!MyEmployees[3].Name = ‘Mike’ 
 
We then wish to create a new array containing just the employees’ names. 
 
!Names = ARRAY() 
 
do !Person VALUES !MyEmployees 
  !Names.Append(!Person.Name) 
enddo 
 
Each time round the do-loop, the do-variable become s an object of the appropriate type, 
even if the array is a heterogeneous mixture of obj ects. 
7.3. Jumping to a Labelled Line 
 The golabel command in PML allow you to jump to a line with a matching label name 
 
LABEL /FRED 
: 
: 
GOLABEL /FRED 
 
The label name /FRED has a maximum length of 16 characters , excluding the / slash 
which must be present. The next line to be executed  will be the line following LABEL /FRED, 
which could be before or after the GOLABEL command.  
7.3.1. Conditional Jumping to a Labelled Line 
do !A 
  do !B to 3 
    !C = !A * !B 
    golabel /finished if (!C GT 100) 
    !Total = !Total + !C 
  enddo 
enddo 
label /finished 
$P Total is $!Total 
 
If the expression !C GT 100 is TRUE there will be a  jump to LABEL /FINISHED and PML 
execution will continue with the line 
 
$P Total is $!Total 
 
If the expression is FALSE , PML execution will continue with the line: 
 
!Total = !Total + !C 

--- Page 47 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 47/178  7.3.2. Illegal Jumping 
The following is an illegal jump into a nested do b lock. It is however permitted to jump out of 
a nested block to a line in an enclosing block. 
 
golabel /illegaL 
do !Count to 5 
  !Total = !Total + !Count 
  label /illegal 
enddo 
7.4. Errors and Error Handling 
7.4.1. Error Conditions 
 An error condition can occur because a command cou ld not complete successfully or 
because of a mistake in a PML Macro or function. Th e presence of an error normally has 
three effects: 
 
• An Alert box appears which the user must acknowled ge 
• An error message is output together with a trace b ack of any calling macros or 
functions. 
• Any currently running PML Macros and functions are  abandoned. 
 
This example of an error is caused by an attempt to  use a PML Variable that does not exist: 
 
(46,28) ERROR - Variable FRED not defined 
 
The 46  is the module or program section which identified the error and is the error code itself 
is 28 . If the input line had been typed interactively th at is the end of the story. However, if the 
input line was part of a PML Macro or function the error may optionally be handled. 
7.4.2. Handling Errors 
 An error arising during the processing of a PML Ma cro or function does not immediately 
give rise to an error message - this depends on the  next line of input. Provided the next 
command processed by PML is a matching handle comma nd, the error is not output and the 
commands within the matching handleblock are proces sed instead. Elsehandle blocks may 
optionally also be present - if the handle block do es not match the error one elsehandle will 
be processed - if it matches the error: 
 
$* a command causes Error(46, 28) 
handle (46, 27) 
  $* handle block - not processed this time 
elsehandle (46, 28) 
  $* The commands in this matching handle block are  processed 
  next 
elsehandle ANY 
  $* An ANY Handle Block is processed for any error s. In this position it would handle errors 
other than (46, 27) and (46,28) 
elsehandle NONE 
  $* A NONE Handle Block is processed only if there  were no errors 
Endhandle 
 
$* This line is processed after the handle block. 
 
If (46,27) matches the error, PML processes the com mands in that handle block instead of 
outputting an error. Processing of the current PML Macro or function continues at the line 
after the endhandle command. 

--- Page 48 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 48/178  Note:  The keywords ANY and NONE which can optionally be used in place of a specific 
error code.  
 
 If the line following a line which has caused an e rror is not a handle command, the 
outcome depends on the current setting of onerror ( see next section). The default setting is 
onerror RETURN and the current macro or function is  abandoned. However, if in the calling 
PML Macro or function the next command to be proces sed is a handle command, it now 
gets an opportunity of handling the error (and so o n up the calling 
PML). 
7.4.3. Setting the ONERROR Behavior 
The default setting is: 
 
onerror RETURN 
 
which causes the current macro or function to be ab andoned and gives the calling macro or 
function an opportunity to handle the error. Anothe r possibility is to jump to one section of 
code in the same macro or function after any unhand led error: 
 
onerror GOLABEL /LabelName 
  $* The first command to be executed after the lab el 
  $* must be a handle command - it could for exampl e be a 
  label /LabelName 
handle ANY 
  $* handle block 
Endhandle 
 
To suppress errors, and error alerts the following may be used, for example during no 
interactive testing: 
 
onerror CONTINUE 
 
Although the effect of errors is suppressed, any er ror messages generated will still be 
output. Beware of using this option which can have unpredictable effects. The option is 
applied to all subsequently nested PML Macro and fu nction calls. When debugging, you may 
interrupt normal PML processing after an error: 
 
onerror PAUSE 
 
The effect is the same as $M- and will allow you to  type commands while the PML File is 
suspended. You must type $M+ to resume the PML proc essing. Do not leave this in working 
code. 
7.4.4. Other Responses to an Error 
After handling an error, you can still output the d etail of the error message with the following 
commands: 
 
$P $!!Error.Text 
$P $!!Error.Command 
$P $!!Error.Line 
do !line VALUES !!Error.Callstack 
  $P $!Line 
Enddo 
 
To abandon the running PML Macro or function, but t o re-instate the error so that the calling 
PML code has a chance to handle it, you can use the  command: 

--- Page 49 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 49/178  return error 
 
You can also re-instate the error but suppress the alert using the command: 
return error noalert 
 
To generate a new error (or replace an error with y our own error) plus an optional message, 
use one of the following 
 
return error 1 
return error 1 ‘Your error message’ 
return error 1 NOALERT 
 
To handle such an error there is a special form of the handle command: 
 
handle 1 
  PML code to handle a user-defined error number 
endhandle 
7.5. Handling Files and Directories 
 Reading and writing files is greatly simplified by  using the FILE object. This chapter 
describes the methods most frequently used for read ing and writing. Methods are also 
provided for moving, copying and deleting files and  extracting information such as the 
pathname of a file, its size data and time last mod ified. A FILE object may refer to a directory 
rather than a file and methods are provided for nav igating around the directory structure. For 
a complete list of the methods available, refer to the Software Customization Reference 
Manual. 
7.5.1. Creating a File Object 
 A file object is created by invoking the FILE cons tructor with the name of the file as its 
argument. For example: 
 
!MyFile = object FILE (‘c:\users\bob\list.txt’) 
!MyFile = object FILE (/net/usr/bob/list’) 
!MyFile = object FILE (‘%PDMSUSER%\bob\list.txt’) 
 
 At this stage, the file may or may not exist — cre ating the FILE object does not open or 
access the file in any way. This example reads pair s of numbers from file data, adds them 
together and writes the answers to file RESULTS. 
 
!Input = object FILE('DATA') 
!Input.Open(‘READ’) 
!Output = object FILE('RESULTS') 
!Output.Open(‘WRITE’) 
do 
  !Line = !Input.ReadRecord() 
  if (!Line.set()) then 
    !array = !Line.Split() 
    !Total = !Array[1].Real() + !Array[2].Real() 
    !Output.WriteRecord( !Total.String() ) 
  else 
    break 
  endif 
enddo 
!Output.Close() 
!Input.Close() 

--- Page 50 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 50/178  7.5.2. Reading from Files 
 When reading a file one line at a time using the R eadRecord() method you must open the 
file first with the Open(‘READ’) method and close i t afterwards with the Close() method. 
Each line read from the file will be returned as a STRING until the end of the file is reached, 
when you will get an UNSET STRING returned. The UNS ET string can be detected using 
the STRING object's Set() method (or Unset()) 
7.5.3. Writing to Files 
 When you open a file for writing, the file will be  created if it does not already exist. If you 
use Open(‘WRITE’) and the file already exists, the user will be shown an alert asking 
whether the file can be overwritten. Alternatively you may specify OVERWRITE, to force 
overwriting of a file if it already exists or APPEN D if you want to add to the end of a file if it 
already exists. 
7.5.4. Reading and Writing ARRAYS 
 You will obtain much quicker performance if you re ad or write an entire array in a single 
operation. In particular you are recommended to use  the ReadFile() method which returns 
the whole file as an array of strings, opening and closing the file automatically: 
 
!Input = object FILE('DATA') 
!Output = object FILE('RESULTS') 
!Lines = !Input.ReadFile() 
!ResultArray = ARRAY() 
do !Line VALUES !Lines 
  !Numbers = !Line.Split() 
  !Total = !Numbers[1].Real() + !Numbers[2].Real() 
  !ResultArray.Append( !Total.String() ) 
enddo 
!Output.WriteFile('WRITE', !ResultArray) 
 
Note:  With the ReadFile() method you may optionally specify the maximum numbe r of 
lines you are prepared to read and an error is rais ed if this number is exceeded. If not 
specified, a limit of 10000 is imposed. 
7.5.5. Error Handling When Using a File Object 
 Errors will mainly be encountered when an attempt is made to open a file that does not 
exist, has been mistyped or to which you do not hav e access. Anticipated errors may be 
dealt with in a handle command following use of the  Open() method. The errors most 
commonly encountered include the following: 
 
(160,7) Argument to method is incorrect 
(160,9) File does not exist 
(160,36) Unable to read file record, file is not op en 
(160,37) Unable to write file record, file is not o pen 
(160,44) File exists, user does not want to overwri te it 
(160,47) File length has exceeded N lines 
(41,319) Cannot access file (Privileges insufficien t) 
  

--- Page 51 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 51/178  8. Macros 
8.1. PML Macros 
 Macros are command sequences that are stored in te xt files. To access a macro file and 
input the command sequence to your program, you run the macro. The file is scanned line-
by-line, with exactly the same effect as if you wer e typing the lines in from a keyboard. 
Macro files may include synonyms and user-defined v ariables. They may also act on data 
which you define when you give the command to run t he macro (parameterized macros). 
Macros are permanent records which may be called fr om within any working session of a 
program. 
8.1.1. Naming and Running Macros 
 A macro file can be given any name that conforms t o the naming conventions of the 
operating system. The suffix .mac is often used to indicate that the filename is that  of a 
macro, but this is optional. The process of reading  the contents of a macro file as program 
input is known as running the macro . The program does not discriminate between input 
from the GUI, the keyboard, or a macro file. To run  a macro, enter: $M filename  
 
where filename is the pathname of the macro file. The filename may  optionally be preceded 
by a slash (/) character. If you give only the name  of the file, the program will look for it in the 
directory from which you executed the program. An e rror message will be output if the file 
cannot be found and opened for reading. 
8.1.2. Macros with Arguments 
 It is often convenient to write a macro in a gener alized form, using parameters to 
represent dimensions, part numbers etc., and to ass ign specific values to those parameters 
only when the macro is to be run. In the simplest c ase, parameters are allocated positions in 
the command lines as macro arguments by inserting e scape codes of the form $n where n is 
an integer in the range 1 to 9. These arguments are  then specified as part of the command 
to run the macro. They follow the macro name, with spaces separating the individual 
arguments. For example, if a macro named beam.mac i ncludes the command line  
 
NEW BOX XLEN $1 YLEN $2 ZLEN $3 
 
then the macro call $M/BEAM.MAC 5000 200 300 will run the macro and will set the lengths 
defined as $1, $2, $3 to 5000, 200 and 300 respecti vely. Arguments may be either values or 
text, but note that a space in a text string will b e interpreted as a separator between two 
different arguments. Apostrophes in text arguments are treated as parts of the arguments, 
not as separators between them. For example, if a d emonstration macro arg.mac includes 
the lines: 
$P First Argument is $1 
$P Second Argument is $2 
$P Third Argument is $3 
 
and is called by the command $M arg.mac ’Arg1a Arg1b’ ’Arg2’ ’Arg3’ 
 
the resulting output will be 
First Argument is ’Arg1a’ 
Second Argument is ’Arg1b’ 
Third Argument is ’Arg2’ 
 
whereas the intended output was 
First Argument is ’Arg1a Arg1b’ 
Second Argument is ’Arg2’ 
Third Argument is ’Arg3’ 

--- Page 52 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 52/178  If you need to include spaces or newlines in an arg ument, you must enclose the argument 
between the escape codes $< and $>. The correct for m for the preceding example is 
therefore $M/arg.mac $<’Arg1a Arg1b’$> ’Arg2’ ’Arg3’  
 
As an alternative, you may redefine the separator b etween arguments to be the esc. code $, 
instead of a space. If you do this, you must end th e argument list with the escape code $. 
 
Note:  The full stop is part of the escape code, not punc tuation. Using this convention, the 
preceding example becomes $M/ARG.MAC $,’Arg1a Arg1b’$,’Arg2’$,’Arg3’$.  
 
If an argument is omitted when a macro is called, t he $n in the macro command line is 
ignored. Whether or not this leaves a valid command  depends upon the syntax which 
applies. To avoid possible errors, a default settin g may be defined for each argument. If the 
argument is omitted when the macro is called, the d efault setting will be used. To define an 
argument’s default setting, use the command $Dn = default_string  where n is the argument 
number (1-9) and default_string is any sequence of characters ending in a newline. The 
default setting may be specified at any point in th e macro, but it will only be applied from that 
point onwards. It is usually best, therefore, to de fine any defaults at the beginning of the 
macro. If an argument has been specifically defined , a subsequent default specification is 
ignored. Arguments may be omitted in the following ways: 
 
• If the normal macro calling sequence is used (spac es as separators, Return as end-
offline marker), trailing arguments may simply be o mitted 
• If a non-trailing argument is to be omitted, the e scape code $<$> must be used to 
replace the argument which is not required 
• If the $, argument separator is being used, the ar gument may be omitted from the list 
For example, if the macro demo.mac expects three ar guments, the following calls to 
run the macro all omit one of the arguments: 
 
Macro Call Effect 
$M/demo.mac arg1 arg2 Omits third argument 
$M/demo.mac arg1 $<$> arg3 Omits second argument 
$M/demo.mac $,$,arg2$,arg3$. Omits first argument 
8.2. Using Macros and Functions Together 
 The existing mechanism for invoking a macro using $M continues to be available 
alongside the new PML Functions. Most PML code in e xisting macros should continue to 
work unmodified. To call a macro, even from within a PML Function, use the $M command. 
Variables used as arguments to a macro must be STRI NG values. PML Variables must be 
converted to a STRING with a preceding $: $M filename $!X $!Y $!Z  
 
Note:  To gain the full benefits of using PML Functions i t is best not to mix Macros and 
Functions extensively. Many of the advantages of PM L Functions depend on using variables 
without $ which is not possible with arguments to macros. 
8.3. Synonyms in PML Macros and Functions 
 You may use synonyms in macros, although you canno t use them in PML Functions. This 
restriction was introduced because changing a synon ym (which is global to the whole 
program) can cause an unintentional change in behav ior of individual macros. There is also 
a large performance penalty on every line of PML ex ecuted where synonyms are permitted. 

--- Page 53 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 53/178  8.4. PML 1 Hierarchy 
 All PML1 Macros are in a directory structure point ed at by the variable PDMSUI. The 
PDMSUI environment variable Set PDMSUI=C:\AVEVA\plant\PDMS12.0.2\pdmsui  
 
Picture Nr.2. - PML1 File hierarchy 
 Standard AVEVA environment variable are set in a b at files called EVAR.bat in the 
executable directory.  All PML1 macros and forms ar e called using synonyms For example 
the macros and forms associated with piping are cal led using the synonym CALLP: 
 
$S CALLP=$M/%PDMSUI%/DES/PIPE/$s1 
CALLP MPIPE 
 
Note:  This is why if all synonyms are killed that PDMS w ill no longer work properly. 
 
It is normal practice to create a parallel hierarch y to contain any new or modified PML. 
These modifications can then be called by modifying  the PDMSUI variable to point at a multi 
path. This can be done by putting a new file path i n front of the %PDMSUI% definition. This 
will update the PDMSUI environment variable to incl ude the specified file path. 
Set PDMSUI=c:\pmltraining\PDMSUI %pdmsui% 
 
The new file path should go in front of %PDMSUI% so  this area is checked first for content. 
Once content is found, other locations will not be searched. This modification should be 
done after the PDMSUI environment variable has been  defined. This can be done at the 
bottom of the EVAR.bat file or in the PDMS.bat file  (after the line which calls evar.bat). The 
environment variables can be checked with PDMS by u sing the q evar syntax q evar PDMSUI 
or q evar ‘SAM000’ .  
8.5. PML2 Functions and Objects 
8.5.1. The pmllib environment variable 
The PMLLIB environment variable points to a PML2 di rectory structure. 
Set PMLLIB= C:\AVEVA\plant\PDMS12.0.2\pmllib 
 
Picture Nr.3. - PML2 File hierarchy 
 There are 3 new file extensions .pmlfnc for Functi ons, .pmlfrm for Forms and .pmlobj for 
Objects, with these extensions the files will be lo aded by PDMS automatically when the 
program is started. Functions are loaded by PDMS an d are run by typing the following 
!!mymac(). This runs file mymac.pmlfnc. Forms are d isplayed by typing Show !!Myform or 
!!Myform.show()Objects have to be assigned to a var iable before they can be used i.e. !x = 
object MyObject() 
8.5.2. Modifications to pmllib 
 It is normal practice to create a parallel hierarc hy to contain any new or modified PML. 
These modifications can then be called by modifying  the PMLLIB variable to point at a multi 


--- Page 54 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 54/178  path. This can be done by putting a new file path i n front of the %PMLLIB% definition. This 
will update the PMLLIB environment variable to incl ude the specified file path. 
 
Set pmllib=c:\pmltraining\PMLLIB %pmllib% 
 
 The new file path should go in front of %PMLLIB% s o this area is checked first for 
content. Once content is found, other locations wil l not be searched. This modification should 
be done after the PMLLIB environment variable has b een defined. This can be done at the 
bottom of the EVAR.bat file or in the PDMS.bat file  (after the line which calls evar.bat). In 
AVEVA products environment variables can be checked  using the q evar syntax i.e. q evar 
pmllib. 
8.5.3. Updating PDMSUI and PMLLIB 
 Edit the Evar.bat file to include multi paths for PDMSUI and PMLLIB. These settings 
should be made at the bottom of the evar.bat file 
 
Set pdmsui=c:\pmltraining\pdmsui %pdmsui% 
Set pmllib=c:\pmltraining\pmllib %pmllib% 
 
 The setting of the variable can be checked in AVEV A Plant Design (PDMS) using the 
following commands: q evar pdmsui and q evar pmllib . If a pmllib file is c once items have 
been loaded by PDMS, it needs to be reloaded. This can be done by typing either pml 
reload form !!NAME  or pml reload object NAME  If a new file is to pmllib, the files can be 
remapped so PDMS knows where it is located. This is  done by typing pml rehash  onto the 
command line. This will update the first file locat ion in the search path. To update all search 
paths, type pml rehash all . 
8.5.4. PML2 Objects 
 An object is a PML grouping of information. It may  have MEMBERS (used to hold data) 
and METHODS (used to complete an action). Once assi gned to a variable, that variable 
becomes an instance of that object. This means that  variable will behave as the object 
definition. While it is possible to create user-def ined objects (discussed later), PDMS is 
supplied with a large number of built-in objects. A  full list of these can be found in the PDMS 
Software Customization Reference Manual. For exampl e, type !pos = object position() onto 
the command line. Query the variable and check the results against the members of a 
position object listed in the reference manual. 
8.5.5. PML2 Methods 
 When working with built-in objects, there may also  be BUILT-IN METHODS (object 
dependents). These methods have been defined to com plete certain actions applicable to 
object. For example, type the following into the co mmand line: 
 
!value = |56| 
!result = !value * 2 
 
 This example will have caused an error as a string  cannot be used in an expression like 
this. To avoid the error, refer to the STRING objec t in the Reference Manual and find the 
.real() method. This method translates the variable  from a STRING to a REAL so that it can 
be used in the expression. The !value remains a str ing, but !results now becomes a REAL 
e.g. 
 
!value = |56| 
!result = !value.real() * 2 
 

--- Page 55 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 55/178  Within PML2, there are built-in methods for all the  standard objects (ARRAY, TABLE, 
FORM, and STRING). For each object type, the table shows: 
 
NAME  The name of the method or member. REAL object has a method named Cosine. If 
there are any arguments, they are indicated in the brackets () after the name. For example, 
the REAL object has a method named BETWEEN which ta kes two REAL arguments. 
RESULT  The type of value returned by the method. For exam ple, the result of the method 
Cosine is a REAL value. Some methods do not return a value: these are shown as NO 
RESULT. 
STATUS  This column is used to give other information abou t the method or members. For 
methods, this column tells you whether the method M ODIFIES the value of the object. For 
members, this column tells you whether the member i s SETTABLE (by the user) or 
UNSETTABLE. 
ACTION  This column tells you what the member or method do es. 
 
A large number of methods have been provided for th e built-in PML data types: For 
example, for STRING objects, you will find a method  named Length. 
 
!Name = ‘Tony Blair’ 
!NumberOfLetters = !Name.Length() 
q var !NumberOfLetters 
 
This method returns a REAL value (the number of cha racters in the string), but has NO 
EFFECT on the variable itself. Notice the dot separ ator between the name of the variable 
and the name of the method. Also note the () bracke ts following the name of the method. 
The brackets are used to enclose the arguments of t he method, but they must be present. 
The following method creates an ARRAY of STRINGS: 
 
e.g. !NameStrings = !Name.Split() 
8.5.6. Method Concatenation 
 It is possible to apply multiple methods to the sa me variable within the same line of code. 
This process will work providing the data passed at  each stage is valid. Try the following on 
the command line: 
 
!line = 'hello world how are you' 
!newline = !line.upcase().split().sort() 
q var !line !newline 
<STRING> 'hello world how are you' 
<ARRAY> 
[1] <STRING> 'ARE' 
[2] <STRING> 'HELLO' 
[3] <STRING> 'HOW' 
[4] <STRING> 'WORLD' 
[5] <STRING> 'YOU' 
8.5.7. The !!CE Object 
 A special GLOBAL PML variable !!CE always points t o the current PDMS element and its 
attributes. Type q var !!CE onto the command line a nd compare it against typing q att. You 
will notice the returned attribute information is t he same of the members list of the !!CE 
object. This means that the !!CE object can be used  to assign the values of attributes to 
!variables For example, !BranchHeadBore = !!CE.Hbore  assigns the HBORE attribute (taken 
from the current BRAN element) to the variable !Bra nchHeadBore making it real. If the !!CE 
object member is an object itself, that object will  also have members so further information 
be obtained e.g. !HeadPosition = !!CE.Hpos.East  East member from a POSITION object 

--- Page 56 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 56/178  !Easting = !!CE.Href.Cpar[1]  Cata parameter member (attribute) of a DBREF objec t. If the 
!!CE object member is an object with built-in metho ds, these methods can also be called: 
 
!PosWRTValve = !!CE.Hpos.WRT(ZONE)  POSITION object w.r.t the owning ZONE 
 
This process can also be reversed allowing the sett ing of attributes for the CE. This means 
that it is possible to record the current value of an attribute, modify and reassign back to the 
CE. For example, type out the following onto the co mmand line: 
 
!Pos = !!CE.Pos 
q POS 
!Pos.Up = 2000 
!!CE.Pos = !Pos 
q POS 
 
These lines will have moved the CE up by 2000. Try this example again with some other 
attributes. 
8.5.8. PML2 Functions 
 Functions are new style macros which are pre-loade d by PDMS and can be called 
directly. For example, to call the function called FuncName.pmlfnc, type !!FuncName() onto 
the command line. A function is defined within a .p mlfnc file stored within the PMLLIB file 
path. For an example of a function, type the follow ing into a new file and save it as  
 
c:\pmltraining\pmllib\functions\NameCE.pmlfnc. 
define function !!NameCE() 
  !ce = !!CE.fullname 
  $p $!ce 
Endfunction 
 
To run this function, type !!NameCE() onto the comm and line. You will notice the full name is 
printed below it. This is an example of a NON-RETUR N function with NO ARGUMENTS. If 
the function can be given arguments which are then assigned to variables with the function. 
If a variable is returned, this means that the func tion can be assigned to another variable or 
as part of a calculation. Type out the following, a nd save it as 
 
c:\pmltraining\pmllib\functions\Area.pmlfnc: 
define function !!Area(!Radius is REAL) is REAL 
  !CircleArea = !Radius.Power(2) * 3.142 
  return !CircleArea 
endfunction 
 
As this function is an example of a RETURN function  with an ARGUEMENT, it can be used 
as part of an expression. The returned value is bas ed the functions argument and its type 
(REAL in this case ). 
 
 
!Height = 64 
!CylinderVolume = !!Area(2.3) * !Height 
q var !CylinderVolume 
 
As indicated by the !!, functions are global. This means that once defined, they can be called 
by any form or method within PDMS minimizing repeti tive code. 
  

--- Page 57 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 57/178  9. Using PML in AVEVA Products 
 Most of this manual describes how to use PML 2 to create and customize Forms and 
Menus. This chapter describes how to use PML within  AVEVA products. Note that for tasks 
such as defining Rules and Report Templates, you ar e restricted to the PML 1 expressions 
package described in the Software Customization Reference Manual, and it is also 
sometimes necessary to use the VAR command. 
9.1. Composing Text 
 It is sometimes necessary to arrange text in multi ple columns. The COMPOSE facility of 
the VAR command will help you do this. For example,  if we create the following text string: 
 
!A = 'The quick brown fox jumped over the lazy dogs ' 
 
To compose the text we might use the following comm and: 
 
VAR !Table COMPOSE |$!A| WIDTH 11 C SPACES 2 |$!A| WIDTH 15 R 
 
This would give the following output: 
 
Index  Value  
[1] The quick The quick brown' 
[2] brown fox jumped over' 
[3] jumped over the lazy dogs'  [4] the lazy '  [5]  dogs ' 
 
COMPOSE  always returns an array with at least one element.  The number of array 
elements depends on the length of the text strings supplied and the width of each column. 
Notice that all of the STRING array elements are sp ace-padded to the same length. 
Following the COMPOSE keyword is a list of column d efinitions. For each column, there is a 
text string, such as |$!A| which evaluates to a tex t string, followed by the column layout 
keywords in any order: 
Keyword  Effect 
WIDTH n Specifies the space-padded width of this column. If  not specified the width 
of the column will be the length of the input strin g. 
SPACES n Specifies the number spaces between this and the ne xt column. 
L LEFT Specifies text is to be aligned along the left edge  of the column. 
R RIGHT Specifies text aligned along the right edge of the column 
C CENTRE Specifies justification in the center of the column . 
DELIMITER ' ' This can optionally be used to specify an alternati ve delimiter at which to 
break the input. By default the text will be split at a white-space character such as space 
which may be removed from the output text. If the d elimiter is specified as an empty string, 
the text will be split at the column edge whatever the content. 
9.2. Defining Variables for Late Evaluation (Rules)  
 The following are used to pass the name of a varia ble into PDMS as part of a stored 
expression so that the value is taken when PDMS pro cesses the stored expression rather 
than PML extracting the value at the time the line is read: 
 
VVALUE( !X ) 
VTEXT( !AString ) 
VLOGICAL( !Boolean) 

--- Page 58 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 58/178  9.3. Using PML in PDMS 
The following facilities are only applicable to PDM S. 
9.3.1. Accessing DB Elements As Objects 
 A special global variable !!CE has been provided w hich always refers to the current 
element in the database. !!CE can be used to obtain  the DB reference of the current 
element: 
 
!Item = !!CE 
 
!!CE is of type DBREF so the new variable !Item wil l also be of type DBREF. The dot 
notation can be used to access attributes and pseud o-attributes of a database element: 
 
!Bore = !Item.bore 
 
This form of access can also be used directly on th e !!CE variable: 
 
!Owner = !!CE.owner 
 
It is also possible to follow references between DB  elements using this mechanism: 
 
!Rating = !!CE.cref.pspec.rating 
 
Assigning a new reference to the !!CE variable make s the new reference the current element 
by navigating to it in the database: 
 
!!CE = !!CE.owner 
 
P-points are accessed using the P-point number like  an array subscript. For example, to 
access the direction of P-point[1]: 
 
!Dir = !!CE.Pdirection[1] $* !Dir is a DIRECTION ob ject 
 
To access the position of P-point[3]: 
 
!Pos = !!CE.Pposition[3] $* !Pos is a POSITION obje ct 
 
A NULREF is treated as UNSET, so a NULREF can be te sted for in two ways: 
 
if ( !MyDBRef EQ NULREF ) then 
if ( UNSET( !MyDBRef ) ) then 
 
There is also the function BADREF which will detect  whether a database reference is unset 
or invalid (i.e. impossible to navigate to): 
 
if (BADREF( !MyDBRef ) ) then . . . 
 
Note:  Use full-length names for attributes as listed in the Appendix for compatibility with 
future releases. 
9.3.2. Assigning Values to Element Attributes 
 You can assign a new value to aDBREF attribute, en suring that the type of the new value 
matches the type of the attribute 
 
!!CE.Built = TRUE 

--- Page 59 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 59/178  You can still assign an attribute value in this way  even if the PML DBREF is not the current 
element': 
 
!A = !!CE 
!!CE = !!CE.Owner 
!A.Built = TRUE 
 
You can even assign a PML object, such as POSITION,  where this corresponds to the type 
of the attribute: 
 
Note that where the type of an attribute is a PML o bject, it is not possible to set an object 
member value, such as the up value of a POSITION, d irectly - this must be done in two 
stages: 
 
!Pos = !!CE.Position 
!Pos.Up = 2000 
!!CE.Position = !Pos 
9.3.3. Accessing Information About a Session 
 A number of special commands have been provided to  set a PML Variable with 
information about the current session. The commands  are: 
 
Current Session, Sessions, Projects, Teams, Users, MDBs, DBs 
 
These commands can be used as in the following exam ple. The SESSION object has a 
method that returns name of the MDB in the current session. Hence: 
 
!C = current session 
!CurrentMDB = !C.MDB() 
 
This will set !CurrentMDB to the name of the curren t MDB. 
9.3.4. Evaluating Selected DB Elements 
Using the facilities described here you can create an expression and have it evaluated for all 
elements which satisfy particular selection criteri a. The results of the expression are then 
placed in a named array. The command syntax is: 
 
VAR !Array EVALUATE (Expression) FOR select COUNTVA R !Counter 
 
Where: 
!Array  is the name of the array that will be created to c ontain the results of (expression) for 
all the elements selected within select. 
(expression)  is the expression that will be carried out for all  the elements that match the 
select criteria. 
select  is the selection criteria (see above, and the rele vant Reference Manual for your 
product for details of selection criteria) 
COUNTVAR  is an optional command which allows you to record how often the expression is 
calculated in Counter , which is increased by one e ach time the expression is evaluated. 
 
You can append the results of such an evaluation to  an existing array using the APPEND 
keyword. For example: VAR !BOXES APPEND EVALUATE ( XLEN*YLEN ) FOR ALL 
BOXES will add the values calculated from the expre ssion for all BOXES to the (already 
existing) array BOXES. You can also overwrite eleme nts in the array by specifying the first 
index in the array which you want to be overwritten . The specified index, and the indexes 
following it, will be overwritten by the results of  the evaluation. For example: 
 

--- Page 60 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 60/178  VAR !BOXES[99] EVALUATE ( XLEN*YLEN ) FOR ALL BOXES  
 
will place the result of the first evaluation for t he selected elements at index 99, overwriting 
any existing item, and the following results in the  subsequent array elements. 
9.3.5. RAW keyword When setting Variables with VAR 
 Programs that use the Forms and Menus interface (e .g. the DESIGN, DRAFT and 
ISODRAFT modules) strip out line feeds and compress  consecutive spaces to a single 
space before text strings are assigned to array var iables. If this is not the effect you want, 
you can suppress this automatic editing by includin g the RAW keyword into the variable-
setting command line for these programs. The syntax  for setting array variable elements to 
unedited text strings is  
 
VAR !VarName RAW ... 
 
where … represents any of the standard VAR syntax f or setting variables. 
9.3.6. Undo and Redo 
 The Undo and Redo functionality has been exposed t o PML so you can create your own 
set of undoable events. There are several ways PDMS  adds entries to the undo system: 
 
• Using the MARKDB / ENDMARKDB commands. The syntax is as follows: MARKDB 
‘text’ 
• where text is an optional description to be includ ed with the mark. This causes a mark 
to be made in the database and an entry made in the  undo stack. You should make 
your database changes, and then use the command END MARKDB 
• By creating a PML undoable object and adding it to  the undo stack. See the Software 
Customization Reference Manual for a fuller descrip tion of this object. You should 
create an undoable object, set up the undo and redo  execution strings, and then 
call the method add() to mark the database and add the undoable to the undo 
stack. Make your database changes, and then call th e method end Undoable(). 
• Automatically whenever a model element is moved us ing graphical interaction 
techniques in Model Editor. Additionally you may re gister to be informed whenever 
an undo or redo operation has taken place, using th e PML PostEvents object. See 
the Software Customization Reference Manual for a f uller description of this object. 
 
After an undoable has been removed from the stack a nd its state recovered then the user 
supplied method on the PostEvents object is called,  and will be passed the description text 
that was associated with the undoable object. 
  

--- Page 61 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 61/178  10. Copies and References 
 Assignment using = , the assignment operator, usua lly does what you would expect, but a 
detailed explanation of how the different data type s are handled may be helpful. 
10.1. Assignment 
 Assignment always makes a copy of the right-hand-s ide to replace what is on the left-
hand side. The following command copies !Y into !X:  
 
!X = !Y 
 
If, for example, !Y is an array, this command will duplicate the entire array making a copy of 
each of the array elements. The same is true if !Y is an OBJECT. The technical term for this 
is deep copy. Following this copy !X[1] = ‘New Value’  
 
will change !X[1] but leave the original array !Y u nchanged. 
10.2. Form and Gadget References 
!!Form and !!Form.Gadget are both PML references. A fter the command: 
 
!X = !!Form.Gadget 
 
!X is now a new reference, but the gadget itself ha s not been copied. Both PML Variables 
now refer to the same gadget. 
 
!X.val = ‘New Value’ 
!!Form.Gadget = ‘New Value’ 
 
will both have the same effect and will assign a ne w value original gadget. You can think of a 
reference as another name for the same object or va riable. 
10.3. DB References 
!!CE is a DB reference. Following the command: 
 
!X = !!CE 
 
!X is now a new reference to the same DB element, b ut the element itself has not been 
copied. 
 
!Value = !X.Attribute 
 
will now return an attribute of the current element . When the current element changes, !!CE 
will point to a new DB element. In this example, !X  will not be changed but remains as a 
reference to the previous current element. Because !!CE is special, 
 
!!CE = !X 
 
will navigate to a new current element provided !X is another DB reference. In this example 
the command would navigate to the previous current element. 
 
10.3.1. Deep Copy involving References: 
Where !Y is an array or object: 
!X = !Y 

--- Page 62 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 62/178  will make a deep copy of !Y. However, if any of the  array elements is a reference (e.g. to a 
gadget or DB element), a copy is made of the refere nce, but not of the object it refers to. In 
other words a deep copy stops copying when it reach ed a reference. 
10.4. Function Arguments 
 A function argument is a PML reference to a value or object outside the function. In effect 
the argument is another name for the original PML V ariable. If we define a PML Function 
such as the following: 
 
define function !!ChangeIt ( !Argument is STRING) 
  !Argument = 'New Value' 
  $P !Argument 
  $P !!Global Var 
Endfunction 
 
Then invoke the function like this: 
 
!!GlobalVar = ‘Old Value’ 
!!ChangeIt (!!GlobalVar) 
 
The values printed for !Argument and !!GlobalVar wi ll both be 'NewValue'. Warning: Be very 
careful about changing function arguments. It is a powerful feature capable of causing 
unexpected results. 
10.4.1. Constants as Function Arguments 
Passing a constant as a function argument, such as a STRING in quotes, means the 
argument is read only and cannot be assigned a new value. So if we define a function 
 
define function !!ChangeString( !Argument is STRING ) 
  !Argument = 'New Value' 
Endfunction 
 
The following will change the value of !S: 
 
!S = ‘Old Value’ 
!!ChangeString ( !S ) 
 
However, the following will result in a PML error m essage because the value passed to the 
function as an argument is a CONSTANT STRING value which cannot be modified. 
 
!!ChangeString ( 'OldValue' ) $* WRONG 
10.4.2. Form and Gadget Properties Passed as Functi on Arguments 
 A form or gadget value passed as a function argume nt is read only so cannot be 
assigned a new value. If you wish to change the val ue of a gadget passed as an argument, 
pass the gadget itself as an argument, not its valu e: 
 
define function !!ChangeValue( !Argument is GADGET)  
  !Argument.val = 'NewValue' 
endfunction 
10.5. Database Attributes 
 PDMS Database Attribute are read only, and so they  cannot be given new values by 
assigning to them. 
  

--- Page 63 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 63/178  11. Developing PML Code 
 All PML variables of type STRING hold their data i n Unicode UTF8 format. Refer to Using 
Unicode Text for further information. Fully develop ed PML code should - if required to - 
interact with the user by means of forms, menus, an d alert boxes. However, while you are 
still developing your PML code the facilities descr ibed here might be useful. The commands 
described here should normally only be typed intera ctively or included in a PML File on a 
temporary basis. None of these commands should rema in in fully developed PML code. 
11.1. Using Unicode Text 
 The PDMS command processor supports Unicode charac ters. All PML string variables 
support Unicode values. You can use Unicode charact ers in PML variable names, PML 
object form and gadget names, PML method and functi on names. Filenames and directory 
names can also contain foreign Unicode characters, but remember that you may have 
problems saving files with foreign Unicode names in  some source management systems e.g. 
ClearCase, so be very wary about using this facilit y. At PDMS12.1 it is mandatory that PML 
Appware source files are stored (in order of prefer ence) as: 
 
1. Unicode UTF8 encoding with a BOM present. 
2. Unicode UTF16 or UTF32 encoding (big-endian or l ittle-endian) with a BOM present. 
3. ASCII 7bit encoding – no BOM needed 
 
Notes: 
• Using Unicode encodings with a BOM means that your  (multilingual) Appware can be 
read successfully anywhere. 
• Restricting your characters to ASCII 7bit (32 – 12 7) means that your (restricted) 
Appware can be read successfully anywhere (this is a strict subset of Unicode). 
• If you use 8-bit single byte non-Unicode character s e.g. degree sign ° (Latin1 
encoding), Euro € (CP1252(ANSI) encoding), OE (CP12 52(ANSI) encoding) etc. 
Then you will probably experience difficulty when t rying to read your Appware with 
CADC_LANG set to Korean, Chinese, Japanese etc. 
11.1.1. Textual File Handling 
By default all sequential text files read by PDMS w ill be expected to be in UTF8 format with a 
Byte Order Mark (BOM) present to identify them. Sim ilarly by default all sequential text files 
written by PDMS will be in Unicode UTF8 format with  a BOM present. The following PDMS 
environment variables are available for users to mo dify how PDMS handles sequential text 
files: 
 
CADC_LANG  specifies file encoding for reading PDMS external files which do not have an 
expected Unicode BOM present. If the variable is un set, then default to LATIN1 format. Files 
with the following Unicode BOMs will be translated to UTF8 on reading: UTF16 little-endian, 
UTF16 big-endian, UTF32 little-endian, UTF32 big-en dian. 
 
CADC_LANG_NEW  specifies the file encoding for new files written by PDMS. If the variable 
is unset, then default to Unicode UTF8 format with a BOM present. The following encodings 
are currently supported: 
 
• Unicode 
• UTF8 Unicode UTF8 
• UTF16LE UTF16 little-endian 
• UTF16BE UTF16 big-endian 
• UTF32LE UTF32 little-endian 

--- Page 64 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 64/178  • UTF32BE UTF32 big-endian 
• ISO 
• LATIN1 ISO8859-1 
• LATIN2 ISO8859-2 
• LATIN5 ISO8859-5 Cyrillic 
• Windows code page 
• CP932 Japanese shift-JIS 
• CP936 Simplified Chinese GBK 
• CP949 Korean 
• CP950 Traditional Chinese Big5 
• CP1250 Central European 
• CP1251 Cyrillic 
• CP1252 LATIN1 + some extras (beware) 
• For backwards compatibility with legacy PDMS Proje cts 
• JAPANESE Japanese shift-JIS 
• CHINESE Simplified Chinese (EUC) 
• KOREAN Korean (EUC) 
• TCHINESE Traditional Chinese (used in Taiwan for e xample) (EUC) 
11.1.2. File Transcoding Utility 
PDMS provides a file transcoding utility transc.exe  which users may find useful, particularly 
for moving files between PDMS12.1 and previous PDMS  versions. Transc is a command line 
application to transcode files from one encoding to  another, and can also be used to add or 
remove the BOM from existing UTF8 (or UTF16) files.  The basic syntax is: 
 
Transc -encoding> <input-file> -encoding> <output-f ile> 
 
See Transc - text file transcoding utility.doc for more details. 
11.1.3. Using Unicode as the new PDMS Internal Form at 
 The major design decision for the Unicode conversi on of PDMS was to use (32bit) 
Unicode Scalar (US) instead of ASCII codes as it's integer character representation (holding 
1 US character code per array element), and to use UTF8 format for its character byte 
strings, with up to 4 bytes to represent 1 characte r. The section below describes a few 
important properties of Unicode Scalars and the UTF 8 format. 
 
1. A Unicode scalar is a 32 bit integer code which uniquely represents a single Unicode 
character. Unicode assumes that the 32 bit range wi ll cope uniquely with all the world's 
character sets. 
2. For the ASCII character set (codes 32 to 127) th e codes are equal to the Unicode scalar 
codes. 
3. UTF8 encoding needs 1, 2, 3 or 4 bytes to repres ent a Unicode scalar. For UTF8 we need 
to be able to clearly distinguish the number of cha racters held and the number of bytes 
needed to represent them - as they cannot be assume d to be the same. 
4. Within UTF8 the ASCII characters can always be f ound by a simple byte by byte search in 
either direction. 
5. UTF8 allows the first byte of any adjacent chara cter to be found by simple byte by byte 
search in either direction, and every first byte yi elds the number of bytes in the character. 
6. After having found a UTF8 character first byte ( which could be an ASCII character e.g. $, 
/, &, space, ~ etc.) then subsequent bytes of the c haracter are never ASCII bytes. So when 
you've found an ASCII byte it is a genuine characte r and not part of another character. 
  

--- Page 65 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 65/178  11.2. PML Tracing 
 If a PML File does not appear to be running in the  way you expect the easiest thing to do 
is to turn on PML Tracing with the command: 
 
PML TRACE ON 
 
With PML Tracing switched on, each of the PML lines  executed is output to the parent 
window together with its line number. Additional tr acing messages tell you when you have 
begun to process a new PML File and when it has fin ished. To turn off tracing type: 
 
PML TRACE OFF 
 
These commands can also be put into a PML File on a  temporary basis. You can also turn 
PML tracing on by setting the Environment Variable PMLTRACE to ON before you start the 
program. For more precise control of PML tracing yo u can use the $R command. $R100 is 
the equivalent of PML TRACE ON and $R0 is the same as PML TRACE OFF. Type the 
command $HR for online help on how to use the $R co mmand. 
11.3. Diagnostic Messages From Within PML Files 
 It is often useful to output a line to the screen from within a running PML File to indicate 
that the execution of the program has reached a par ticular stage. Use the $P command: 
 
$P !Total is: $!Total and !Maximum is: $!Maximum 
 
Note: 
The use of $ to convert the value of a variable to a STRING. 
11.4. Alpha Log 
 The alpha-log is a file containing a record of all  the commands processed together with 
any text output and error messages. To start record ing use one of the following commands: 
 
alpha log /filename $* to open a new file 
alpha log /filename OVERWRITE $* to replace an exis ting file 
alpha log /filename APPEND $* to add to an existing  file 
 
To finish recording and close the file use: 
 
alpha log END 
11.5. Alpha Log and PML Tracing 
 The alpha-log does not include standard PML tracin g from the command PML TRACE 
ON. For PML tracing to be included in the alpha-log , PML tracing should be directed to the 
alpha-window. For example, to obtain standard PML t racing in the alpha-log use the 
command: 
 
$R102 
 
Refer to the online help given by $HR for other opt ions. 
11.6. Suspending a Running PML Macro 
 If you cannot find out what is going wrong by mean s of PML trace output or writing out the 
values of PML Variables, you may suspend a running PML File at a particular point by 
including the command: 

--- Page 66 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 66/178  $MYou 
 
can then query the values of any PML Variables of i nterest and even change the values of 
some PML Variables. To resume processing of the sus pended PML File type into the 
command line: 
 
$M+ 
 
Use these facilities only for debugging and do not leave these commands in a finished PML 
File. 
 
Note: 
These facilities do not apply to PML Functions or m ethods. 
11.7. Querying PML 
 A variety of queries are available to help diagnos e problems. Typically you might type 
these queries into the command line whilst a PML Fi le is suspended. Alternatively you could 
include any of these commands temporarily within a PML File. 
11.7.1. Querying the Currently Running PML File Sta ck 
 If you are interested in the name of the currently  running PML File and the other PML 
Files from which the current file was invoked use t he command: 
 
$QM 
11.7.2. Querying the Values of PML Variables 
 The table below gives some useful commands for que rying PML Variables. 
 
Command   Effect  
q var !LocalName   Queries the value of a specific local variable, u se the command. 
q var LOCAL   Queries the values of all local variables. 
q var !!GlobalName   Queries the value of a specific global variable. 
q var GLOBAL   Queries the values of all global variables 
q var !MyArray[1]   Queries the value of a specific element of an arr ay. 
q var !MyArray   Queries the values of all elements of an array. 
q var !MyArray.Size()   Queries the number of elements currently in an ar ray. 
11.7.3. Querying What Can Be Typed Next 
 When you are typing commands into a macro or into a command line, you may not 
remember exactly what arguments are available or wh at other commands are related. You 
will find full details in the appropriate Reference  Manuals to the module, but you can also ask 
the command processor what sort of command or comma nds it is expecting next by typing: 
$Q 
 
This will produce a list of every valid command wor d or argument type that you may enter 
next. The list may be long and could include every valid command for the module that you 
are in. The $Q facility is also useful to establish  what is allowed as the next component of a 
command. Type the beginning of the command sequence  followed by $Q. 
  

--- Page 67 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 67/178  12. Upgrading from PML1 to PML2 
12.1. Difference between PML 1 and PML2 
12.1.1. PML1 advantages 
• PML 1-First version of PML including loops, if sta tements, string handling , labels. 
• Is faster with simple single line definition and s ingle execution, 
• Returns array of strings of the references, 
• The scope can include volumetric limits (within …) , 
• To obtain a value in PML 1 must be preceded with $ , var !value ($!number), 
• PML1 must be still used when an expression is used  as an argument to a command 
and must be enclosed in () brackets, 
• PML 1 macros are in PDMSUI folder, 
12.1.2. PML2 advantages 
• PML 2-Object oriented language builds on PML 1 and  extends the facilities to be like 
other object based languages (VB, Smalltalk) 
• Is slower and initially more lines of code to set up the collection is necessary, 
• Returns array of database references and  
• Collection can be used as the scope of a collectio n, 
• Can be used with the TABLE object, 
• Can’t use volumes to limit the scope, 
• To obtain a value in PML 2 is used =, !value = !nu mber, 
• PML2 may be of any complexity, may contain PML fun ctions and methods and form 
gadget values, !value = !!MyFunction(!arg) * !!Form .Gadget.Val / 
!MyArray.Method(), 
• PML2 may consist operators and operands (+,-,*,/,G T,AND,OR,&,EQ…), 
• PML 2 macros are in PMLLIB, 
• Variable Types - STRING, REAL, BOOLEAN and ARRAY, 
• Built in methods for commonly used actions, 
• User Defined Object Types, 
• PML Search PATH (%PMLLIB%), 
• Dynamic Loading of Forms, Functions and Objects, 
• New Aid objects for geometric modelling, 
• $Wn - Will Break the GUI Software 
• Numbered Variables - Are no longer available 
• Macros - Avoid Mixing with PML Functions 
• Global Variables for results - Use Function “Retur n” 
• $M- $M+ $MK - Only for debugging, not LIVE code 
• $R+ $R- - Withdrawn, (PML TRACE ON/OFF) 
• Synonyms - Not permitted in PML Functions but work s in macros, 
• VAR Syntax - Use “=“ Where possible 
• VAR Name READ - Use ALERT object or Form 
• Expressions in () - Brackets not needed after “=“ 
• !VALUE = NAME - Use !VALUE = !!CE 
• $ - Use variables without $ 
• Don’t Quote variables - With no $, quotes not need ed 
• @ cursor functions - Use Event Driven Graphics 
• !ARRAY[-ve] - Not allowed in PML2 
• !ARRAY[0] - Not advised to use at PML2 
• Dots “.” In Names - New meaning at PML2 
• Form EDIT  - syntax Use direct setting  

--- Page 68 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 68/178  12.2. Important differences 
Only Algebraic expressions are allowed, (No reverse -polish notations after “=“ sign) 
 
Creating numeric variable with “=“ creates a REAL 
 
Some PML1 macros using the “=“ will now create vari ables of the wrong type. 
 
VAR !name value will now create a STRING value. 
 
DO variables are now REAL rather than STRING 
 
If “=“ has been used in existing PML code and probl ems are found, re-write the code using 
PML2 technology, or revert to PML1 VAR technology. 
 
Conversion utility “eq2var” (Currently runs through  an “awk” script) 
 
DO variables in PML2 are automatically deleted to e nsure that they can be created, This can 
upset other variables if of the same name. 
 
On exit DO variables remain REAL; previously they w ould have been STRING +1 if loop ran 
to completion. 
 
Variable in “do values” is deleted on exit. 
 
DO from to are required to be REAL, Existing macros  are unaffected by this ($) 
 
Change variable names to avoid DO variables 
 
Check DO expressions, re-write as necessary 
 
Results of an expression in IF must be TRUE or FALS E. 
 
An error will occur where ZERO=FALSE 
 
e.g.                                     if ($value) then - - (PML1)  
will have to be either       if ($value EQ 1) then  
                                  or if ( BOOLEAN($value)) then  
 
Most common occurrence  
PML1  if ( match ($!String1,$!String2)) then  
PML2  if ( match ($!String1,$!String2) GT 0 ) then  
 
Check Form and Global Variable Names 
 
Forms are now GLOBAL variables, and cannot have the  same names as a Global Variable. 
 
Form and Gadget Names Must be Unique and Start with  a Letter 
 
Forms & Menus enforces the rule that gadget names m ust start with a letter, and must be 
unique, (Gadget names can be re-used in different f orms). 
 
New Forms & Menus Error Messages. 
 
No longer possible to use setup form from within .I NIT macro. 

--- Page 69 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 69/178   
Gadgets that are outside the form are now ERRORS. 
 
More than one OK,CANCEL or HELP will generate an er ror. 
 
Var list & do list are restricted to LIST gadgets, for TEXTPANES & SELECTOR gadgets use 
var pane,selector & do selector 
 
DOT in variable, Form and Gadget Names Is now used as separator between a Form or 
Object name and the name of one of its members or f unctions. 
 
!Array.size() 
var !String ‘comment’ 
!Old.Name = ‘!String’ 
 
could now use: 
!Size = $!<Old.name>.length() 
or 
!Size = $!Old.name$N.length() 
 
Negative Array Subscript is now an Error. 
Array subscripts MUST now be positive or zero, Zero  is permitted but many of the array 
methods ignore the zero’th element. Macros which ma ke use of negative array subscripts 
will need to be revised. 
 
$MKn & $MK-n Withdrawn. 
 
These commands may have had a role when macros were  run directly from a terminal, but 
are incompatible with form-driven software. 
 
Macros will have to be re-written. 
 
Synonyms are NOT Available in PML Functions but are  still available in Macros. 
 
= in PDMS10 is not compatible with = in PDMS11 
 
Components in Function to the Right of “=“ 
 
Existing “var” code is not affected. 
 
Add brackets if PML1 code has none. 
 
To convert to “text” add “$” 
 
!X = 32 , !Y = 52 
!Z = !X + !Y Result = REAL  …..84 
!Z = ‘$!X’ + ‘$!Y’ Result = STRING  …..3252 
 
  

--- Page 70 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 70/178  13. PML Form concepts 
13.1. Overview 
 The AVEVA software module which provides the abili ty for users to customize the PDMS 
graphical user interface using the PML is referred to as PML Forms & Menus (or just F&M). 
The default ‘system font’ used by Forms and Menus t o display character data is Arial 
Unicode MS which contains a large number of the wor ld’s alphabets. Internally F&M uses full 
Unicode, but can only display the characters access ible in its current ‘system font’. You will 
be able to copy and paste Unicode characters from a nd to textual fields of F&M gadgets. 
 
 In PML 2, forms are a type of object represented b y a global variable — the form’s name, 
for example !!EntryForm . This means that a form cannot have the same name as any other 
object type, global variable, or any other form. Th e form object owns a set of predefined 
member variables and built-in methods. In addition,  you can define your own members — 
form variables and form gadgets — and your own form  methods. All these will determine the 
content and functionality of the form. Gadget objec ts are user-defined members of the form 
object. Form members are always accessed using the dot notation, for example 
 
!!EntryForm.TextField 
 
Gadgets own a set of predefined member variables an d built-in methods which determine 
the content and functionality of the gadget. For ex ample, the value of a text field gadget is 
accessed by: 
 
!!EntryForm.TextField.val.  
 
Note that gadgets do not support user-defined membe r variables or user-defined gadget 
methods. 
 
Callbacks  are user-defined actions assigned to a form and it s gadgets and that are 
executed when the operator interacts with the form,  for example, by clicking a mouse button 
on a gadget. The callbacks are supplied as text str ings and may be any valid PML 
expression, PML Function or method call, including any form, gadget or user defined object 
method. Effectively, these callbacks determine the intelligence of the form. 
13.2. Naming Forms and their Members 
 The following are examples of the format of form a nd member names: 
 
!!EntryForm  The name of a form 
!!EntryForm .GadgetName The name of a gadget on a form 
!!EntryForm .GadgetName.val The data value held by that gadget 
 
Note: 
That total length of the name is limited to 1024 ch aracters even though the length each 
individual components is limited to 64 characters. Within the form definition, the members of 
the form should be referred to by using !This to re place the form name part of the gadget 
name. For example: 
 
!This.GadgetName 
!This.GadgetName.val 
 
Note: The obsolete convention of using an underscore to r eplace the form name has been 
retained for compatibility with earlier versions.   

--- Page 71 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 71/178  13.3. Simple Form 
 You define a form using a command sequence that st arts with: 
 
setup form !!formname 
 
and ending with: 
 
exit 
 
 Between these two commands come a number of option al subcommands which define 
the gadgets on the form. The following example defi nes a small form, containing the text 
‘Hello  World’, and a button labelled ‘ Goodbye’ , which removes the form when pressed: 
 
setup form !!hello 
  paragraph .Message text 'Hello world' 
  button .bye 'Goodbye' OK 
exit 
 
Picture Nr.4. - A simple form 
 Some points to note about the above definition and  the form it creates are: 
 
• there are no user-defined methods on this form, an d so the setup form . . . exit 
sequence is the complete form definition; 
• the paragraph command adds a paragraph gadget to t he form (a paragraph gadget is 
just a piece of text displayed on the form). The na me of the gadget is Message, and 
the dot before the name indicates that the gadget i s a member of the form. The text 
itself is specified after the keyword TEXT. 
• the button subcommand adds a button gadget named . bye. The text on the button will 
be ‘Goodbye’. The keyword OK is a form control attr ibute that specifies that the 
action of this button is to remove the form from th e screen. 
 
To display the form in this example, you can use th e command: 
 
show !!Hello 
13.3.1. Adding a Gadget Callback 
 To perform intelligent actions a form or gadget mu st invoke a callback.We will now add a 
simple gadget callback to the hello form. We will a dd a second button, change message, 
which will execute a callback to modify the Message  paragraph gadget. 
 
setup form !!hello 
  paragraph .Message text 'Hello world' 
  button .change ‘Change message’ callback |!this.m essage.val = ‘Modified’| 
  button .bye 'Goodbye' OK 
exit 
 
Picture Nr.5. - A form with gadget callback  


--- Page 72 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 72/178   A gadget callback is defined by the callback comma nd followed by a command or PML 
Function enclosed in text delimiters. As we are giv ing a text string as part of the command 
which is itself supplied as a text string, we have had to use two kinds of delimiter: the 
apostrophe, (‘) and the (|) vertical bar. 
 
Note: The use of this to mean the current form. When the callback is executed, 
 
!this.message.val = ‘Modified’ 
 
will set the value member of the gadget Message on this form to read Modified rather than 
Hello world. 
 
Note: The gadget callback could have been 
 
|!!OtherForm.Para.val = ‘Modified’| 
 
to change the value of a paragraph gadget on anothe r form named !!OtherForm. Typically a 
callback will involve many commands and could be a complex piece of code in its own right. 
In practice, the recommended way of defining a comp licated callback is to use a form 
method. 
13.4. Form Definition File 
 Form definitions must be held one per file. The fi le name must be the form’s name in 
lowercase with the file extension .pmlfrm.  For example, our form !!Hello would be captured 
in a file called hello.pmlfrm. This definition file should be stored in a director y pointed to by 
the PMLLIB  environment variable. It will then be loaded autom atically on execution of the 
show !!Hello  command. The form definition file contains: 
 
• The form definition between setup form and exit. T his includes the commands which 
create the form itself, and set its attributes, suc h as its size and title, the commands 
which create the gadgets on the form and specify ho w they are arranged, and the 
definitions of any variables which are to be member s of the form. 
• Any method definitions should follow the exit comm and, each method beginning with 
the define method command and ending with endmethod . Methods on forms are 
just like methods on any other kind of object. 
• In particular, it will contain the form's default constructor method. This is a method with 
the same name as the form, and no arguments. It is the only method called 
automatically when the form is loaded, and so it ca n be used, among other things, 
to set default values for the gadgets on the form. 
• The form may be given an initialization method, wh ich is run whenever the form is 
shown (as opposed to when it is loaded). 
• No executable statements should appear in the file  outside of the form definition or 
form methods. The effect of misplaced executable st atements is indeterminate. You 
can put comments anywhere in the file. 
13.5. How Forms are Loaded and Displayed 
 A form definition must be loaded before the form c an be displayed. If you have stored the 
definition in a . pmlfrm  file then loading will be automatic when the form is displayed for the 
first time. Normally, a form is displayed as a resu lt of the operator making a menu selection 
or pressing a button on a form. This is achieved ei ther by using the Form Directive in the 
menu or button definition (see next section) or by means of the command show !!formname  
used in the gadget’s callback. However, to display forms when you are developing them, you 
may find it convenient to type the command: 
show !!formname  

--- Page 73 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 73/178   Sometimes it is useful to force the loading of a f orm’s definition file before the form is 
actually displayed, so that you can edit the form o r gadget attributes from another form’s 
callbacks before the form is actually displayed. Us ing the command 
 
loadform !!formname 
 
from a callback will force load the definition if t he form is unknown to PML, but do nothing if 
the form has already been loaded. Once a form has b een displayed you can remove it from 
the screen using the command 
 
hide !!formname 
 
Note that if you show it again it will appear on th e screen, but its definition is already known 
to PML and so it will not be loaded. It is possible  to remove a form definition from PML using 
the command 
 
kill !!formname 
 
The form is then no longer known to PML until a new  definition is loaded. 
 
Note:  Earlier AppWare used form definitions in macro fil es which had to be loaded explicitly 
via $M path-name-to-file. This mechanism still oper ates for backwards compatibility, but is 
strongly discouraged when writing new AppWare. 
13.6. PML Directives 
 PML directives are commands used to control PML it self. For example, you use a PML 
directive to instruct PML to re-make its index when  you have added a new file. Some of 
these directives have been described in Storing and  Loading PML Files: the information is 
repeated here, with additional directives for loadi ng forms. Note: Unlike the PML commands 
described in How Forms are Loaded and Displayed, PM L directives should not be included 
in callbacks, but are generally for command line us e. You will need to use PML directives 
when you are developing new form definitions or mod ifying existing ones. PML directives are 
commands of the form pml . . . The table below give s some useful PML directives. 
 
Command Effect: 
 
pml rehash  When you create a new PML Form while an AVEVA prod uct is running, you 
must link in the file storing the form by giving th is command. It causes PML to scan all the 
directories under the PMLLIB path, and to create a file pml.index, which contains a list of all 
the .pmlfrm files in the directories. 
pml index  This command re-reads all the pml.index files in y our search path without 
rebuilding them. If other users have added PML File s and updated the appropriate pml.index 
files, you can access the new files by giving this command. 
pml reload form !!formname  When you edit an existing form while an AVEVA prod uct is 
running, you must use this directive to reload the form definition file. 
kill !!formname  If you experience problems of an edited form defin ition not being re-loaded, 
you can use this directive followed by the pml relo ad directive. 
pmlscan directory_name  This command runs a utility supplied with AVEVA pr oducts. 
When you are not running an AVEVA product, you can use this command to update the 
pml.index file in a given directory. 
  

--- Page 74 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 74/178  13.7. Revisiting our Simple Form 
Our simple form !!Hello , which we constructed earlier in this chapter, is not very intelligent. 
Once we have pressed the Change button the .Message  paragraph will read ‘Modified’ for 
ever more, even if we hide the form and re-show it.  The extended version of form !!Hello 
below: 
 
• illustrates the use of the form definition file; 
• illustrates form methods as callbacks; 
• introduces some important predefined form members.  
 
First save the definition in a file called hello.pm lfrm and ensure that its directory is in your 
PMLLIB search-path. 
 
setup form !!hello 
  title ‘Display Your Message’ 
  paragraph .Message width 15 height 1 
  text .capture ‘Enter message’ width 15 is STRING 
  button .bye 'Goodbye' OK 
exit 
 
define method .hello() 
  -- default constructor - set gadget load-time def ault 
  values 
  !this.message.val = ‘Hello world’ 
  !this.capture.callback = ‘!this.message.val = !th is.capture.val’ 
  !this.Okcall = ‘!this.success()’ 
Endmethod 
 
define method .success() 
  -- action when OK button is pressed 
  !this.message.val = ‘Hello again’ 
  !this.capture.val = ‘’ 
Endmethod 
 
 
Picture Nr.6. - A Smarter Form 
 
In the form definition: 
 
• title sets the form title member and hence display s a title; 
• para adds a PARAGRAPH gadget size 15 chars by 1 li ne with no content; 
• text adds a TEXT field gadget with tag ‘Enter mess age’, width 15 chars, to hold data of 
type STRING. 
 
The constructor method .hello() does the following:  
 
• initializes the paragraph’s default value to ‘Hell o world’; 
• defines the callback on the text input field: to i nsert its value into the paragraph; 
• sets the form member Okcall (in the line beginning  !this.Okcall). This is a callback that 
gets executed when a button with control-type OK is  pressed. 
  


--- Page 75 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 75/178  The definition of method .success() does the follow ing: 
 
• Sets the paragraph’s value to ‘Hello again’. 
• Resets the text field’s value to empty. 
 
Now load and show the form by typing: 
 
PML rehash 
show !!Hello 
 
 This will auto-load the form definition and execut e the default constructor method (which 
will set the message paragraph to ‘Hello world’ and  define the gadget and form callbacks). It 
will also display the form. Type your message into the Enter message field and press the 
Enter key. This will execute the field’s callback, which will write your typed text into the 
message paragraph. Type a new message and press Ent er. The paragraph updates to 
reflect what you typed. Click the Goodbye button. T his executes the form’s Okcall action 
which calls the success() method. The success() met hod sets the paragraph to ‘Hello again’ 
and blanks out the text field. Finally, the OK cont rol action hides the form. 
 
Show the form again and observe that the paragraph reads ‘Hello again’ and not ‘Hello 
world’. This demonstrates that when you re-show the  form the form’s constructor is not run, 
because the form is already loaded. If you want to reset the form every time it is shown, you 
must define a form initialization callback. 
  

--- Page 76 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 76/178  14. Forms and Gadget callbacks 
14.1. Callbacks: Expressions 
A callback may be any valid expression, including a ny AVEVA product commands. For 
example, the following is a PDMS command: 
‘new box xlen 10 ylen 20 zlen 50’ 
 
It can also include PML general commands like 
‘$m %pathname%/MyMacro’ 
 
to execute a given command macro, or 
‘q var !!form’ 
‘q var !!form.gadget’ 
 
which will write out details of the form or gadget and its members. You might like to try 
it on the form !!Hello.Typical expressions for a ca llback are 
 
‘!this.gadget.val = !MyObject.count’ 
‘!MyObject.count = !this.gadget.val’ 
 
which get or set the value of a gadget on the form from or to a user-defined object. 
14.2. Callbacks: Form Methods / PML Functions 
 Most callbacks require more than a single command,  so invoking a method or function (or 
macro) is an essential requirement. The advantage o f using form methods as callbacks is 
that this keeps the whole form definition in a sing le file. Forms defined in early versions of 
PML 2 used PML Functions as callbacks. This is stil l valid and is sometimes even essential 
as you may need to manage a group of forms; but mos tly the callbacks on a form are 
specific to that form. 
 
setup form !!hello 
  title ‘Display Your Message’ 
  paragraph .Message width 15 height 1 
  text .capture ‘Enter message’ width 15 is STRING 
  button .bye 'Goodbye' OK 
exit 
 
define method .hello() 
  !this.message.val = ‘Hello world’ 
  !this.capture.callback = ‘!this.message.val = !th is.capture.val’ 
  !this.Okcall = ‘!this.success()’ 
Endmethod 
 
define method .success() 
  !this.capture.val = ‘’ 
endmethod 
 
 The .success() method above could only deliver a f ixed string ‘Hello again’ to the 
message PARAGRAPH gadget. The great advantage of me thods is that you can pass 
variables as arguments to the method, so it can be used more generally, for example as the 
callback to several gadgets. 
 
define method .success( !output is GADGET, !message  is STRING, !input is GADGET ) 
  output.val = !message 
  input.val = ‘’ 
endmethod 

--- Page 77 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 77/178  We have added three arguments, an output gadget, an  input gadget and a message string 
variable. This has made the method very general. We  can still use it as the Okcall callback: 
 
!this.Okcall = |!this.success( !this.message, ‘Hell o again’,!this.capture )| 
 
 When the OK button is pressed the Okcall action wi ll invoke the success() method, 
passing to it the message paragraph gadget as !outp ut, the message text ‘Hello again’ as 
!message and the text input field gadget capture as  !input. The method will do just what it did 
before. However, we could use it differently. We co uld add another button gadget, Restart, to 
the form: 
 
button .restore 'Restart' callback |!this.success( !this.message,‘Hello world’, !this.capture )| 
 
 When clicked, the Restart button‘s callback will e xecute and set the message paragraph 
gadget to read ‘Hello world’ and clear the capture text field, thus restoring the form to its 
state when it was displayed for the very first time . If we invoked the success() method as: 
 
!this.success( !this.capture, ‘Hello world’, !this. message ) 
 
it would set the value ‘Hello world’ into the captu re text input field and clear the contents of 
the message PARAGRAPH gadget. Not what you need her e perhaps, but you can see how 
versatile methods can be! 
 
Note:  The arguments to methods can be any valid PML obje ct types, built in or user 
defined. 
14.3. PML Open Callbacks 
14.3.1. Events 
When the operator interacts with a GUI, an event oc curs. For example, when the operator: 
 
• types something into a field on a form; 
• moves the cursor into a window; 
• presses down a mouse button; 
• moves the mouse with button down; 
• let’s the button up. 
 
 The events are queued in a time-ordered queue. The  application software services this 
queue: it gets the next event, determines the objec t of the event (for example, form, gadget, 
menu) and the event type (for example, enter, leave , select, unselect, popup etc.), deduces 
appropriate actions and carries them out. When one event is completed, the software looks 
for the next event. 
14.3.2. Open Callbacks at Meta-events 
 There are a very large number of possible events, and most of them are very low level 
and have to be serviced very quickly to produce a u sable GUI. It would be inappropriate to 
allow the (interpreted) PML AppWare access to them all. However, the application software 
defines a set of meta-events for forms and gadgets. When a meta-event occurs, th e 
application software checks for user-defined callba cks and executes them. Hence callbacks 
are the AppWare’s way of providing actions to be ca rried out at these meta-events. 
 
 Callbacks provide a simple yet versatile mechanism  for the AppWare to create and 
manage the GUI. Sometimes there is more than one me ta-event associated with a gadget. 
In this case, the simple assigned callback is insuf ficient to fully exploit the gadget's possible 
behaviors. To overcome this shortcoming we can use open callbacks to allow the AppWare 

--- Page 78 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 78/178  to be informed whenever a meta-event is encountered . Open callbacks can be used 
wherever callbacks can be used. They always involve  methods or PML Functions with a 
fixed argument list as follows: 
 
define method .Control( !object is FormsAndMenusObj ect, !action is STRING) 
 
• !object is a Forms and Menus object, for example, a form, gadget or menu. 
• !action is the meta-event that occurred on the obj ect and represents the action to be 
carried out by the method. 
 
The open callback is a string of the form: 
'!this.MethodName(' 
 
Note:  The open bracket '(', no arguments and no closing b racket. The callback is to an open 
method or function. 
 
We might assign an open callback to a multi-choice list gadget as follows: 
 
setup form !!Open 
  title 'Test Open Callbacks' 
  list .choose callback '!this.control(' multi widt h 15 height 8 
exit 
define method .open() 
  do !i from 1 to 10 
    !fields[!i] = 'list field $!i' 
  enddo 
  !this.choose.dtext = !fields 
endmethod 
define method .Control( !object is GADGET, !action is STRING) 
  if ( !action eq 'SELECT' ) then 
   --find out all about our gadget object 
    !form = !object.owner() $*get object’s owner 
    !type = !object.type() $*get object type 
    !name = !object.name() $*get object name 
    !field = !object.PickedField $*get picked field  number 
    !s = !object.DTEXT[!field] $*get DTEXT 
    -- do something with the data 
    $p selected $!form$n.$!name $!type field $!fiel d, D text{$!s} 
  elseif (!action eq 'UNSELECT' ) then 
    !n = !object.PickedField $*get picked field num ber 
     $p unselected field $!n $*do something with     data 
  endif 
endmethod 
 
Note  in the constructor method open() we have initializ ed the list so that field n will display 
list field n. DTEXT is a shorthand for display-text , that is the text displayed in the list field. 
• Control is the method which manages interaction wi th the list. Note the open callback 
• defined in list choose. 
• Note the use of $* for in-line comments 
• Note the use of the printing command $p to print i nformation to the system Request 
channel. $!form replaces the variable !form with it s current value as a string - this 
only works for PML simple in-built scalars types RE AL, STRING, BOOLEAN. $n in 
$!form$n.$!name is a separator needed to separate $ !form from the following ‘.’ 
which would otherwise be thought of as part of the variable name. When a list field 
is clicked, the list’s callback will be examined an d if it is an open method or function, 
then the Forms and Menus software will supply the a rguments required to complete 
the function. 

--- Page 79 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 79/178  Thus in this case the actual callback string execut ed will be 
 
|!this.control( !!Open.choose, ‘SELECT’ )| 
 
 Inside the control() method we branch on the value  of !action and access the data of 
!object (in this case our list). Finally we perform  our application’s resultant action - in this 
case just printing out all we know about the operat or interaction using the $p command, 
which for a selection of an un-highlighted list fie ld will write: 
 
Selected OPEN.CHOOSE LIST field 5, Dtext{list field  5} 
 
Notice that the same method could be used to manage  several or even all gadgets on our 
form since the variable !object is a reference to a  gadget object and is supplied as 
!!Open.choose, the full name of the gadget includin g its form. This allows us to find 
everything about that object from its in-built meth ods, including its gadget type (LIST, 
TOGGLE, etc) and its owning form: 
 
!type = !object.type() 
!form = !object.owner() 
14.3.3. Using a PML Function in an Open Callback 
All the examples so far have used form methods as o pen callbacks. The code would be 
essentially the same if we used PML Functions. The PML Function must be in a file of its 
own called control.pmlfnc. The body of the definiti on would be identical but must be 
bracketed by: 
 
define function !!Control( !object is GADGET, !acti on isSTRING) 
endfunction 
 
Note that the function has a global name !!control,  that is, it is not a member of any form or 
object and thus cannot use the !this variable The o pen callback on the choose list gadget 
would become 
 
list .choose callback '!!control(' multi width 15 h eight 8 
 
The rest of the story remains the same. 
14.3.4. Objects That Can Have Open Callbacks 
 Object  Object Callback 
LIST multichoice Gadget SELECT,UNSELECT,START,STOP 
LIST singlechoice Gadget SELECT, UNSELECT 
OPTION Gadget SELECT, UNSELECT 
ALPHA VIEW Gadget SELECT 
BUTTON Gadget SELECT, UNSELECT 
TOGGLE and RTOGGLE Gadget SELECT, UNSELECT 
MENU (command fields) Menu SELECT, INIT 
MENU (toggle fields) Menu SELECT, UNSELECT, INIT 
FORM Form INIT, QUIT, CANCEL, OK,KILLING, FIRSTSHOW N 
TEXT Gadget SELECT, MODIFIED, VALIDATE 
SLIDER Gadget START, STOP, MOVE 
FRAME Gadget SELECT, UNSELECT,SHOWN, HIDDEN 
NUMERICINPUT Gadget SELECT, MODIFIED 
COMBOBOX Gadget SELECT, UNSELECT, VALIDATE 
 
  

--- Page 80 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 80/178  15. Forms 
15.1. Modules and Applications 
 A PDMS GUI module consists of a set of co-operatin g applications running within the 
Application Window. Each module has: 
 
• A Main form to present the default application and  to control access to the other 
applications. 
• One or more document forms usually displaying the application model. 
• Transient floating dialog forms that relate to spe cific tasks. 
• A small number of docking dialog forms to provide frequently required services. The 
Main form has a menu bar that provides access to al l the functionality of the current 
application of the module, from its pull-down menus  (the main menu system), and a 
set of toolbars, each containing gadgets (usually i con buttons, icon toggles and pull-
down lists) designed to give fast access to frequen tly used functions. The Main form 
is not displayed directly, but supplies all its men us and toolbars to be displayed in 
the Application Window. 
15.2. Defining a Form 
The form definition is a command sequence starting with: 
 
setup form !!formname 
 
and ending with: 
 
exit 
 
The sequence includes: 
 
• The commands which create the form itself and set its attributes, such as its minimum 
size and title. 
• The commands which create the gadgets on the form,  and specify how they are 
arranged. 
• The definitions of any variables which are to be m embers of the form. 
15.2.1. Form Attributes 
All the form attributes are optional and have sensi ble defaults. Those which can only be set 
once must be specified on the setup form line. Thes e are: 
 
• Form type. 
• Layout mode. 
• Minimum size. 
• Resize. 
• Docking. 
• Form position. 
• NOQUIT 
• NOALIGN 
 
Other attributes are specified as sub-commands in t he setup form . . . exit sequence. They 
can be edited after the form has been created by me ans of the form’s in-built members and 
methods. 
  

--- Page 81 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 81/178  15.2.2. Form Type 
 The appearance and behaviour of a form is determin ed by its Type attribute: 
 
MAIN  The form that will be swapped to as a Main form. T hese forms are not usually 
displayed directly, but serve to provide gadgets fo r the application’s toolbar and menus for 
the application’s main menus. 
DOCUMENT  Resizable form usually with a view gadget, but no menu bar. All document 
forms can be floated or un-floated using the right- mouse popup menu in the form’s top 
border. When it is floating, you can drag the form away from the MDI frame and position it 
and resize it without constraint. This allows you t o drag the document form away to another 
screen of a multiscreen configuration. 
DIALOG  This is the default type the form will assume if y ou give no type when you set up 
the form. The default DIALOG form will be non-resiz able, floating, and non-docking. You can 
specify the 
DOCKING  attribute to allow the form to be docked within th e application frame. By default, a 
docking dialog is displayed floating, and you can i nteractively dock it. When a dialog is 
docked it will be resized to match the application frame edge to which it is docked, and so is 
resizable by default. The qualifiers LEFT, RIGHT, T OP, and BOTTOM, specify the edge of 
the application frame to which the dialog form will  be docked when first displayed. 
BLOCKING DIALOG  Normal form layout and content, but will block acc ess to all other 
forms while it is displayed. 
 
Here are some examples of ways you can set up forms  of different types: 
 
setup form !!myform dialog dock left - Creates a re sizable docking dialog; 
setup form !!myform dialog resizable - Creates a re sizable floating dialog; 
setup form !!myform dialog - Creates a non-resizabl e floating dialog; 
setup form !!myform - Creates a non-resizable float ing dialog; 
setup form !!myform document - Creates a resizable MDI child document; 
setup form !!myform document Float - Creates a floa ting resizable non-MDI document. 
15.2.3. Layout Modes 
 Two layout modes are supported, namely VarChars an d FixChars. VarChars is a new 
layout mode, based on measuring precise string widt hs. It is better suited to the use of 
variably spaced fonts, and tends to produce smaller , more pleasing forms, without unwanted 
space. The benefits of using VarChars are: 
 
• It tends to produce smaller, more pleasing forms, without unwanted space. 
• No text wrap-around, except possibly in conjunctio n with TagWidth. 
• No truncation of explicitly defined text except po ssibly in conjunction with TagWidth. 
 
The recommended layout mode for all new forms is: 
setup form !!formname . . . VarChars 
 
 FixChars is the old layout mode (prior to PDMS12.1 ), which is based on the use of 
notional character width to calculate the approxima te sizes of textual gadgets and gadget 
tags. Because the calculated sizes are only approxi mate, the user has to make frequent use 
of the gadget's Width specifier and TagWidth specif ier and considerable trial and error to 
achieve a desired layout. 
 The default layout mode for setup form is FixChars, because this will be th e least 
disruptive for existing user Appware, so FixChars m ode will currently result from either of 
 
setup form !!formname . . . 
setup form !!formname . . . FixChars 

--- Page 82 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 82/178  15.2.4. Minimum Size and Resizability 
 A form will automatically stretch to fit the gadge ts you add to it. You can use the SIZE 
keyword to give a minimum size in multiples of the character width and line height . For 
example: 
 
setup form !!New1 size 25.5 10 
 
• Character width is the notional character width for the selected ch aracter font. 
• Line height is the height of the tallest single line gadget, th at is a TOGGLE , BUTTON , 
 
RADIO BUTTON, OPTION  gadget or single-line PARAGRAPH  for the selected character 
font. The RESIZABLE command means that the form wil l be displayed with re-sizing controls 
at its corners. This will allow the user to change the size of the form. Docking forms and all 
document forms are resizable by default; but for ot her types, if you do not include the 
RESIZABLE command, the size of the form is fixed. 
 
setup form !!New1 RESIZABLE 
setup form !!New2 size 25 10 RESIZABLE 
15.2.5. Intelligent Resizable Forms 
 All gadgets except ALPHA and VIEW gadgets have DOCK and ANCHOR attributes that 
allow you to define gadgets that have intelligent p ositioning and resizing behaviour when 
their container gadget resizes. 
 
 This allows you to have more than one resizable ga dget on a form and still have 
predictable and potentially complex resize behaviou r. However, the DOCK and ANCHOR 
attributes are mutually exclusive: setting the DOCK  attribute resets the ANCHOR to the 
default; setting the ANCHOR attribute resets DOCK t o none. 
 
 ALPHA and VIEW gadgets do not support DOCK or ANCH OR attributes. They do, 
however, expand to fill their containers, so you ca n put them in a frame and set the frame’s 
DOCK or ANCHOR attributes to get the behaviour you desire. 
15.2.6. Gadget Alignment Control 
Certain gadgets, known as the linear gadgets, have their centres auto-aligned 
approximately to aid simple layout without the user  having to know about PATH and ALIGN 
concepts. 
 
 This pseudo-alignment gives sensible layout for si mple forms, but introduces small errors 
in all other circumstances and prevents accurate co ntrolled layout because the user doesn’t 
know the offsets applied. The NOALIGN keyword allow s you to switch off this pseudo 
alignment. 
15.2.7. No Alignment 
 The gadgets BUTTON, TOGGLE, TEXT, OPTION, single l ine PARGRAPH fit within 1 
vertical grid unit and are by default drawn with th eir Y-coordinate adjusted so that they would 
approximately centre-align with an adjacent BUTTON.  This pseudo-alignment introduces 
small errors in all but a few circumstances and pre vents accurate controlled layout. 
NOALIGN prevents this (historical) gadget auto-alig nment. Use NOALIGN in conjunction 
with PATH RIGHT (the default path) and HALIGN CENTR E, as it gives a better layout, with 
fewer surprises. 
Note:  It is bad practice to place one gadget on top of a nother. This may lead to gadgets 
being obscured. The commands to set modifiable attr ibutes are described after the syntax 
graph.  

--- Page 83 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 83/178  15.3. Form Members 
15.3.1. Form Title and Icon Title 
 The title sub-command is used to supply a string t hat is displayed in its banner at the top 
of the form's window. To set the title: 
 
title 'Quite a Long Title for a Form' 
 
You can modify the title at any time using the Form Title member: 
 
!!MyForm.FormTitle = 'Modified Title' 
 
The icontitle sub-command is used to supply a strin g that is used when a form is iconized. 
To set the icon title: icontitle 'Short Title' 
 
You can also modify the icon title at any time usin g the IconTitle member: 
 
!!MyForm.IconTitle = ‘New Icon’ 
15.3.2. Form Initialisation Callback 
 The form’s initialisation callback allows the form ’s gadgets to be initialised every time it is 
shown to reflect the current state of the applicati on and possibly to validate whether the form 
can be displayed in the current context. You can se t the callback by assigning to the form’s 
initcall member. This can be done with the INITCALL  command: 
 
INITCALL ‘!This.InitCallBack()’ 
 
or directly by 
 
!!MyForm.initcall = ‘This.InitCallBack()’ 
 
Note:  The form initialisation callback must not attempt to display another form. You may 
invoke an ALERT object but not otherwise seek any i nput from the user. If the callback 
discovers an error so serious that the form cannot be displayed it can abort the display of the 
form by returning an error. You can supply the text  of an error message that is to be 
presented in an error alert in place of the form: 
 
define method .initcallback() 
  return error 1 'You do not have write access to t his 
  database' 
endmethod 
 
If the initialisation callback has already caused a n alert to be raised then you can prevent the 
raising of a new error alert by using the NOALERT k eyword: 
 
define method .initcallback() 
  return error 1 NOALERT 
endmethod 
15.3.3. Form OK and CANCEL Callbacks 
The form supports the concepts of OK and CANCEL act ions: 
 
The OKCALL callback is executed when a form’s OK bu tton is pressed or when the OK 
button of a form’s ancestor has been pressed It all ows operators to approve the current 
gadget settings and carry out the function of the f orm. The form is then removed from the 
screen. Typically this callback will gather all the  data from the form’s gadgets and perform 

--- Page 84 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 84/178  the form’s major task. If you do anything of signif icance in callbacks on other gadgets you 
may have a hard time undoing everything if the user  presses the CANCEL button. You can 
assign to the form’s OKCALL member using the comman d OKCALL ‘CallbackString’ . You 
can modify the Okcallback at any time using !this.Okcall = ‘CallbackString’ . 
 
The CANCELCALL callback is executed when a form’s C ANCEL button is pressed, when 
the CANCEL button of a form’s ancestor is pressed ( see section on Form Families) or when 
the window’s CLOSE gadget is used. It allows the op erator not to proceed with the functions 
of the form. The form is then removed from the scre en and all gadgets are automatically 
reset to the values they had when the form was disp layed or when any APPLY button was 
last pressed. Typically this callback allows you, t he PML programmer, to undo any actions 
already carried out on the form that ought to be un done in the light of the CANCEL request 
You can assign to the form’s CANCELCALL member usin g the command CANCELCALL 
‘CallbackString’ . 
 
You can modify the CANCELcallback at any time using  
 
!this.Cancelcall = ‘CallbackString 
15.3.4. Quit/Close Callback 
 All Forms have a QUITCALL member that you can pass  a standard callback string. This 
is executed whenever the user presses the Quit/Clos e icon (X) on the title bar of forms and 
the main application window. If an open callback is  used then it is called with the FORM 
object as its first parameter and ‘QUIT’ as its act ion string. QUITCALL for MAIN Forms For 
forms of type MAIN, the QUITCALL callback is execut ed, if present. This permits the user to 
terminate the application, and so the associated PM L callback should prompt the user for 
confirmation. If the user confirms the quit, then t he callback should close down the 
application, and not return. If the user decides no t to quit, then the callback should return an 
error to indicate the decision to F&M. 
 
 Use return error…noalert if you want to avoid disp laying an error alert. If the form has no 
QUIT callback, then the QUIT event will be ignored.  The following example shows a (global) 
PML function, that you could be use from all forms of type MAIN: 
 
define function !!quitMain( ) 
  -- Sharable method Quit the application 
  !str = !!Alert.Confirm('Are you sure you want to quit the application?') 
  if( !str eq 'YES' ) then 
    -- execute application termination command, whi ch should not return 
    finish 
  else 
    return error 3 |user chose not to QUIT| noalert  
  endif 
endfunction 
 
This would be called from the form definition funct ion body or from its constructor method as 
shown below: 
 
Setup form !!myApplication MAIN 
  quitCall ‘!!quitMain( )’ 
exit 
define method .myApplication( ) 
-- Constructor 
  !this.quitCall = ‘!!quitMain( )’ 
endmethod 
 

--- Page 85 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 85/178  Essentially, if no QUIT callback is present, then t he form is cancelled (hidden with reset of 
gadget values). If a QUIT callback is provided then  you can prevent the default Cancel 
action by returning a PML error, but you must hide the form from your callback method (It is 
more efficient the use ‘!this.hide()’, rather than ‘hide !!myform‘ from your form methods). 
 
Note:  F&M does not display an alert for the returned err or, it is merely for communication. 
You don’t need a QUIT callback if you just want to allow the form to be hidden. For 
DOCUMENT forms (MDI children) only, the callback must not display an alert as this will 
cause some gadgets to malfunction afterwards. 
15.3.5. FIRSTSHOWN callback 
Typically assigned in the Constructor by 
 
!this.FirstShownCall = '!this.<form_method>' 
 
 The purpose is to allow the user to carry out any form actions which can only be 
completed when the form is actually displayed. Ther e are a variety of circumstances where 
this arises and it is often difficult to find a rel iable solution. A couple of examples are given 
below. Commands which manipulate form, menu or gadg et visual properties, executed from 
a PML macro, function or callback may not happen un til control is returned to the window 
manager's event loop. For example, in the applicati on's start-up macro the command 
sequence show !!myForm … hide !!myform will result in the form not being displayed, but 
also not becoming known at all to the window manage r. Attempts to communicate with this 
form via the External callback mechanism (possibly from another process) will not work. 
 
This can be rectified by doing the '!this.hide()' w ithin the FIRSTSHOWN callback, because 
the form will be guaranteed to be actually displaye d (and hence known to the window 
manager), before it is hidden It is sometimes diffi cult to achieve the correct gadget 
background colour setting the first time the form i s displayed. This can be resolved by setting 
the required colour in the FIRSTSHOWN callback. 
15.3.6. KILLING callback 
Typically assigned in the Constructor by 
 
!this.KillingCall = '!this.<form_method>' 
 
The purpose is to notify the form that it is being destroyed and allow the assigned callback 
method to destroy any associated resources, e.g. gl obal PML objects which would otherwise 
not be destroyed. This may be necessary because PML  global objects will survive an 
application module switch, but may not be valid in the new module. 
 
Notes: 
1. The callback method MUST NOT carry out any modif ications to the Gadgets belonging to 
the form or to the Form itself (e.g. don't show or hide the form). Attempts to edit the form or 
its gadgets may cause unwanted side effects or poss ible system errors. 
2. Form callbacks designed for other Form events (e .g. CANCEL, INIT) are rarely suitable as 
killing callbacks. 
3. Restrict form and gadget operations to querying.  
15.3.7. Form Variables: PML Variables within a Form  
 It is often convenient to store additional informa tion on a form which will not be displayed 
to the user. This is achieved by defining form vari ables. These are variables which can be 
any of the PML data types, including ARRAYS and OBJ ECTS. These variables have the 
same lifetime as the form and are deleted when the form itself is killed. 
 

--- Page 86 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 86/178  Form members are defined in just the same way as ob ject members: 
 
setup form !!MyForm... 
  member .MyNumber is REAL 
  member .MyString is STRING 
  member .MyArray is ARRAY 
exit 
 
The value of a form member can be set and used in j ust the same way as an object 
member: 
 
!!MyForm.MyNumber = 42 
!Text = !This.MyNumber 
!ThirdValue = !This.MyArray[3] 
 
In a callback function you can use !this. to repres ent 'this form': 
 
!ThirdValue = !This.MyArray[3] 
15.3.8. Querying Form Members 
You can query the members of a form using the comma nd: 
 
q var !!formname 
 
This will list all the attributes of the form, and all the gadgets defined on it. This is a useful 
debugging aid. To query all the gadgets of a form ( excludes USERDATA gadget) use: 
 
!!gadgetsarray = !!MyForm.gadgets() 
 
Returns array of GADGET. 
15.4. Loading, Showing, and Hiding Forms 
15.4.1. Free Forms and Form Families 
 Forms are displayed on the screen either as free-s tanding forms or as a member of a 
form family. A form can be displayed as a free stan ding form, for example by show !!form 
free. It then has no parent so it will not disappea r when the form which caused it to be 
displayed is hidden. 
 
 When one form causes another form to be displayed,  such as when a button with the 
FORM keyword is pressed or a gadget callback execut es a show !!form command the result 
is a child form. A form can have many child forms ( and grand-children…) but a child form 
has only one parent - the form which caused the chi ld form to be displayed. The nest of 
related forms is called a Form Family. 
 
 The Form Family exists just as long as the forms a re displayed. If a form is already on the 
screen when it is shown, it is brought to the front  of the display. If the child form is already in 
a Form Family it is transferred to the new parent. If the user presses the OK button of a 
parent form, the system in effect presses the OK bu ttons on each of the child forms, 
'youngest' first, invoking their OKCALL callbacks. The parent form and all child-forms are 
hidden and the Form Family then ceases to exist. If  the user presses the CANCEL button or 
uses the window's CLOSE controls, the system in eff ect presses the CANCEL buttons of 
each of the child forms, 'youngest' first, invoking  their CANCELALL callbacks, and all the 
forms in the Form Family are hidden. The action of RESET and APPLY buttons does not 
affect family members. 

--- Page 87 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 87/178  15.4.2. Loading and Showing Forms 
 A form definition must be loaded before the form c an be displayed. If you have saved the 
definition in a .pmlfrm file then loading will be a utomatic when the form is displayed for the 
first time. Note: Earlier AppWare used form definit ions in macro files which had to be loaded 
explicitly via 
 
$m path-name. 
 
This mechanism still operates for backwards compati bility, but is strongly discouraged when 
writing new AppWare. Normally, a form is displayed as a result of the operator making a 
menu selection or pressing a button on a form. This  is achieved either by using the Form 
directive in the menu or button definition or by me ans of the command: 
 
show !!formname 
 
used in the gadget’s callback. In either case the f orm becomes a child of the menu’s or 
gadget’s owning form. A form may be displayed free- standing, i.e. not as a child, by: 
 
show !!formname free 
 
Sometimes it is useful to force the loading of a fo rm’s definition file before the form is actually 
displayed, so that you can edit the form or gadget attributes from another form’s callbacks 
before the form is actually displayed. Using the co mmand: 
 
loadform !!formname 
 
from a callback will force load the definition if t he form is unknown to PML, but do nothing if 
the form has already been loaded. If you are sure t hat a form’s definition has been loaded 
then you can show the form as a child or free-stand ing respectively using the form methods: 
 
!!formname.show( ) 
!!formname.show( ‘free’ ) 
 
but note that this will not dynamically load the fo rm definition. 
15.4.3. Position of Forms on the Screen 
 Mostly forms are automatically positioned by the s ystem according to their type and the 
way they are shown. The origin of a form is its top  left hand corner. When a form is displayed 
as a child form then it is always positioned with r espect to its parent. For a form shown from 
a MENU, its origin is at the origin of the parent. If the form is displayed from a BUTTON or 
any other gadget, its origin is at the centre of th e gadget. When a form is shown as a free 
form for the first time then its default position i s at the top left-hand corner of the screen. We 
strongly recommend that you allow the system to pos ition forms whenever 
possible. 
 
You can force the screen position of free-standing forms using the following commands or 
methods: 
 
show !!MyForm Free At xr 0.3 yr 0.5 
show !!MyForm Free Centred xr 0.5 yr 0.5 
!!MyForm.show( 'At', 0.3, 0.5 ) 
!!MyForm.show( 'Cen', 0.5, 0.5 ) 
 

--- Page 88 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 88/178  The At option puts the origin of the form at the sp ecified position; alternatively the Cen option 
puts the centre of the form at the given position. The co-ordinate values are fractions of the 
screen width or height respectively and are referre d to as screen co-ordinates. For example : 
 
show !!MyForm free At xr 0.25 yr 0.1 
 
positions the origin of !!MyForm one quarter of the way across from the left edge of  the 
screen, and one tenth of the way down from the top.  
 
!!MyForm.show( 'Cen', 0.5, 0.5 ) 
 
centres !!MyForm at the middle of the screen.  
15.4.4. Hiding Forms 
 The recommended way for a form to be removed from the screen is for the user to press 
a button with the OK or CANCEL attribute. Forms may  also be cancelled by using the 
window’s close controls. Both these mechanisms will  remove the form and any of its children 
executing their OK or CANCEL 
callbacks appropriately. 
 
 Sometimes it is required to hide a form and other forms which are functionally associated 
but not part of the form family or as a result of a  button press on a form you may want to hide 
other associated forms but not the form whose butto n was pressed. The hide command or 
method allows this: 
 
hide !!MyForm 
!!MyForm.hide() 
 
Note: When you explicitly hide a form in this way i ts gadgets will be reset to their values at 
display or at the last APPLY, just like a CANCEL ac tion, but the CANCELCALL callbacks for 
the form and its nest will not be applied. This mea ns that before youexecute the hide you 
should use any pertinent data  from the forms to be  hidden. 
15.4.5. Killing Forms 
You can destroy a loaded form definition using the command kill !!MyForm 
 
The form is hidden and then its definition is destr oyed so that it is then no longer known to 
PML. You cannot then access the form or its gadgets , members or methods (including its 
.show() method. Normally you will not need to inclu de the kill command within your 
AppWare. If you re-show the form using the show com mand then the system will attempt to 
demand load the definition again. This is slow and expensive if you haven’t modified the 
definition so avoid it: use loadform !!MyForm and ! !MyForm.show() instead. If you execute a 
setup form !!MyForm... while the form !!MyForm alre ady exists then it is killed and a new 
definition is started. This mechanism may be useful  because it makes it possible to generate 
a form definition interactively from within your Ap pWare. This can be very powerful but 
should be used with great care. 
15.4.6. NOQUIT Form Status 
 You can stop forms from being hidden from the bord er close/quit pull-down menu by 
setting the NOQUIT attribute: 
 
Setup form !!MyForm . . . NOQUIT 
 
By default, you can quit from any user-defined form , except for the current system Main 
form. 
  

--- Page 89 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 89/178  16. Menus 
 Menus are always members of forms but can be emplo yed in various ways by the form 
and its gadgets. Menus come in two types: main menu s and popup menus. You determine 
what type a menu is when you create it. If you do n ot specify the type, then the system will 
try to infer its type from the context of its first  use. 
 
For example, if the first action in a form definiti on is to define the menubar, then the 
system will infer any menus referenced in the bar…e xit sequence to be of type MAIN. Or, as 
a second example, if a menu is assigned as the popu p for the form or a gadget of the form, 
then the system will infer the menu to be of type P OPUP. 
16.1. Menu Types and Rules 
 Forms may have a bar menu gadget or main menu, whi ch appears as a row of options 
across the top of the form. When you select one of the menu options, a pull-down menu is 
temporarily displayed. Fields on a menu may have pu ll-right arrows (>) that open a pulldown 
sub-menu when selected. Forms and gadgets can have popup menus assigned to them. 
When you move the cursor onto them and press the mo use popup button, the menu pops-up 
at the cursor and you can then select from the disp layed options. The following rules 
determine how you can use menus: 
 
• Each menu belongs either to the Main menu system or to the Popup menu system, but 
cannot belong to both . 
• A menu in the Main system can appear only once. i. e. it cannot be a sub-menu of 
several menus. 
• A menu in the Popup system may appear only once in a given popup tree, but may be 
used in any number of popup trees. 
• A menu cannot reference itself , either directly as a pullright of one of its own fields or 
be a pullright of another menu in its own menu tree . 
• Any pullright field of a menu references a sub-men u that will be inferred to be of the 
same type as the referencing menu. 
16.2. Defining a Bar Menu Gadget 
 A bar menu is defined within a form definition. Th e menu bar is created with the bar 
subcommand. Note that its name is ‘bar’: there can be only one bar menu on a form. Then 
you can use the bar’s Add() method to add the optio ns. For example: 
 
setup form !!MyForm Dialog size 30 5 
bar 
!this.bar.add ( 'Choose', 'Menu1') 
!this.bar.add ( 'Window', ' ' ) 
!this.bar.add ( 'Help', ' ' ) 
exit 
 
This code specifies the text of three options label led Choose, Window, and Help. 
 
Picture Nr.7. - A Simple Menu  


--- Page 90 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 90/178  • The Choose option when picked will open Menu1 as a  pull-down 
• The Window and Help options will open the Window a nd Help system menus 
 
Note:  That Menu1 need not exist when the bar is defined,  it can be defined later in the form 
definition, but it must exist before the Choose opt ion is selected or an error alert will be 
raised. 
16.2.1. Defining a Menu Object 
 A menu is a set of menu fields, each representing an action that is invoked when the field 
is selected. The fields’ display text indicates to the user what the actions are, and the fields’ 
replacement text defines what the actions are. With in the form definition a menu object can 
be created using the form’s NewMenu method or the m enu sub-command. You can then use 
the menu’s Add(), InsertAfter(), and InsertBefore()  methods to add or insert named menu 
fields. A menu field can do one of three things: 
 
• Execute a callback. 
• Display a form. 
• Display a sub-menu. 
 
You can also add a visual separator between fields.  Below is an example of a complete 
menu definition: 
 
!menu = !this.newmenu( 'file', ‘main’ ) 
!menu.add( 'MENU', 'Send to', 'SendList', 'SendTo' ) 
!menu.add( 'SEPARATOR', 'saveGroup' ) 
!menu.add( 'CALLBACK', 'Save', '!this.SaveFile()', 'Save' ) 
!menu.add( 'FORM', 'Save as...', 'SaveFile', 'SaveA s' ) 
!menu.add( 'SEPARATOR' ) 
--core-code managed field for Explorer Addin, ticke d. 
--Note no Rtext needed 
!menu.add( 'CORETOGGLE', 'Explorer', '', 'Expl' ) 
!menu.add( 'MENU', 'Pull-right1', 'Pull1') 
--initialise toggle field as ticked (typically in t he 
constructor) 
!menu.SetField( 'Expl', 'Selected', true ) 
 
This creates a new main menu called Menu with six f ields and two separators between 
them. For example: 
 
• The SAVE field when picked will execute the callba ck command this.SaveFile(). 
• The Save as... field when picked will load and dis play the form !!SaveFile. By 
convention, the text on a menu field leading to a f orm ends with three dots, which 
you must include with the text displayed for the fi eld. 
• The SEPARATOR, usually a line, will appear after t he previous field. 
• The Pull-right1 field when picked will display the  sub-menu !this.Pull1 to its right. A 
• menu field leading to a sub-menu ends with a > sym bol: this is added automatically. 
• Named Menu Fields 
 
You can add menu fields with an optional fieldname that you can later refer to when editing 
the menufield or modifying its attributes’. If you do not specify a field name then you will not 
be able to refer to the field again. You can also a ssign a name to separator fields, which 
allows separator group editing. The general syntax is: 
 
!menu.Add( ‘<FieldType>’,’ <Dtext>’, ‘<Rtext>’, { ‘ <FieldName>’ } ) 
!menu.Add( ‘SEPARATOR’, { ‘<FieldName>’ })  

--- Page 91 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 91/178  Where the fields have the following meanings: 
 
<FieldType>  has allowable values: ‘CALLBACK’, ‘TOGGLE’, ‘MENU’ , and ‘FORM’. 
<Dtext>  is the display-text for the field (cannot be null or blank). May contain multi-byte 
characters. 
<Rtext>  is the replacement-text for the field. A null stri ng indicates no replacement-text. The 
allowable values for RTEXT for the different field types are: 
 
• CALLBACK’ - callback string 
• TOGGLE’ - callback string 
• MENU’ - menu name string (without preceding ‘.’). 
• It cannot be blank. 
• FORM’ - form name string (without preceding ‘!!’).  It 
• cannot be blank. 
 
<FieldName>  is an optional argument, which, if present, is the  
unique field name within the menu. 
16.2.2. Window Menu 
You can add the system Window menu to a bar menu using: 
 
!this.bar.add (‘<Dtext>’, ‘window’) 
 
This menu is dynamically created on use with a list  of the titles of the windows currently 
displayed as its fields. Selecting a field will pop  that window to the front. This can be very 
useful on a cluttered screen. 
16.2.3. Online Help Menu 
You can add the system Help menu with the specified  display text to a bar menu using 
 
!this.bar.add (‘Dtext’, ‘Help') 
!this.bar.InsertAfter(‘window’, ‘<Dtext>’, ‘Help’) 
 
When selected, this Help option displays a system-h elp pull-down menu that gives Access to 
the application help system. The fields are: 
 
Contents  This displays the Help window so that you can find  the required topic from the 
hierarchical contents list. 
Index  This displays the Help window with the Index tab s elected, so that you can browse for 
the topic you want to read about from the alphabeti cally-arranged list. You can locate topics 
quickly by typing in the first few letters of their  title. 
Search  This displays the Help window with the Search tab at the front so that you can find 
all topics containing the keywords you specify. 
About  To see the product version information. 
 
You can access On Window help by pressing the F1 ke y while the form has keyboard focus, 
or by including a Help button in the form’s definit ion. 
 
Note:  By convention, the help menu should be the last on e defined for the menu bar, which 
will ensure that it appears at the right-hand end o f the menu bar. 
16.2.4. Popup Menus 
 You can use any of your defined menus as popup men us for most interactive gadgets 
and for the form background as long as you have spe cified them as belonging to the popup 
menu system. When the cursor is moved over it with the popup mouse button pressed down, 

--- Page 92 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 92/178  and then released, the menu will be displayed, and you can select from it in the normal way. 
A popup is added to a gadget or form using its Setp opup() method, with the popup menu as 
the argument to the method. Note that the menu pop1  must exist when the Setpopup() 
method is executed. For example: 
 
setup form !!MyForm resizable 
  menu .pop1 popup 
  !this.pop1.add( 'MENU', 'Options', 'optionmenu' )  
  !this.pop1.add( 'MENU', 'More', 'moremenu' ) 
  !this.pop1.add( 'MENU', 'Last', 'Lastmenu' 
  button .b1 ... 
  !this.b1.setpopup( !this.pop1 ) 
exit 
16.2.5. Finding Who Popped up a Menu 
 You can find out whether a menu was popped up from  a gadget, and if so, the gadget’s 
name. The method is: 
 
!menu.popupGadget() is GADGET 
 
If the menu was a popup on a gadget then the return ed GADGET variable is a reference to 
the gadget. If the menu was popped up from a pulldo wn-menu or from a popup on the form 
itself, the value is UNSET. Example: 
 
!g = !menu.popupGadget() 
if !g.set() then 
  !n = !g.name() 
  $p menu popped up by gadget $!n 
else 
  !n = menu.owner().name() 
  $p menu popped up by form $!n 
endif 
16.2.6. Toggle Menus 
 A menu TOGGLE field is a menu field with a callbac k action and a tick-box to show that 
the field has been selected or unselected. By defau lt the field will be unselected so the box 
will not be ticked. When picked the fields callback  action will be executed and the tick-box 
ticked. If you pick the field again the callback ac tion will again be executed and the tick 
removed. Note that the open callback is an obvious candidate for toggle menus as the 
SELECT or UNSELECT action is returned as the second  argument to the callback method. 
For example, in your form definition you can add a toggle field as follows: 
 
setup form !!Myform Dialog size 30 5 
  !menu = !this.newmenu(‘Test’, ‘popup’) 
  !menu.add( 'Toggle' ,’Active/Inactive’, '!this.to ggle(‘,'OnOff' ) 
Exit 
 
define method .toggle( !menu IS MENU, !action IS ST RING ) 
  !name = !menu.fullname() 
  !field = !menu.PickedFieldName 
  $P menu $!name $!action field: $!field 
Endmethod 
 
Note: How we use the PickedFieldName member of the menu object to obtain the last 
picked field. If you pick this menu field the callb ack method will print: 
 
menu !!MyForm.Menu1 SELECT field: OnOff  

--- Page 93 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 93/178  16.3. Editing Bars and Menus 
 The contents of menu bars and menus can be modifie d at any time using the members 
and methods of the bar menu gadget object and the m enu object. 
16.3.1. Inserting Menus into a Bar 
 You can insert new fields into a menu bar using th e InsertBefore() and InsertAfter() 
methods, which insert the new fields relative to ex isting named menus. The methods use 
named menus to determine the point where they shoul d insert the new menu. The general 
syntax is: 
 
InsertBefore(<TargetMenuName>, <Dtext>, <MenuName>)  
InsertAfter(<TargetMenuName>, <Dtext>, <MenuName>) 
 
Where the fields have the following meanings: 
 
<TargetMenuName>  is the name of the menu immediately before or afte r where you want 
the new menu to go. 
<Dtext>  is the display-text for the menu. 
<FieldName>  is the unique name for the menu within the bar. 
 
For example: 
 
setup form !!MyForm Dialog size 30 5 
  bar 
  -- adds a pulldown for menu1 labelled with <dtext > 
  !this.bar.Add( ‘<dtext>’, ‘menu1’ ) 
  -- adds a window pulldown labelled with <dtext> 
  !this.bar.Add( ‘<dtext>’, ‘Window’ ) 
  -- adds a help pulldown labelled with <dtext> 
  !bar.InsertAfter( ‘Window’, ‘<dtext>’, ‘Help’ ) 
Exit 
 
 If you use the identifier ‘Window’ or ‘Help’ as th e name of the menu, the system will 
interpret them as system Window and Help menus, alt hough they will still be displayed with 
the string given in <dtext>. Named menus and the me thods that create them are discussed 
in more detail in the rest of this section. 
16.3.2. Inserting New Menu Fields 
You can insert new fields into a menu using the Ins ertBefore() and InsertAfter() methods, 
which insert the new fields relative to existing na med menu fields. The methods use named 
menu fields to determine the point where they shoul d insert the new field. The general 
syntax is: 
 
InsertBefore(<TargetFieldName>,<FieldType>,<Dtext>, <Rtext >,{<FieldName>}) 
InsertBefore(‘SEPARATOR’,{<FieldName>}) 
InsertAfter(<TargetFieldName>,<FieldType>,<Dtext>,< Rtext> ,{<FieldName>}) 
InsertAfter(‘SEPARATOR’,{<FieldName>}) 
 
Where the fields have the following meanings: 
 
<TargetFieldName>  is the name of the field immediately before or aft er where you want the 
new field to go. 
<FieldType>  has allowable values: ‘CALLBACK’, ‘TOGGLE’, ‘MENU’ , and ‘FORM’. 
<Dtext>  is the display-text for the field (cannot be null or blank). May contain multi-byte 
characters. 

--- Page 94 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 94/178  <Rtext>  is the replacement-text for the field. A null stri ng indicates no replacement-text. The 
allowable values for RTEXT for the different field types are: 
 
• CALLBACK’ - callback string 
• TOGGLE’ - callback string 
• MENU’ - menu name string (without preceding ‘.’). It cann ot be blank. 
• FORM’ - form name string (without preceding ‘!!’). It can not be blank. 
 
<FieldName>  is an optional argument, which, if present, is the  unique field name within the 
menu. 
16.3.3. Changing the State of Menufields 
 There are two methods you can use to set and read the status of menu- and menu-field 
properties. Setting Menu-Options’ Status You can de -activate a menufield on a menu bar 
and a field in a menu with the SetFieldProperty() s o that it cannot be selected. Similarly, you 
can make them invisible so the user cannot see them . You can also use SetFieldProperty() 
to hide a menu field and to select or unselect togg le-type fields. The general syntax is: 
 
!menu.SetFieldProperty (<FieldName>, <PropertyName> , Boolean) 
 
Where the fields have the following meanings: 
 
<FieldName>  The name of the field you want to change. 
<PropertyName>  The name of the property you want to change in the  named field. The 
allowed values are: 
 
• ACTIVE’ - greyed in or out 
• VISIBLE’ - visible or invisible 
• SELECTED’ - selected or unselected (toggle type fi elds, only. Specifically, this value 
cannot be used with bars). 
 
Boolean  The value, TRUE or FALSE, for the property. 
 
Note:  The property names may optionally be truncated to the first three characters ‘ACT’, 
‘VIS’, and ‘SEL’. For example: 
 
!bar = !!MyForm.bar 
!menu = !!MyForm.Menu1 
 
sets local variables !bar and !menu to be reference s to the bar gadget and Menu1 of form 
!!MyForm. 
 
Then 
 
!bar.SetFieldProperty( 'Foo', ‘ACTive’, false) 
 
will grey-out the menufield on bar that has the fie ld-name “Foo”. And 
 
!menu.SetFieldProperty ( 'Bar', ‘ACTive’, true) 
 
will activate the menufield on Menu1 that has the f ield-name “Bar”. 
 
You can use the same method to change the selected status of a toggle menu field. 
  

--- Page 95 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 95/178  Reading the Status of Menus and Menus’ Fields 
To read the status of a menu or of a menu-field pro perty, you can use the FieldProperty() 
method. The general syntax is: 
 
Boolean = !menu.FieldProperty (<FieldName>, <Proper tyName>) 
 
Where the fields have the following meanings: 
 
<FieldName>  is the name of the field you want to change. 
<PropertyName>  is the name of the property you want to change in the named field. The 
allowed values are: 
 
• ‘ACTIVE’ - greyed in or out 
• VISIBLE’ - visible or invisible 
• ‘SELECTED’ - selected or unselected (toggle type f ields, only. Specifically, this value 
cannot be used with bars) 
 
Note:  The property names may optionally be truncated to the first three characters ‘ACT’, 
‘VIS’, and ‘SEL’. 
 
For example: 
 
!bar = !!MyForm.bar 
 
sets local variable !bar to be a reference to the b ar gadget of form !!MyForm. 
 
Then 
 
!isSet = !bar.FieldProperty( 'Foo', ‘ACT’) 
 
will get the greyed-out status of the menufield on bar that has the field-name “Foo”. You can 
use the same method to change the selected status o f a toggle menu field. 
16.3.4. Implied Menu-field Groups 
 A separator field and all following fields up to b ut not including the next separator field 
implies a menu-field group. You can modify the ACTI VE and VISIBLE properties of all fields 
in the group, by reference to its separator name. F or example, for the menu: 
 
!menu = !this.newmenu( 'file', 'Main' ) 
!menu.add( 'MENU', 'Send to', 'SendList', 'SendTo' ) 
!menu.add( 'SEPARATOR', 'SaveGroup' ) 
!menu.add( 'CALLBACK', 'Save', '!this.SaveFile()',' Save' ) 
menu.add( 'FORM', 'Save as...', 'SaveFile', 'SaveAs ' ) 
!menu.add( 'SEPARATOR', 'explGroup' ) 
!menu.add( 'FORM', 'Explorer...', 'ExplFile', 'Expl ' ) 
 
<FieldName>  is the name of the field you want to change. 
<PropertyName>  is the name of the property you want to change in the named field. The 
allowed values are: 
 
• ACTIVE’ - greyed in or out 
• VISIBLE’ - visible or invisible 
• SELECTED’ - selected or unselected (toggle type fi elds, only. Specifically, this value 
cannot be used with bars) 
  

--- Page 96 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 96/178  Executing the method 
 
!menu.SetField( 'saveGroup', 'visible', false ) 
 
will make the all the fields invisible for the grou p currently implied by the separator field 
‘SaveGroup’, i.e. the fields SaveGroup, Save and Sa veAs. 
 
The combination of named SEPARATOR fields, insertio n and field group visibility will be 
useful for managing the sharing of menus between co -operating sub-applications. This 
facility should be used with great care. 
16.3.5. Creating Menus Dynamically 
 You can create new menus from within your appware dynamically using the form method 
NewMenu(). For example, you could equip your form w ith the methods popupCreate() and 
popupAction() which would allow you create and serv ice a popup menu from an array of 
strings. Executing !this.popupCreate(‘NewPopup’, !f ieldArray) will create a new popup menu 
and assign it to the form. 
 
define method .popupCreate( !name is STRING, !field s is ARRAY ) 
  --!fields is an array of field name strings 
  !menu = !this.newmenu( !name, ‘popup’ ) 
  --add all the fields with same open callback 
  do !n from 1 to !fields.size() 
    !menu.add( 'Callback', !fields[!n], '!this.menu Action(' ) 
  enddo 
  -- assign the new menu as the form’s popup menu 
  !this.setpopup( !menu ) 
endmethod 
 
define method .popupAction( !menu is MENU, !action is STRING ) 
  -- General popup menu action routine 
  if ( !action eq ‘SELECT’ ) then 
    !name = !menu.fullname() 
    !field = !menu.pickedField 
    -- execute application actions according to the  field selected 
    $P selected field $!field of menu $!name 
  else 
    -- execute applications for unselected field (t oggle) 
  endif 
endmethod 
  

--- Page 97 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 97/178  17. Form layout 
The Form Layout section explains how to lay gadgets  out on a form. 
17.1. System Font and Unicode characters 
 F&M supports a system font which provides the character representations used w ithin 
any forms, gadgets and menus which you define. This  system font has variable width 
characters (referred to as VarChars ), so different characters may have different width s. 
A notional character width for the font is also supported. This is a sort of a verage width 
(usually the width of upper-case X), and provides a  rough guide to the width of a text string 
as (number of characters X notional width). The rec ommended system font also supports 
many of the World's character sets, so forms can be  designed to use non-English 
characters, and even to mix different languages on the same form. In order to achieve this 
PML and F&M now use the Unicode standard as their internal character format. 
17.2. Layout Modes 
 Two layout modes are supported, namely VarChars an d FixChars. VarChars is a new 
layout mode, based on measuring precise string widt hs. It is better suited to the use of 
variably spaced fonts, and removes the need for mos t uses of the TagWidth specifier. The 
benefits of using VarChars are: 
 
• It tends to produce smaller, more pleasing forms, without unwanted space. 
• No text wrap-around, except possibly in conjunctio n with TagWidth. 
• No truncation of explicitly defined text except po ssibly in conjunction with TagWidth. 
 
The recommended layout mode for all new forms is: 
 
setup form !!formname . . . VarChars 
 
 FixChars is the old layout mode (prior to PDMS12.1 ), which is based on the use of 
notional character width to calculate the (approx.)  sizes of textual gadgets and gadget tags. 
Because the calculated sizes are only approximate t he user has to make frequent use of the 
gadget's Width specifier and TagWidth specifier and  considerable trial and error to achieve a 
desired layout. The default layout mode for setup f orm is FixChars, because this will be the 
least disruptive for existing user Appware, so FixC hars mode will currently result from either 
of 
 
setup form !!formname . . . 
setup form !!formname . . . FixChars 
 
See the FMSYS object method 
 
!!FMSYS.SetDefaultFormLayout(layout is STRING) 
 
that allows users to change the default layout mode  for Setup form. This can be used to help 
test any existing appware which is using setup form  !!formname . . ., in either mode to 
determine which forms need layout adjustment. 
 
Future Change to VarChars as Default Layout Mode 
The intention is to change the recommended layout m ode to be VarChars at a subsequent 
PDMS release. It is probable that this will be achi eved by introducing the alternative, 
optional, form definition Syntax 
Layout form !!<form_name> . . . exit 
This will ensure VarChars mode (and NoAlign) by def ault.  

--- Page 98 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 98/178  17.3. Containers, Grid Co-ordinates and Gadget Boxe s 
 The Form and its Frame gadgets act as containers for holding gadgets. Typically 
gadgets are laid out in their containers from left to right and from top to bottom. Each 
container has a rectangular co-ordinate grid with origin (0, 0) at the top at the top left-hand 
corner. Each gadget has an origin at its top left-hand corner and a width and height , which 
together define a notional gadget box , which contains the gadget including its tag-text if 
defined. Layout involves positioning each gadget, b y its origin, at a specified position within 
the grid of its container and indicating its width and height. 
 
• The grid horizontal pitch is the notional characte r width for the system font. Because 
this font is variably spaced, n horizontal grid units do not equate to n characters. 
Generally, it is more than n unless the string has a high proportion of wide 
characters e.g. capitals, numerals, w's, m's etc. I t is important that you understand 
this concept when you specify gadget sizes. 
• The grid vertical pitch is the line-height , which is the height of the tallest of the textual  
gadgets: TOGGLE, BUTTON, OPTION, TEXT or single-lin e PARAGRAPH. 
 
Picture Nr.8. - Conceptual X and Y Coordinates 
For the Form container its extremities are referred to as XMIN form , YMIN form , XMAX 
form and YMAX form . 
 
The extremities of a gadget box are referred to as XMIN.gadget , YMIN.gadget , 
XMAX.gadget an YMAX.gadget . 
 
Picture Nr.9. - Gadget Box Extremeties 
When new gadgets are added to a container, the XMAX and YMAX extremities grow to 
include the gadget boxes. 
  


--- Page 99 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 99/178  17.4. Positioning, Alignment and Size of Gadgets 
 We strongly recommend that you lay out your form u sing auto-placement in combination 
with relative placement and use the NoAlign keyword. 
 
Note: This is vital because it allows gadgets to be added , removed, and repositioned, 
without having to adjust the geometry of all the ot her gadgets on the form. 
 
Auto-placement chooses a gadget's position coordinate automaticall y relative to the last 
placed gadget. 
Relative placement uses the AT syntax to specify a gadget's position c oordinate relative to 
a previously placed gadget. 
NoAlign switches off the default approximate centre-alignme nt of the gadgets TEXT, 
OPTION, COMBO, TOGGLE and single line PARAGRAPH for  path right and path left, which 
interferes with Auto-placement. 
 
A gadget's size component , width or height, is either a literal value, or a previous gadget's 
size component, or an extension to a previous gadge t's co-ordinate limit, i.e. min or max. 
The last option, referred to as sizing to Positional Extent , uses the width to… and height 
to… syntax. This makes it much simpler to lay out compl ex and resizable forms. 
 
The following example form demonstrates layout of a  simple, fixed size dialog form using the 
VarChars layout mode. Each gadget's position is set within t he gadget definition either, 
implicitly using auto-placement , or using the AT syntax. Gadget sizes are set implicitly, or 
relative to the size of other gadgets or to the pos itional extents of other gadgets. 
 
Picture Nr.10. - Form definition using the VarChars layout mode 
Note:  No actual co-ordinate positions are required to sp ecify this form. It is mostly 
undesirable and unnecessary to specify a gadget's p osition as absolute grid coordinates, 
e.g. at x 12, y 5; we recommend defining the layout  of each gadget relative to a predecessor. 
This allows simple editing of the layout, without h aving to calculate new positions. There are 
exceptions, for example, for the first gadget in a form or frame, where you may want to 
establish an initial x or y co-ordinate that is not  at the default position. 
 
Here is the corresponding PML code for the form: us ingVarChars.pmlfrm. The 'layout' 
keywords are emboldened and explained later in the chapter. 
  


--- Page 100 ---
AVEVA PDMS Programmable Macro Language manual 
  2016 v.1. Page 100/178  setup form !!usingVarChars dialog Varchars NoAlign 
  $*-- layout form !!usingVarChars dialog 
  title |Form !!usingVarChars| 
  path down 
  paragraph .para1 text 'Simple form layout using V arChars' 
  frame .frame1 |frame1: See my gadgets| 
    paragraph .para2 text 'text positioned implicit ly in frame1' 
    frame .frame2 |frame2: path right| 
      toggle .tog1 |BBC news 24| 
      path right 
      toggle .tog2 |BBC 1| 
      toggle .tog3 |BBC 2| 
      path down 
      vdist 0 
      frame .frame3 |frame3: path down, vdist 0| at  xmin.frame2 width to max.frame2 
        -- path down, vdist 0 gives minimum vertica l spacing 
        rtoggle .rad1 |ClassicFM| at xcen.frame3 - 0.5 * size 
        rtoggle .rad2 |Caroline| 
        rtoggle .rad3 |BBC Radio 2| 
      exit 
    exit 
  exit 
  button .cancel |CANCEL| at xmin form CANCEL 
  path right 
  button .ok |OK| at xmax form-size OK 
exit 
17.5. Auto-placement 
 Auto-placement uses the PATH , DISTANCE and ALIGNMENT commands, which have 
the following meanings: 
 
• PATH The direction in which the next gadget origin will be placed relative to the 
previous gadget. 
• DISTANCE The distance increment between gadgets along the cu rrent path. 
• ALIGNMENT Specifies how the next gadget aligns to the previou s one for the current 
path. 
Relative placement means specifying the new gadget position by reference to the 
extremities of a previously defined gadget. It is a lso possible to position gadgets using 
explicit form coordinates, but this is rarely neces sary. 
17.5.1. Positioning Gadgets on a Defined Path 
 The path along which gadgets are to be added, is s et using a PATH attribute: Usually 
PATH right or PATH up, occasionally PATH left or PA TH down. The default direction is 
PATH right. The current path direction is set until  you give a different PATH command. 
17.5.2. Setting the Auto-displacement between Gadge ts 
 To specify the horizontal and vertical displacemen t between adjacent gadgets, use the 
HDISTANCE and VDISTANCE keywords, respectively. The  default displacements are 
HDIST 0.2 grid units, VDIST 1.0 grid units. Note th at these specify clearance distances 
between gadgets (for example, the distance between the XMAX of one gadget and the XMIN 
of the next), not the distance between gadget origi ns, thus: 
 
Picture Nr.11. - Distances Between Gadgets  
