--- Page 1 ---
Software
Customisation Guide

--- Page 2 ---
PML Disclaimer
1.1 AVEVA does not warrant that the use of the AVEVA software will be uninterrupt ed, error-free or free from
viruses. 
1.2 AVEVA shall not be liable for: loss of profits; loss of business; depletion of goodwill and/or similar losses; loss of
anticipated savings; loss of goods; lo ss of contract; loss of us e; loss or corruption of  data or information; any
special, indirect, consequential or pure economic lo ss, costs, damages, charges or expenses which may be
suffered by the user, including any loss suffered by the user  resulting from the inaccura cy or invalidity of any data
created by the AVEVA software, irrespective of whether such  losses are suffered directly or indirectly, or arise in
contract, tort (including negligence) or otherwise.
1.3 AVEVA shall have no liability in contract, tort (includi ng negligence), or otherwise, ar ising in connection with the
performance of the AVEVA software where the faulty perf ormance of the AVEVA software results from a user's
modification of the AVEVA software. User's rights to modi fy the AVEVA software are strictly limited to those set out
in the Customisation Manual. 
1.4 AVEVA shall not be liable for any breach or infringement  of a third party's intellectual property rights where such
breach results from a user's modification of the AVEVA software or associated documentation.
1.5 AVEVA's total liability in contract, tort (including negligence), or otherwise, ar ising in connection with the
performance of the AVEVA software shall be limited to 100% of the licence fees paid in the year in which the user's
claim is brought. 
1.6 Clauses 1.1 to 1.5 shall apply to the fullest extent permissible at law.
1.7. In the event of any conflict between the above cl auses and the analogous clauses in the software licence
under which the AVEVA software was purchased, the clau ses in the software licence shall take precedence.
PML Copyright
Copyright and all other intellectual property rights in this  manual and the associated software, and every part of it
(including source code, object code, any data contained in it, the manual and any other documentation supplied
with it) belongs to, or is validly licensed by, AVEVA Solutions Limited or its subsidiaries. 
All rights are reserved to AVEVA Solutions Limited and its subsidiaries. The information contained in this document
is commercially sensitive, and shall not be copied, reproduced, stored in a retr ieval system, or transmitted without
the prior written permission of AVEVA Solutions Limited. Where such permission is granted, it expressly requires
that this copyright notice, and the abov e disclaimer, is prominently displayed at the beginning of every copy that is
made.
The manual and associated documentation may not be ada pted, reproduced, or copied, in any material or
electronic form, without the prior written permission of AVEVA Solutions Limited. Subject to the user's rights, as set
out in the customisation manuals to amend PML software files contained in the PDMS UI and PMLLIB folders and
any configuration files, the user may not reverse engineer, decompile, copy, or adapt the software. Neither the
whole, nor part of the software described in this public ation may be incorporated in to any third-party software,
product, machine, or system without th e prior written permission of AVEVA Solu tions Limited, save  as permitted by
law. Any such unauthorised action is strictly prohibited, an d may give rise to civil liabilities and criminal prosecution.
The AVEVA software described in this guide is to be inst alled and operated strictly in accordance with the terms
and conditions of the respective software licences, and in accordance with the relevant User Documentation.
Unauthorised or unlicensed use of th e software is strictly prohibited.
© Copyright 1974 to current year. AVEVA Solutions Limited and its subsidiaries. All rights reserved. AVEVA shall
not be liable for any breach or infringement of a third party's intellectual property rights where such breach results
from a user's modification of the AVEVA software or associated documentation.
AVEVA Solutions Limited, High Cross, Mading ley Road, Cambridge, CB3 0HB, United Kingdom.
PML Trademark
AVEVA and Tribon are registered trademarks of AVEVA Solu tions Limited or its subsidiaries. Unauthorised use of
the AVEVA or Tribon trademarks is strictly forbidden.
AVEVA product/software names are trademarks or regist ered trademarks of AVEVA Solutions Limited or its
subsidiaries, registered in the UK, Eu rope and other countries (worldwide).
The copyright, trademark rights, or ot her intellectual property rights in any other product or software, its name or
logo belongs to its respective owner .AVEVA Solutions Limited 

--- Page 3 ---
Revision Sheet
Date Version Comments / Remarks
September 2011 12.1.1 Issued
January 2012 Copyright added to all pages.
Setting bearing on volume views added.Forms layout improvements and enhancements.Software Customisation Guide 

--- Page 4 ---
Software Customisation Guide 

--- Page 5 ---
 Software Customisation Guide
Contents Page
12 Series i Software Customisation Guide
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Customisation Guide
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1:1
PMLs Character Format. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1:1
Customising a Graphical User  Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1:1
Serious Warning About Software Cu stomisation . . . . . . . . . . . . . . . . . . . . . . . . 1:2
How to Use this Manual. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1:2
Hints on the Trying the Examples  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1:2
Minimising Problems for Futur e Upgrades . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1:3
Current PML2 Naming Convention. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1:3
Note for Users Familiar with OO Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1:5
Variables, Objects, Functi ons and Methods. . . . . . . . . . . . . . . . . . . 2:1
PML Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:1
Object Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:1
Members and Attributes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:2
User-defined Object Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:2
Storing Object Type Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:3
Creating Variables (Objects) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:3
Local and Global Variable Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:3
Notes on Naming Conventions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:4
Creating a Variable with a Built-in Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:4
Creating Other Types of Variable. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:5Using the Member Values of an Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:5

--- Page 6 ---
12 Series ii Software Customisation Guide
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.PML Functions and Methods  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:6
Storing and Loading PML Functions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:7
PML Procedures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . 2:7
Arguments of type ANY. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:8
Using the Methods of an Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:9
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:10
Methods on User-Defined Object Ty pes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:11
Method Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 :12
Constructor Methods with Arguments  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:12Overloading with ANY  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2: 12
Invoking a Method from Another Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:12
Developing a PML Object with Methods  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:13
Unset Variable Representations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:13
UNSET Values and UNDEFINED Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:13
Deleting PML Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:14
Forms as Global Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:14
General Features of PML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:1
Functions, Macros and Object Defini tions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:1
Comments in PML Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3: 1
Leaving a PML File with the RETURN Command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:2
Case Independence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:2
Abbreviations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:2
Special Character $ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:2
Text Delimiters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:3
Filename Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:3
Storing and Loading PML Files  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:4
Rebuilding All PML File Indexes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:4
Querying the Location of PML Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:4
PML Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4:1
Format of Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4:1
Operator Precedence. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4:2
Boolean Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4:2
Concatenation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4:3
Nesting Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4:3

--- Page 7 ---
12 Series Software Customisation Guide
iii © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Units in Real Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4:3
PML 1 and PML 2 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4:3
PML 2 Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4:3
Control Logic. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:1
IF Construct  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:1
Nesting if-constructs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:2
BOOLEAN Expressions and if Statements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:2IF TRUE Expression. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5:4
DO Loops  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:4
Stopping a DO loop: break and breakif  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:5
Skipping Commands in a DO Loop using Skip or Skip if . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:6
Nested DO Loops. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:6
Jumping to a Labelled Line. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:7
Conditional Jumping to a Labelled Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:7
Illegal Jumping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:7
Arrays  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:1
Creating Array Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:1
Arrays of Arrays (Multi-dimensional Arrays). . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:2
Array Methods  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:2
Appending a New Element to an Existing Array. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:3
Deleting an Array Element . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6: 3
Deleting an Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . 6:3
Splitting a Text String into Array Elements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:3
Length of String Array Elements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:4
Sorting Arrays Using Array Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:4
Sorting Arrays using the VAR Command  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:6
Subtotalling Arrays with the VAR Command  . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:9
Arrays of Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:10
DO Values with Arrays of Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:10
Block Evaluation And Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:11Using Block Evaluate to Sort an Array of Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:11
DO VALUES and DO INDICES with Arrays. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:12
Macros  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7:1
PML Macros  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7:1
Naming and Running Macros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7:1

--- Page 8 ---
12 Series iv Software Customisation Guide
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Macros with Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 :1
Using Macros and Functions Together . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7:3
Synonyms in PML Macros and Functi ons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7:4
Using PML in AVEVA Products . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8:1
Composing Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8:1
Defining Variables for Late  Evaluation (Rules) . . . . . . . . . . . . . . . . . . . . . . . . . . 8:2
Using PML in PDMS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8:2
Accessing DB Elements As Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8:2
Assigning Values to Element Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8:3Accessing Information About a Session. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8:4
Evaluating Selected DB Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8:4
RAW keyword When setting Variables with VAR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8:5Undo and Redo  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . 8:5
Copies and References (for Advanced Us ers) . . . . . . . . . . . . . . . . . 9:1
Assignment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9:1
Form and Gadget References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9:1
DB References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9:1
Deep Copy involving References: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9:2
Function Arguments  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9:2
Constants as Function Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9:2
Form and Gadget Properties Passed as Function Arguments. . . . . . . . . . . . . . . . . . . . . . . 9:3
Database Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9:3
Errors and Error Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10:1
Error Conditions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10:1
Handling Errors  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10:1
Setting the ONERROR Behaviour. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10:2
Other Responses to an Error  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10:3
Handling Files and Direct ories. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11:1
Creating a File Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11:1
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11:1
Reading from Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11:2
Writing to Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11:2
Reading and Writing ARRAYS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11:2

--- Page 9 ---
12 Series Software Customisation Guide
v © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Error Handling When Using a File Ob ject . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11:3
Developing PML Code  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:1
Using Unicode Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:1
Textual File Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12:1
File Transcoding Utility. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12:3
Using Unicode as the new PDMS Internal Format. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:3
PML Tracing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:3
Diagnostic Messages From Within PM L Files. . . . . . . . . . . . . . . . . . . . . . . . . . 12:4
Alpha Log . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:4
Alpha Log and PML Tracing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:4
Suspending a Running PML Macr o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:4
Querying PML. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:5
Querying the Currently Running PML File Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:5
Querying the Values of PML Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:5
Querying What Can Be Typed Next. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12:5
Form Concepts: Getting Started  . . . . . . . . . . . . . . . . . . . . . . . . . . . 13:1
Overview  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13:1
Naming Forms and their Members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13:2
Simple Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13:2
Adding a Gadget Callback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13:3
Form Definition File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13:4
How Forms are Loaded and Displayed  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13:4
PML Directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13:5
Revisiting our Simple Form  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13:6
Form and Gadget Callbacks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:1
Callbacks: Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:1
Callbacks: Form Methods / PML Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:1
PML Open Callbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:3
Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14:3
Open Callbacks at Meta-events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:3
Using a PML Function in an Open Callback. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:5
Objects That Can Have Open Callbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:6
Undo/Redo Support for Callbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:6
Form Callbacks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:8

--- Page 10 ---
12 Series vi Software Customisation Guide
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Gadget Callbacks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14:9
Menu and Menufield Callbacks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:9
Core Managed Objects  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14:9
Forms  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:1
Modules and Applicat ions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:1
Application Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:1
Current Document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:2
Defining a Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:2
Form Attributes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:3
Form Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:3
Layout Modes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . 15:4
Minimum Size and Resizability. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:4Intelligent Resizable Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15: 5
Gadget Alignment Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:5
Form Members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:5
Form Title and Icon Title. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:5
Form Initialisation Callback  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 :6
Form OK and CANCEL Callbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:6
Quit/Close Callback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15:7
FIRSTSHOWN callback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:8KILLING callback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:9
Form Variables: PML Variables within a Form. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:9
Querying Form Members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:10
Loading, Showing, and Hiding Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:10
Free Forms and Form Families . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:10
Loading and Showing Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:10
Position of Forms on the Screen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:11
Hiding Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:12
Killing Forms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:12
NOQUIT Form Status. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:12
CORE Managed Forms  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15:13
Menus  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:1
Menu Types and Rules  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:1
Hints and Tips for Using Menu Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:1
Core-Code Based Menus. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:2
Defining a Bar Menu Gadget . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:2
Defining a Menu Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 :3

--- Page 11 ---
12 Series Software Customisation Guide
vii © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Window Menu. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:4
Online Help Menu. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16:4
Popup Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:5
Finding Who Popped up a Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:6Toggle Menus. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . 16:6
Editing Bars and Menus  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:7
Inserting Menus into a Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16: 7
Inserting New Menu Fields. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:8
Changing the State of Menufields  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:9Implied Menu-field Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:10
Creating Menus Dynamically . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16:11
Form Layout  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:1
System Font and Unicode characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:1
Layout Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:1
Future Change to VarChars as Default Layout Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:2
Containers, Grid Co-ordinates a nd Gadget Boxes . . . . . . . . . . . . . . . . . . . . . . 17:2
Positioning, Alignment and Size of  Gadgets. . . . . . . . . . . . . . . . . . . . . . . . . . . 17:3
Auto-placement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:5
Positioning Gadgets on a Defined Path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:6
Setting the Auto-displacement between Gadgets  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:6
Gadget Alignment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17:6
How It All Works. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . 17:6
Default Positions in Gadget Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:8
Relative Placement using the AT-syn tax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:8
Positioning Relative to a Previous Gadget. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:8
Positioning Relative to the Form Extremities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:9
Mixing Auto and Relative Placement .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:10
Absolute Gadget Positioning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:10
AT Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:10
Gadget Size Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:11
Tag Width . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:11
The Meaning of Size for the PML Gadget Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:12
Specifying Gadget Size Relative to a Previous Gadget . . . . . . . . . . . . . . . . . . . . . . . . . . 17:13
Gadget Size Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 :13
Intelligent Positioning and Resizing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:14
ANCHOR Attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17: 15
DOCK Attribute. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17:15

--- Page 12 ---
12 Series viii Software Customisation Guide
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Useful Form Layout Qui ck Checklist . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17:15
Frames  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18:1
Types of Frame. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18:1
Normal Frames. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18:1
Tabset Frames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18:1
Toolbar Frames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18:2
PANEL Frames  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18:2
Fold Up Panel Frames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18: 2
Gadgets and their Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:1
Gadget Definition Commands. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:2
Some Generic Gadget Members an d Methods . . . . . . . . . . . . . . . . . . . . . . . . . 19:3
Gadgets that Support Pixmaps. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:3
Selected and Unselected States  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:3
AddPixmap Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 :3
De-activating Gadgets: Greying Out  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:4
Greying Out Gadgets on Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:4
Making Gadgets Visible and Invisible  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:5
Making Gadgets Visible and Invisible in Frames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:5
Setting Keyboard Focus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:5
Refreshing Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:6
Gadget Background Colour  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19:6
Gadget Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:1
Examples  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:1
Complex Form Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20: 1
Multi-lingual Form. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  20:11
Frame Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:14
Defining a Frame . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:15
Frame Radio Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:1 5
Managing Pages in Tabset Frames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:18Managing the Fold Up Panel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:19
CONTAINER Gadget  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:20
Example of Container Gadget . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:21
Paragraph Gadgets  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:24
Textual Paragraph Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:24
Pixmap Paragraph Gadgets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:24

--- Page 13 ---
12 Series Software Customisation Guide
ix © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Textual Paragraph Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:24
Button Gadgets  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:25
Buttons of Type Toggle  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:2 5
Buttons of type LINKLABEL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:25
Form Control Attributes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20: 26
Defining a Dismiss Button  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:27
Toggle Gadgets  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:27
RToggle Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:28
Option and Combobox Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:29
Textual Option Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:30
Combobox Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:30
Pixmap Option Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:31Setting and Getting the Current Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:31
Slider Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:32
Event Callbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  20:32
Line Gadgets  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:32
Numeric Input Gadget . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:33
List Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:34
Single Choice List Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:35
Multiple Choice List Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:36
Multi-Column List Gadgets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:37
Database Selector Gadgets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:39
Text Gadgets  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:39
Controlling Text Gadgets’ Editing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:40
Copying and Pasting into Text Fields. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:42Formatting in Text Input Gadgets: Imperial Units. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:43
Unset Text Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:44
Validating Input to Text Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:44Setting the Value of a Text Field  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:46
TextPane Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:47
Fixed Width Font  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:48
Fast Access to Lists,  Selectors and Textpanes using DO Loops . . . . . . . . . 20:49
View Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:50
Defining a View Gadget . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:5 0
Resizable View Gadgets  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:51
Pop-up Menus in Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:51
Defining Alpha Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20: 51

--- Page 14 ---
12 Series x Software Customisation Guide
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Graphical Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:53
Defining PLOT Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:5 5
Defining DRAFT’s Area (2D) Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:56
Defining DESIGN’s Volume (3D) Views. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20:57
Alert Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21:1
Position of Alerts  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21:2
Input Alerts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . 21:2
FMSYS Object and its Methods .  . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:1
Managing the Default Form Layout M ode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:1
Swapping Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:1
Progress and Interrupt Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:2
Refreshing View Gadgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:3
Checking References to Other Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:3
Splash Screen  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:3
Default Form Positioning  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:3
CurrentDocument() Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:3
LoadForm() Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:4
Cursor Function Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22:4
Setting the Default Format Object for Text Fields  . . . . . . . . . . . . . . . . . . . . . . 22:5
PML Add-ins  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:1
Application Switching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:1
Main Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:2
Callbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:2
Defining an Add-in . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:2
Add-in Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . 23:4
Initialisation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . 23:4
Menus  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:5
APPMENU Object  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 :5
Addition of Menu Items. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 3:5
Removing Menu Items . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:6
Modifying the Bar Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23: 6
Toolbars  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:7
Toolbar Control. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:7
Removing Gadgets from a Toolbar  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:8
Deactivating Gadgets on a Toolbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:8

--- Page 15 ---
12 Series Software Customisation Guide
xi © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Forms  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:8
Registering a Form. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  23:8
Hiding Forms when Exiting Applications  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:9Storing Data Between Sessions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:9
Converting Existing User-defined Applications . . . . . . . . . . . . . . . . . . . . . . . 23:10
Replacement of the DBAR File  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:10
Menu Name Clashes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:11
Converting the DBAR File  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:11
Example Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:11
Adding a Menu Field  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23: 11
Creating a Custom Delete Callback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23:12
Core Managed Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .A:1
Form Core Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .A:1
FORM Core Code Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A:2
Gadget Core Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .A:2
GADGET Core Code Interface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A:3
Menufield Core Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .A:4
MENUFIELD core code interface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A:4
PML Defined Menufields Managed by Application Fram ework Addins . . . . . . . . . . . . . . . . A:5
Manipulating VIEWS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .B:1
Manipulating 2D Views  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .B:1
Manipulating 3D Views  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .B:3

--- Page 16 ---
12 Series xii Software Customisation Guide
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 17 ---
 Software Customisation Guide
Introduction
12 Series  1:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.1 Introduction
This manual describes how to use PML , the AVEVA Programmable Macro Language. You
should use it together with the Software Customisatio n Reference Manual.
You do not have to be a professional programmer to start to learn PML, although you may
find this manual difficult to follow unless you have some understanding of programmingconcepts such as if statements and do loops. If you have no programming experience, youshould consider attending a PML Training Course. For details, contact your local supportoffice, whose address is given on the copyright page of this manual.
The current version of PML, sometimes refe rred to as PML2 , may simply be seen as an
extension to the original PML1  facilities. However, the more powerful techniques that are
available mean that many programming tasks are carried out in different ways.
There are some tasks which are carried out more  efficiently using PML 1 facilities. These
are described in this manual where necessary, you should also refer to the Database
Management Reference Manual .
1.1 PMLs Character Format
From PDMS12.1, all textual information in PDMS is represented as Unicode.
Unicode is a computing industry standard for the consistent encoding, representation and
handling of text expressed in most of the world's writing syst ems. Developed in conjunction
with the Universal Character Set standard and published in book form as The Unicode
Standard, the latest version of Unicode cons ists of a repertoire of more than 109,000
characters covering 93 scripts. For more information refer to: http://en.wikip edia.org/wiki/
Unicode . 
The PML Internal Format for string data is Unicode UTF8 format.This means that all PML string variables support Unicode values.
You can use Unicode characters in PML variable names, PML object form and gadget
names, PML method and function names.
All PML language files should either be UTF8 format with a BOM present or else strictly
ASCII 7-bit (decimal 32 to 127) format.
1.2 Customising a Graphical User Interface
Most AVEVA products make use of a Graphical User Interface  (GUI) to driv e the software.
The interfaces provided with your AVEVA software are designed to apply to a wide range ofsituations and business needs. However, as  you become more experienced with AVEVA
products you may wish to design an interface that is more closely related to yourrequirements.

--- Page 18 ---
12 Series  1:2 Software Customisation Guide
Introduction
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.PML 2 has been specifically desig ned for writing and customising the Forms and Menus for
AVEVA products. Almost all the facilities available in PML 1 and the older Forms and Menus
facilities continue to functi on as before even if they  are not documented here.
Before you begin customising a GUI, you mu st have a good working knowledge of the
command syntax for the AVEVA product you are working with. The commands aredescribed in detail in the reference manuals for the products.
1.3 Serious Warning About Software Customisation
The ability to customise individual Applications  to suit your own sp ecific needs gives you
great flexibility in the ways in which you use your system.
But it also introduces the risk that your modified macros may not be compatib le with future
versions of the software, since they are no longer under AVEVA’s control.
Your own Applications may diverge from future standard versions and may not take
advantage of product enhancements incorporated into the standard product.
To minimise this risk, it is most important th at your in-house customisation policies constrain
any changes which you make to the Applications so that they  retain maximum compatibility
with the standard product at all times.
Remember that AVEVA Limited can give you full technical support only for products over
which it has control. We cannot guarantee to solve problems caused by software which youhave written yourself.
1.4 How to Use this Manual
Chapters 2 to 12 descr ibe the facilities available in PML2 , with reference to  the differences
between PML1 and PML2.
Chapters 13 onwards describe how to use PML2 to customise a GUI.Appendix A contains detailed information for AVEVA developers on how to use core-code
managed objects.
Appendix B contains details of how to mani pulate the interactive 2D and 3D views.
1.4.1 Hints on the Trying the Examples
This manual is not really designed as a self-t each tutorial, although users who are already
familiar with PML 1 prog ramming may be able to use it as such.
Because PML 2 is specifically designed to be  used to create Forms and Menus, the best
way of experimenting is to start up an AVEVA product and display the command line.
You can then create a new form definition file , or edit an existing one, display the form, and
use it to call the PML Functions which you have defined in separate files.
The source files for some of the larger examples are available from the AVEVA web site, so
you can download them rather than having to type them in. 
You can find them here under PDMS/Macro Library.http://support.aveva.com/suppor t/United_Kingdom/index.htm

--- Page 19 ---
 Software Customisation Guide
Introduction
12 Series  1:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.1.5 Minimising Problems for Future Upgrades
When future versions are rele ased, the product documentation will identify which macro files
(Form, Object, Function, macro) and which parts of the directory hierarchy have been
modified. You must then decide on one of three courses of action for dealing with anycustomised Appware which you may have been using:
• Run your existing Appware, thereby ignori ng any enhanced features which may have
been incorporated into the standard versions.
• Revert to using standard Appware instead of your customised versions.• Update your customised Appware to take  advantage of any enhanced features now
available.
In order to minimise any problems resulting from updating your customised Appware, you
should adopt the following key principles as part of your customisation policy:
• The directory which holds the Appware files associated with your Applications is
divided into two main areas: a standard product area and a user  area. You should
make changes  only in the User area  using only copies  of the standard Application
macros.
Warning:  You should never modify the original files, so that you can always revert to
using these if things go wrong.
• The environment variable PMLLIB  is a search path which must be set to the directory
or list of directories under which user-defined PML Functions, objects and forms arestored. The directory specif ied can contain sub-director ies which will automatically be
scanned by PML.
• When writing your own PML Appware, follow the styles and conventions used in the
AVEVA standard  AppWare .
• Make sure that the names  of any new objects, forms and functions which you create
cannot conflict with the name s of any standard AVEVA Appware which may be used in
the AVEVA Applications. You should prefix t he names of your objects, forms and global
variables with a suitable code to distinguish them from AVEVA names. For example, acompany XYZ could choose to start all form and global variables names with the
characters XYZ.
1.6 Current PML2 Naming Convention
The majority of the existing PML2 code has been given a three or four letter prefix to the full
name.
Application Prefix Comments
Accommodation ACCAdministration ADM
Access, Stairs & Ladders ASL
Area Based ADP ABA Add-in application
Assembly ASSY
Associations ASSO C None apparent
Common COMM MixedDesign DES Mixed

--- Page 20 ---
12 Series  1:4 Software Customisation Guide
Introduction
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Icon naming
Icons are named without regard to any rules, except on odd occasions.Draft DRA Plus ADP, DGN, DXF
Global GLB
Hull Design HULL
Marine Drafting MDRA NoneIntegrator INT
Isodraft ISO
Isometric ADP ISO Add-in applicationMarine Diagrams DIAG No appware except main form
Monitor MON
Paragon CATReview Interface REVI None - Single file
Router RTR
Spooler SPLTraining TRA
AVEVA Marine AMAR No appware except start-up
Folder Prefix Comments
Actions - VariousApplications - Various
Access, Stairs & Ladders ASL
Assembly ADP ADConstructs - Various
Design DES Various
Draft DRAFTProfile PRFL Various
Schematic Model Viewer SMV Various
Shapes - No existing iconsSplash - Various
Styles STY Plus FSTYApplication Prefix Comments

--- Page 21 ---
 Software Customisation Guide
Introduction
12 Series  1:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.1.7 Note for Users Familiar with OO Concepts
PML2 is almost an object-oriented language. Its main deficiency is that it lacks inheritance.
However, it does provide for classes of built-in, system-defined and user-defined objecttypes.
Objects  have members  (their own variables) and methods  (their own functions ). All PML
Variables are an instance of a built-in, s ystem-defined or user-d efined object type.
Operators  and methods are polymorphic  — what they do (their behaviour) depends on
the type of the variable. Overloading  of functions and operators is supported for all variable
types.
There is no concept of private  members or methods, everything is public . There are only
two levels of scope for variables: Global  and Local . Arguments  to PML Functions are
passed-by-reference with Read/Write access so any argument can potentially be used asan output argument.
Warning:  Changing the value of an argument inside a PML Functions or method will
change the value in the calling function or method .

--- Page 22 ---
12 Series  1:6 Software Customisation Guide
Introduction
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 23 ---
 Software Customisation Guide
Variables, Objects, Functions and Methods
12 Series  2:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.2 Variables, Objects, Functions and Methods
2.1 PML Variables
Variables  are used to store values. Variables have names. The value that is stored can be
changed but the name is fixed. You choose the names and decide what is stored by eachvariable.
The variables used in PML 2 are objects:
• Every object (variable) has a unique name.
• An object has a set of functions associated  with it, which can be called to manipulate
this data. These functions are called methods.
• Some methods change the data held by the object, some return a result derived from
the data, and some methods do both.
• The data that an object can hold and the fu nctions that are available are fixed by the
object type (sometimes called the object’s class ).
• Before you can create an object, the object type must have been defined. The object
type definition specifies what the members and methods are for that type of object.
2.2 Object Types
Every PML2 variable has an object type which is set when the variable is created and
remains fixed as long as the variable exists.
Attempting to store a value of the wrong type in an  existing variable will cause an error. The
object type must exist before you can create a variable of that type.
PML 2 is supplied with built-in  object types, system-defined  object types, and you can also
define your own user-defined  object types.

--- Page 24 ---
12 Series  2:2 Software Customisation Guide
Variables, Objects, Functions and Methods
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The built-in object types include the following:
There are also system-defined variable types, such as POSITION  and ORIENTATION  in
PDMS.
User-defined variable types are explained in User-defined Object Types .
2.3 Members and Attributes
An object can contain one or more items of data referred to as its members  or attributes .
Each member has a name.
•STRING , REAL  and BOOLEAN  variables just have a value - no members.
•ARRAY  variables have numbered elements, not members.
2.4 User-defined Object Types
You may find that the object types supplied with PML 2 are enough.
However, you can define new object types if you need to. In any case, the following example
may help you understand objects, their members and how they are used.Object Description
STRING This holds any Unicode te xt, including newline and
characters such as Kanji. In macros written with PML1where variables are created with the VAR command, all
variables are of type STRING , even when they are storing
numbers
REAL This is used for all numeri c values including do loop
counters. There is no separate integer type.
These are often used to store physical quantities (especially
distances). The values stored are (nearly) always in thecurrent working units of the quantity (for distances mostoften mm and inches). To dist inguish what units the value is
stored in the units are also stored with the value as another
member of the REAL object. In addition the type of quantity(its DIMENSION or MEASURE) is  also stored. For distances
this is Length. The full set of standard dimensions and unitssupported by the system is described in the database
reference manual. These are in addition to compound unitsand generic dimensions.
BOOLEAN This is used for the result of logical expressions and holds
the value TRUE  or FALSE  
Note: These are not the same as the STRING  values
‘TRUE’  and ‘FALSE’ .
ARRAY This holds many values of any type and is described in
Chapter 6.

--- Page 25 ---
 Software Customisation Guide
Variables, Objects, Functions and Methods
12 Series  2:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The following commands define an object type FACTORY  with two REAL  members and a
STRING  member:
define object FACTORY
member .Name is STRING
member .Workers is REALmember .Output is REAL
endobject
Here is another example where the object type FACTORY  is itself used for one of the data
members of another object type: 
define object PRODUCT
member .Code is STRING
member .Total is REAL 
member .Site is FACTORY
endobject
It is a good idea to use upper case for object-type  names, and mixed upper and lower case
for variable names, the objects themse lves. For example, a type might be WORKERS , and
a variable name might be NumberOfWorkers.
2.4.1 Storing Object Type Definitions
Object type definitions should normally be stor ed in a file with a lowercase name matching
the name of the object type and a .pmlobj  suffix in a directory specified in the PMLLIB
search-path , which can include the current directory. PML  will load a definition
automatically when  it is needed.
2.5 Creating Variables (Objects)
Note: There is no limit to the number of objects you can create of each type.
2.5.1 Local and Global Variable Names
PML variables are of two kinds: global  and local .
Global  variables last for a whole session (or until you delete them). A local variable can be
used only from within one PML Function or macro.
These two kinds of variable are distinguished by their names. Names beginning ‘ !!’ are
global ; names beginning ‘ !’ are local:
!SurfaceArea
!!Area
PML Variable names may be any combination of letters and digits, starting with a letter, up
to a maximum of 64 Unicode characters (plus the ‘ !!’ or ‘!’).  Names are allowed to
contain a dot (.) but this is now strongly discour aged as a dot has a special meaning in
PML2 as a separator between an object and its methods (see Using the Methods of an
Object ), and between the components of form and gadget names.

--- Page 26 ---
12 Series  2:4 Software Customisation Guide
Variables, Objects, Functions and Methods
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Rather than using a dot as part of a name we recommend that you use a mixture of upper
and lower case to make variable names more meaningful, for example:
!!StartInUpperCase
2.5.2 Notes on Naming Conventions
Use a naming convention to avoid 'polluting the namespace ’ of global variables. All global
names beginning with the letters CD are reserved for AVEVA system use. 
Note: The most recent AVEVA  Applicationware  (AppWare ) does not use a prefix. When
creating new PML Macros you are respon sible for avoiding name-clashes, for
example, by using your own prefix.
Here are some guidelines on naming variables:
• Use each variable for one purpose only and give it a meaningful name.
• Limit your use of global variables.
• Where possible use PML Object methods and Form methods instead of PML
functions and macros so as to make use of their members and methods which do
not global variables.
• Remember that within the methods of PML Objects and Forms you generally need
only local variables. Any values which are to be exported should be made available
as members or as method values or returned arguments.
• Only use PML Functions (necessarily global) for tasks which are genuinely globally
accessible, i.e. independent of  a specific object or form, or which need to be shared
by several objects or forms.
Current Global Variables
2.5.3 Creating a Variable  with a Built-in Type
You can create variables of any of the built-in types ( REAL , STRING , BOOLEAN  or
ARRAY ), as in the following example, which creates a REAL  variable and sets it value to
99:Application Prefix Comments
Area Based ADP !!ABA Add-in applicationAdministration !!ADM Plus !!CDAApplication Switching !!APP
Batch Handling !!BAT
CADCentre !!CADCDraft !!CDR
Draft Icon Location !!CD2D Icon pathnames
Defaults !!DFLTSGeneral !!CDC Plus !!CDD, E, F, G, H, I, L, M, N, P, S, U, V, W
Specialised !!CE Plus !!ERROR, !!FMSYS
Various Others

--- Page 27 ---
 Software Customisation Guide
Variables, Objects, Functions and Methods
12 Series  2:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!MyNumber = 99
Because the variable is set to a real, PML knows that its type is real. Similarly, you can
create a STRING  variable and set it like this:
!MyString = ‘Hello World’
The PML Variable !MyString  and the constant ‘Hello World’  are both objects of type
STRING . A STRING  is a very simple object and the only data it contains is its text value. In
this simple expression we are creating a new object, a variable of STRING  type, by making
a copy of the original object, the STRING  constant ‘Hello World’ . 
Other examples:
A variable may also be given a type without giving it an init ial value, in which case it will
have the value UNSET :
!!Answer = REAL()
!Name = STRING()
!Grid = BOOLEAN()
!Lengths = ARRAY()
For more about unset variables, see UNSET Values and UNDEFINED Variables .
!MyDistance = 1metre
Will store a distance of length of 1m. However if the current distance units are cm the value
will be stored and repo rted as 100cm, and when they are inch units the value will be stored
as 39.37inches.
The units and measure of any variable can be queried using the UNITS() and DIMENSION()
methods of the REAL objec t. They will return a UNIT and a MEASURE object. These are
built in objects which have their own useful se t of methods, and are used in other methods
to convert values to different units, and to set and query current working units.
2.5.4 Creating Other Types of Variable
You create variables of types that are system-defined or user-defined, using the OBJECT
keyword. For example, to create a variable of type FACTORY :
!NewPlant = object FACTORY()
2.5.5 Using the Member Values of an Object
The way to set individual members of an object is to use the dot notation as follows:
!NewPlant = object FACTORY()
!NewPlant.Name = ProcessA
!NewPlant.Workers = 451!!Answer = 42 $* creates !!Answer as a GLOBAL REAL variable
\!Name = 'Fred' $* creates !Name as a LOCAL STRING variable
!Grid = TRUE $* creates !Grid as a LOCAL BOOLEAN variable

--- Page 28 ---
12 Series  2:6 Software Customisation Guide
Variables, Objects, Functions and Methods
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!NewPlant.Output = 2001
The dot notation is used in a similar way to access the value of a member of an object:
!People = !NewPlant.Workers
sets the variable !People  to 451.
2.6 PML Functions and Methods
Functions and Methods may optionally have arguments  that can be used to return values. 
Arguments have a data type which is specified in  the function or method  definition and they
are checked when the Function or Method is ca lled. An argument may be one of the built-in
types REAL, STRING  or BOOLEAN ; an ARRAY ; a built-in object or a user-defined
object or specified as  ANY.
Functions and methods can optionally return va lues as their results. Functions that do not
return values are known as PML Procedures  (see PML Procedures ).
Here is a definition of a PML Function that has two REAL  arguments. It also has a REAL
return value, as shown by the final is REAL :
define function !!Area( !Length is REAL, !Width is REAL )
is REAL
Inside a function, the arguments are referenced just as if they were local PML Variables.
The RETURN  keyword is used to specify the vari able that stores the return value:
define function !!Area( !Length is REAL, !Width is REAL )
is REAL
!Area = !Length * !Width
return !Area
endfunction
When a PML Function is called, all the PML Variables passed as arguments must already
exist.
In addition, arguments used for input must ha ve a value, which could be a constant, when
the function is called:
define function !!LengthOfName(!Name is STRING) is REAL
!TidyName = !Name.trim()
return !TidyName.Length()
endfunction
The function is called to set the value of a variable !Length  as follows:
!Length = !!LengthOfName( ' FRED ')
Here ' FRED '  is a string constant passed as an argument. We could rewrite this function
so that it returns its results by chan ging its arguments. The output argument, !Length , will
be set to the value required when the function is called:
define function !!LengthAndTrim(!Name is STRING, !Length
is REAL)

--- Page 29 ---
 Software Customisation Guide
Variables, Objects, Functions and Methods
12 Series  2:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!Name = !Name.Trim()
!Length = !Name.Length()
endfunction
Arguments used for output must exist prior to the call and one that is also used as an input
argument must al so have a value:
!Name = ' FRED '
!Length = REAL()
The function is called to set the value of a variable !Length  as follows:
!!LengthAndTrim(' FRED ', !Length)
When an argument value is changed within a PM L Function its value outside the function is
also changed.
The following call is incorrect, as the function cannot modify a constant:
A PML Function returning a value may be used  wherever an expression or PML Variable
can be used, for example, this call to the !Area  function defined above:
!PartLength = 7
!PartWidth = 6
!SurfaceArea = !!Area(!PartLength, !PartWidth)
Note: You cannot switch to a different PDMS m odule if a PML Function is running. Use
EXIT  to exit from the function if it has faile d to complete.
2.6.1 Storing and Loading PML Functions
When a PML Function is called it is loaded auto matically from its source file in a directory
located via the environment variable PMLLIB . The name of the ex ternal file must be
lowercase and must have the .pmlfnc  suffix. The source of a PML Function invoked as
!!AR EA or !!Area  or !!area  all correspond to the file named area.pmlfnc .
Note: The!! signifies that the function is user -defined and that it is global - but !! does not
form part of the external filename. All us er-defined functions are global and only one
may be defined per file.
Note: The define function  must be the first line in the file and that its name and the file
name must correspond.
2.6.2 PML Procedures
A PML Procedure is a PML Function that does not return a result.
A function is defined as a procedure by om itting the data type at the end of the define
function  statement: 
define function !!Area( !Length is REAL, !Width is REAL,!!LengthAndTrim(' FRED ' ,4 ) $* WRONG

--- Page 30 ---
12 Series  2:8 Software Customisation Guide
Variables, Objects, Functions and Methods
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!Result is REAL)
!Result = !Length * !Width
endfunction
Here we are using an output argument, !Result , to return the result rather than using a
function return  value. 
The arguments to the !!Area  procedure can be set as follows, and then the procedure
invoked with the call  command.
!SurfaceArea = REAL()
!Partlength = 7
!PartWidth = 6
call !!Area(!PartLength, !PartWidth, !SurfaceArea)
There will be an error if you attempt to assign  the result of a PML Procedure because there
is no return value to assign. So, for example you can say:
call !!Area(!PartLength, !PartWidth, !SurfaceArea)
!Answer = !SurfaceArea 
But you cannot say:
The ( ) parentheses after the name of a proce dure or function must always be present —
even for procedures that do not need arguments: 
define function !!Initialise()
!TotalWeight = 0!!MaxWeight = 0
endfunction
call !!Initialise()
Although the call  keyword is strictly speaking opti onal, its use is recommended with
procedures.
Note: As well as procedures, you can invoke a PM L Function that has a return value using
call, in which case the function  result value is discarded.
2.7 Arguments of type ANY
You may specify ANY  as the type of an argument (and  even as the type of the function
return value).
Note: The use of ANY  should be the exception rather than the rule as it switches off
argument type checking - an important feature of PML Functions to help ensurecorrect functioning of your PML.!Answer = !!Area(!PartLength, !PartWidth,
!SurfaceArea)$* WRONG

--- Page 31 ---
 Software Customisation Guide
Variables, Objects, Functions and Methods
12 Series  2:9 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.In the case an argument of type ANY, a value of any type may be passed as the argument to
the function:
define function !!Print(!Argument is ANY)
$P $!Argument
endfunction
Where an argument of type ANY  is used, you may need to find out its actual type before you
can do anything with it. The ObjectType()  method can be used for this purpose:
define function !!AnyType(!Argument is ANY)
Type = !Argument.pmlobjectType()
if ( !Type EQ 'STRING' ) then
- - do something with a STRING
elseif ( !Type EQ 'REAL' ) then
- - do something with a REAL
elseif ( !Type EQ 'DBREF' ) then
- - do something with a DB Reference
else
- - do something with all other types or give an error
endif
endfunction
2.8 Using the Methods of an Object
Note: A method is a function that is specific to an object.
The Software Customisation Reference Manual contains a table of the object types supplied
as part of PML 2. For each object type, there is a list of the associated methods andmembers. 

--- Page 32 ---
12 Series  2:10 Software Customisation Guide
Variables, Objects, Functions and Methods
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.For each object type, the table shows:
2.8.1 Example
This section explains how to use methods, using a STRING  variable as an example.
Although the STRING  is a simple object type, it has a large number of methods which can
be called.
For example, if you are interested in the length of the string value, look under the list in the
Software Customisation Reference Manual for STRING  objects, and you will find a method
named Length .
This method returns a REAL  value (the number of characters in the string), but has no
effect  on the variable itself.
You can extract the number of characters in the string and store it in a new variable ,
!Nchars , by calling the method as follows: 
Notice the dot separator between the name of the variable and the name of the method.
Also note the ( ) brackets following the name of the method. The brackets are used toName The name of the method or member. For example, a REAL
object has a method named Cosine .
If there are any arguments, they are indicated in the
brackets () after the name.
For example, the REAL  object has a method named
BETWEEN  which takes two REAL  arguments.
Result or Type For members, we use the heading Type; for methods, we
use the heading Result. 
The type of the member or the result describes what kind of
object we are expecting to see as a member or result of themethod. 
For example, the result of  the method Cosine is a REAL
value.
Some methods do not return a value: these are shown as
NO RESULT .
Status This column is used to give other information about the
method or member.
For methods, this column tells you whether the method
modifies the state of the object.
For members, this column tells you whether the member is
Mutable  (by the user) or Read Only . 
Note that for the system-defined PDMS object types,
members correspond to PDMS attributes
Purpose This column tells you what the member or method does. 
!Nchars = !MyString.length() $* A method call

--- Page 33 ---
 Software Customisation Guide
Variables, Objects, Functions and Methods
12 Series  2:11 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.enclose the arguments of the method, but th ey must be present even if there are no
arguments.
2.9 Methods on User-Defined Object Types
When you define a new object type, you can also define methods which can be used tohandle all objects created with the new type. PML Method definitions are stored in the samefile as the object definition, after the endobject  command. 
Here is an example of an object which define s three methods to illust rate the main ideas.
Note that within a method, !This represents the object which invoked the method and
!This.Answer  is the way to refer to member Answer  of this object.
These methods might be used in the following way: 
!Marvin = object LIFE()
-- The method .Life() was called automatically
!Number = !Marvin.Answer()
-- !Number is set to the value 42
!Marvin.Answer(40)!Number = !Marvin.Answer()
-- !Number now has the value 40
Warning: When you create a new object type, or change an existing definition, you
must load the definition by giving the command:The Code What it Does
define object LIFE
member .Answer is REAL
endobjectDefines the object, with a single
member, Answer .
define method .Life() 
!This.Answer = 42
endmethodDefines a method with no arguments
but the same name as the type of theobject is called the default
constructor  method. If the default
constructor method is present, PMLwill call it automatically to initialise theobject whenever an object of that typeis created.
define method .Answer() IS REAL
return !This.Answer
endmethoddefine method .Answer( !Value Is 
REAL)
!This.Answer = !Value
endmethodA method may return a result in just
the same way as a PML Functionusing the return  command. Set a
member of the object using!This.membername . 

--- Page 34 ---
12 Series  2:12 Software Customisation Guide
Variables, Objects, Functions and Methods
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.pml reload object _name_
2.9.1 Method Overloading
Two or more methods on an object may share the same name providing they have different
arguments. This is called method overloading . PML will invoke the method with the
arguments which match the method call. It is common practice:
• To use a method with the same name as a member and one argument of the same
type to set the member’s value. For example:
!Marvin.Answer(65)
• To use a method of the same name as a member returning a value of the same type
but with no arguments to get the member’s value. For example:
!Number = !Marvin.Answer()
2.9.2 Constructor Methods with Arguments
When an object is created, it is possible to supply arguments that are passed by PML to a
constructor method with matching arguments instead of the default constructor method:
!Marvin = object LIFE(40)
This would invoke a method:
define method .Life(!Value IS REAL) 
2.9.3 Overloading with ANY
As with PML Functions, the type of a me thod argument may be specified as ANY. If method
overloading is being used, PM L will invoke the method with a matching set of explicitly-
typed arguments in preference to calling a method with arguments of type ANY, irrespective
of the order the methods appeared in the object definition file:
define method .SetValue( !Argument Is ANY)
define method .SetValue( !Argument Is REAL)
Then:
!SomeObject.SetValue(100)
will invoke the method with the REAL  argument, but
!SomeObject.SetValue(‘Priceless’ )
will invoke the method with the ANY  argument.
2.9.4 Invoking a Method  from Another Method
Within a method !This.Methodname()  refers to another method on the same object. So
our second LIFE  constructor method, the one with an argument, could be defined as:
define method .Life(!Value IS REAL)
!This.Answer(!Value)
endmethod 

--- Page 35 ---
 Software Customisation Guide
Variables, Objects, Functions and Methods
12 Series  2:13 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.2.9.5 Developing a PML Object with Methods
Whenever you add a new method to an object, you need to tell PML to re-read the object
definition, by giving the command:
pml reload object life
It is not necessary to use this command if  you are simply edit ing an existing method
(although you will have to use it if you edit a form definition file , and change the default
constructor method, described in Form Definition File .)
2.10 Unset Variable Representations
Each new data type supports a String()  method that returns a string representing the
value of the variable. For example:
UNSET  variables of all built-in data types have an unset representation:
Other variable types are system-defined variables. Most of these have adopted the unset
string ‘Unset’ . For example:
User-defined data types can also provide a String()  method. These also support an
UNSET  representation, and usually adopt the UNSET  representation ‘Unset’.
2.11 UNSET Values and UNDEFINED Variables
All data types can have the value UNSET which in dicates that a variable does not have a
value. A variable created without giving it an initial value in fact has the value UNSET : 
!X = REAL()!X = 2.5 $* defines a variable X of type REAL with 2.5 as its
numeric value
!S = !X.String() $* will be a variable of type STRING, with the 
value “2.5”
!X = REAL()!
S = !X.String()$* yields the string ’(the empty string)
!X = BOOLEAN()
!S = !X.String()$* yields the string ‘’ (the empty string)
!X = STRING()
!S = !X.String()$* yields the string ‘Unset’
!X = ARRAY()
!S = !X.String()$* yields the string ‘ARRAY’ 
!X = DIRECTION()
!S = !X.String()$* yields the string ‘Unset’

--- Page 36 ---
12 Series  2:14 Software Customisation Guide
Variables, Objects, Functions and Methods
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Variables with an UNSET  value can be passed around and assigned, but use of an UNSET
value where a valid item of  data is required will alwa ys result in a PML error.
The presence of an UNSET  value may be tested either with functions or methods:
An UNDEFINED  variable is one that d oes not exist. The exist ence of a variable may be
tested with these functions:
if ( Undefined(!!Y) ) then . . .
if ( Defined(!!Y) ) then
There is no equivalent method call. If the variab le does not exist, attempting to call a method
would result in an error.
2.12 Deleting PML Variables
A variable that exists can be explicitly made UNDEFINED  with the Delete() method:
!!Y.Delete()
Warning: You must not attempt to delete members of objects or forms.
2.13 Forms as Global Variables
In PML 2, forms are a type of global variable . This means that a form cannot have the same
name as any other global variable or any other form.
Note that a form definition is also the definit ion of an object, so a form cannot have the same
name as any other object type.Functions Methods
if ( Unset(!X) ) then if ( !X.Unset() ) then
if ( Set(!X) ) then if ( !X.Set() ) then

--- Page 37 ---
 Software Customisation Guide
General Features of PML
12 Series  3:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.3 General Features of PML
3.1 Functions, Macros and Object Definitions
Functions and Macros are PML Files that co ntain stored sequences of commands. The
PML File is invoked whenever this sequence of commands is required.
The PML File may also include control logic which alters the order in which the commands
are carried out and special commands for handling errors.
PML Files are normally created using a text editor.
PML Functions and methods on objects (including forms) are the recommended way of
storing command sequences because:
• There is a check that they have been called with the right type of arguments.
• Arguments can return values.• A PML Function or method can return a result of any type.
Most new AppWare code is written as methods on objects. PML Macro s are explained
in Macros  as they are the basis of the older AppWare code.
PML Macros are normally stored in a directory under the 
PDMSUI search-path.
PML Functions are automatically loaded from a directory under the PMLLIB  search-path.
3.1.1 Comments in PML Files
Comments are additional text included in a PML File for the benefit of someone reading the
PML code.  
The PML processor ignores comments and so they  do not affect the way the code executes.
For a simple one line comment, begin the line with - -  (two dashes) or $* (dollar and
asterisk).
- - This is a new-style PML comment
------------------------------$* The following lines calculate the new angle
You can also use $* to add an inline  comment  to any line of PML:
A comment may extend over several lines provided it is enclosed in the escape sequences
$(  and   $) . 
$( A comment containing! Z=! X+! Y $* We are assuming both !X and !Y are REAL

--- Page 38 ---
12 Series  3:2 Software Customisation Guide
General Features of PML
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.more than one line $)
A comment of this kind can be used temporarily to comment-out  lines of PML to prevent
them from being executed, but without deleting them from the file: 
$( 
skip if (!X EQ !Y)
$) 
3.1.2 Leaving a PML File wi th the RETURN Command
At any point within a PML File a return  command will stop further execution of the file and
return to the calling PML File, if there is one:
if ( count EQ 0 ) then
return
endif
For clarity, return  can be used as the final line of a PML Macro. However, the use of this
command is not essential and there will be no error if it is not used.
Note: This is a different use of return  from the command used to set return values of
variables.
3.2 Case Independence
Everything written in PML, including keywords such as if, do and else  means the same
thing in upper or lower case.
The exception is text enclosed between quotes or  vertical bars, which is used exactly as it is
typed. Throughout this  document you will see examples of  PML code using a mixture of
upper and lower ca se for readability.
3.3 Abbreviations
Many commands have a minimum abbreviation which can be used in place of the full
command.
For readability it is recommended  that you use the full form of the command — no te that it is
not less efficient than using the abbreviation.
PML keywords such as if, else  and do have no abbreviations.
3.4 Special Character $
The $ character has a special meaning in PML. It is an escape character , which means
that together with the character which follows it are treated as a special instruction to PML. 
The pair of characters beginning with $ is known as an escape sequence . $P is a
commonly encountered example, which is us ed to output a message to the screen:
$P This text will be output to the screen

--- Page 39 ---
 Software Customisation Guide
General Features of PML
12 Series  3:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.A number of other escape sequ ences will be described later in  this manual. The important
point to note here that if you need the dollar character itself as part of a command, you will
need to double it:
$$
As the last character on a line, $ means that the next li ne is a continuation line.
For example:
$P This is an example of a much longer message that will
be $
output to the screen
3.5 Text Delimiters
Text strings must be enclosed in either singl e quotes, or apostrophes, or vertical bars:
'apostrophes' or vertical bars. 
The apostrophes and vert ical bars are known as delimiters . Take great care to avoid un-
matched delimiters as this can lead to many lines  of PML code being included as part of the
text string, and so lost. 
3.6 Filename Extensions
The naming conventions are as follows:
Note: All filename extensions must  be entered in lower case.$! The PML variable following the ! (or !!) is expanded as a string
by using its own .STRING() method. 
Note: Real values are automatically expanded with any unit
qualifier appended if the value is a physical quantity.This is useful on $P lines or converting real values tostrings in commands.
$newline command continues on next line without being automaticallyclosed.
$M/filename execute a text file as a sequence of commands or an inputmacro. Named using its filename or pathname.
Extension Use for
.pmlfnc PML Function definition files
.pmlobj PML object type definition files
.pmlfrm PML Form definition files

--- Page 40 ---
12 Series  3:4 Software Customisation Guide
General Features of PML
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.3.7 Storing and Loading PML Files
PML Files must be stored in directories pointed to by the PMLLIB  environment variable. 
When an AVEVA product is started up, PML scans each directory in the PMLLIB  search
path and creates a file named  pml.index  in each directory. 
This index file contains a list of all the PML Files in all the directories under the directory
given in the PMLLIB  search path. All the PML Files listed in the pml.index  files are loaded
automatically when the product is started up.
When you are working on PML Files, you should store them in your own PML working
directory, and add the path of your PML working directory as the first entry in your PMLLIB
search path. Then, when you add a new PML File (after you have started up an AVEVA
product), you will need to tell PML to rebu ild its file index by giving the command:
pml rehash
This command scans all the files under the first directory in your PMLLIB  path, and updates
the pml.index  file.
If other users have added PML Files and updated the appropriate pml.index  files, you can
access the new files by giving the command: 
pml index
This command re-reads all the pml.index  files in your search path without rebuilding
them.
When you are not running an AVEVA product, you can update the pml.index  file in a given
directory by giving the command:
pmlscan directory_name
This command runs a utility supplied with AVEVA products.
Note: The commands pml rehash  and pml index  are a type of command known as
PML directives : they are used outside PML Files to direct PML itself to take certain
actions. More information about using PML di rectives with form definitions is given in
PML Directives
3.7.1 Rebuilding All PML File Indexes
Note: This process can take some time, and it is  possible that if another user gives the
command at the same time, the index files may not be re-built properly. Hence it isrecommended that this command should only be used when necessary. SystemAdministrators are advised to maintain fi rm control over the directories in the PMLLIB
search path by removing wr ite access for most users. 
The following command scans all the file s in all the directories in your PMLLIB  path, and
updates the pml.index  files. 
pml rehash all
3.7.2 Querying the Lo cation of PML Files
If you are not sure where a given file is stored, you can query the path by giving the
following command, using the appropriate file suffix:

--- Page 41 ---
 Software Customisation Guide
General Features of PML
12 Series  3:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.q var !!PML.getpathname(  'filename .pmlobj' )

--- Page 42 ---
12 Series  3:6 Software Customisation Guide
General Features of PML
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 43 ---
 Software Customisation Guide
PML Expressions
12 Series  4:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.4 PML Expressions
An expression  consists of operators  and operands .
For example:
2 + 3 
is an expression, where 2 and 3 are the operands, and + is the operator. The result  of this
expression is 5.
Expressions can (and normally do) contain va riables and, in PDMS, expressions will often
contain names of PDMS  element types , attributes  and pseudo-attributes . 
Expressions can also contain arithmetic an d trigonometric functions, such as the SIN
trigonometric function. 
Often, expressions will c ontain logical operators:
!height GT !width
Here the logical operator GT is being be used to test if !height  is greater than !width . 
Each expression has a type such as REAL , STRING  or BOOLEAN . All the elements in an
expression must be of the correct type. For example:
is meaningless if !X is REAL  and will result in an error. (But see Concatenation  for using the
concatenation operator to convert different types to STRING .)
4.1 Format of Expressions
The use of brackets, spaces and quotes in an expression is important. If you do not follow
the rules given below yo u will get error messages:
Text must be enclosed in quotes, either ' apostrophes or | vertical bars:
’This is text ’ |and this is text|
There must be a space before and after an operator. For example:
!X + !Y 
In general, you do not need spaces before or after brackets, except when a name is
followed by a bracket. If there is no space, the bracket will be read as part of the name. For
example:
(Name EQ /VESS1 )!X + 'text' $* wrong, Wrong, WRONG!

--- Page 44 ---
12 Series  4:2 Software Customisation Guide
PML Expressions
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.4.2 Operator Precedence
Operators are evaluated in the order of the fo llowing list: the ones at the top of the list are
evaluated first.
4.3 Boolean Operators
The Boolean, sometimes called Logical, operators have the following meanings:
The logical operators available are:
Note: The operators EQ, NE, LT, GT, LE and GE are sometimes referred to as comparator
or relational  operators; NOT, AND, and OR are sometimes referred to as Boolean
operators. Refer to Precisions of Comparisons  for tolerances in comparing numbers.Operator Comments
BRACKETS Brackets can be used to control the order in
which operators are evaluated, in the sameway as in normal arithmetic. For example (!A
+!B) * 2.
FUNCTIONS
* /
+ -
NE  NEQ  GT  LT  GE  GEQ  LE  LEQ
NOTAND
OR
Operator Comments
EQ TRUE  if two expressions have the same value.
NE TRUE  if two expressions have different values.
LT TRUE  if the first expression is less than the second.
GT TRUE  if the first expression is greater than the second.
LE OR LEQ TRUE  if the first expression is less than or equal to the
second.
GE OR GEQ TRUE  if the first expression is greater then or equal to the
second.
NOT TRUE  if the expression is FALSE.
AND TRUE  if both expressions are TRUE
OR TRUE  if either or both expressions are TRUE.

--- Page 45 ---
 Software Customisation Guide
PML Expressions
12 Series  4:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.4.4 Concatenation 
The & operator concatenates two STRING  values (joins them end-to-end) to make a result
of type STRING . Values of any type are automatically converted to a STRING  first:
4.5 Nesting Expressions
Expressions can be nested using brackets. For example:
( (SIN(!angleA) * 2) / SIN(!angleB) )
4.6 Units in Real Expressions
Real expressions evaluate to a real and a resultant dimension (physical quantity or
measure). For example:
• adding two distances together create a distance (or length) quantity
• multiplying two distances creates a quantity of area
Functions require compatible units, for ex ample trigonometric f unctions will expect to
operate on angles.
If a pure numeric is supplied instead of a phys ical quantity then it must be a compatible
physical quantity (e.g. SIN(!ANG LE)  or !DIST +!DIST) then it  will be assumed to be of that
quantity and in current working uni ts of that quantity. Otherwise it will be simply taken to be a
number.
The result of the expression will be returned in current working units of the dimensions (e.g.
1metre + 10cm will return  1100mm when current distance units are mm).
4.7 PML 1 and PML 2 Expressions
There are now two styles of expressions available:
• PML 2 expressions are used in if and do commands and when giving a PML Variable
a value using the = (assignment) operator.
• PML 1 expressions must be used in all ot her situations, in particular when using an
expression as an argument to a command. For more information regarding PML 1 referto Database Management Reference Manual.
4.8 PML 2 Expressions
PML2 introduces enhanced fa cilities for expressions in if and do commands and when
giving a PML Variable a value using = assignment.
For example, the value of a PML Variable can be used by giving the variable name as the
expression to the right of ‘ =’:
!SavedValue = !Number!X = 64
!Y = 32!
Z=! X&! Y$* !Z is the STRING 6432

--- Page 46 ---
12 Series  4:4 Software Customisation Guide
PML Expressions
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Users familiar with PML1 shou ld note the absence of $ preceding the variable name. These
new expressions do not need to be enclosed in ( ) parentheses:
!NewValue = !OldValue + 1
PML 2 expressions:
• May be of any complexity.
• May contain calls to PML Functions and Methods.• May include form gadget  values (described later), and object members and methods.
For example:
!NewValue = !!MyFunction(!OldValue) * !!Form.Gadget.Val /
!MyArray.Method()

--- Page 47 ---
 Software Customisation Guide
Control Logic
12 Series  5:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.5 Control Logic
There are four types of construct for implem enting control logic within a PML Function or
Macro. These are:
•T h e  if construct for conditional execution of commands.
•T h e  do command for looping and the associated break  and skip .
•T h e  golabel  for jumping to a line with a label.
•T h e  handle  construct for dealing with errors.
5.1 IF Construct
 The full form of an if-construct  is as follows:
if (!Word EQ 'Peanuts' OR !Word EQ 'Crisps') then!Snacks
= !Snacks + 1
!Meal = FALSE
elseif ( !Word EQ 'Soup') then
!Starters = !Starters + 1
!Meal = TRUE
elseif (!Word EQ 'Fruit' Or !Word EQ 'IceCream' ) then
!Puddings = !Puddings + 1
!Meal = TRUE
else
!MainCourse = !MainCourse + 1
!Meal = TRUE
endif
Each BOOLEAN  expression, such as  (!Word EQ 'Soup') , is examined in turn to see
whether it is TRUE  or FALSE . As soon as an expression that is TRUE  is encountered, the
following block of commands is executed.
Once a block of commands has been ex ecuted, everything else up to the endif  is ignored.
The else  command is optional. If it is included, you can be sure that exactly one command
block within the if-construct will be executed.
The elseif  commands are also optional. Once one of the elseif  expressions has been
found to be TRUE , any remaining elseif  commands are ignored.
Thus the simplest form of the if-construct is:

--- Page 48 ---
12 Series  5:2 Software Customisation Guide
Control Logic
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.if ( !Number LT 0 ) then
!Negative = TRUE
endif
You may not concatenate the commands into one line, so the following are not allowed :
Note: That expressions such as:
if ( !TrueValue OR !UnsetValue) 
if ( !FalseValue AND !UnsetValue)
ignore !UnsetValue  if the value is not required to dete rmine the outcome of the expression.
The same is true for PML Functions which have returned an error.
5.1.1 Nesting if-constructs
Any if-construct may contain further if ... elseif … endif constructs:
if (!Number LT 0) then
!Negative = TRUE
if (!Number EQ -1 ) then
!OnlyJustNegative = TRUE
endif
endif
It is particularly helpful with nested if constructs to indent the code so that the logic is clear.
5.1.2 BOOLEAN Expressions  and if Statements 
New expressions based on the operators such as EQ and GT give a BOOLEAN  result that
can be used directly in a PML2 if test:
if (!NewValu e-1G T0 )t h e n
The expression can be a simple variable provided it is a BOOLEAN  type variable:
!Success = !NewValue GT 0
if (!Success) then
The expression could be a user-defined PML Function provided it returns a BOOLEAN  result:
if (!!MyFunction() ) then
Note: The BOOLEAN  constants TRUE , FALSE , YES and NO and their single-letter
abbreviations not enclosed in quotes  return BOOLEAN  results and so can be used
directly in expressions. For example:if ( !Number LT 0 ) then !Negative = TRUE endif $* WRONG
if ( !Number LT 0 ) !Negative = TRUE $* WRONG

--- Page 49 ---
 Software Customisation Guide
Control Logic
12 Series  5:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The following do not return BOOLEAN  values and are therefore invalid:
For upward compatibility with PML1, STRING  variables set to ‘ TRUE’ , ‘FALSE’ , ‘YES’  or
‘NO’ or their single-letter abbreviations can be used in an if-test as long as they are
evaluated with a preceding $. For example:
There is a built-in PML Method and a function for converting a value to BOOLEAN : 
!MyString = ‘TRUE’
if (!MyString.Boolean() ) then . . .
The Boolean conversion is as follows:Code Result Type
if ( TRUE )
if ( FALSE )BOOLEAN
if ( T )
if ( F )BOOLEAN
if ( YES )
if ( NO )BOOLEAN
if ( Y ) BOOLEAN
Code Result Type
if ( 1 )
if ( 0 )REAL
if ( ‘TRUE’ )
if ( ‘FALSE’ )STRING
if ( ‘T’ )
if ( ‘F’ )STRING
Variable = 1
if ($Variable)REAL
Code Result Type
Variable = ‘TRUE’
if ($Variable)STRING
Code Result 
REAL zero FALSE 
$* All other positive and negative REAL values TRUE

--- Page 50 ---
12 Series  5:4 Software Customisation Guide
Control Logic
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.5.1.3 IF TRUE Expression
IFT/RUE will return a value of  the type defined by the second and third arguments.
If the initial Boolean expression is true, the result  of the first expression is returned.  If false,
the result of the second expression is returned.
Both the second and third arguments are fully  evaluated regardless of the value of the
Boolean.  This is because the function is ev aluated using reverse polish procedure (as is the
case of the expression design). This allows th e IF statement to be nestable with any of the
arguments to IF capable of including other IF functions.
If logical1  expression is set to true, then value of typeX 1expression  is returned
If logical1  expression is set to false, then value of  typeX1 expression is returned
typeX1 and typeX2 are two arguments of the same  type which may be:
Logical
Logical Array
RealReal Array
ID
ID ArrayText
Position
Direction
5.2 DO Loops
A do-loop  enables a series of commands to be re peated more than once. The number of
times the series is repeated is controlled by a counter. 
Control is passed to  the line following the enddo  command after executing the commands
within the loop with the counter variable at its final value.
The full format of the do-loop is as follows:
do !x from 10 to 100 by 10
!Total = !Total + !X
enddo
The enddo  must be present at the end of the loop.
The !X , from , to and by are optional, therefore in its simplest form you may use:
do
commands blockSTRING ‘FALSE, ‘F’, ‘NO’ and ‘N’ FALSE
STRING ‘false, ‘f’, ‘no’ and ‘n’ FALSE
STRING ‘TRUE’, ‘T’, ‘YES’ AND ‘Y’ TRUE
STRING ‘true’, ‘t’, ‘yes’ and ‘y’ TRUE

--- Page 51 ---
 Software Customisation Guide
Control Logic
12 Series  5:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.enddo
This will loop forever unless something in th e commands block stops the loop (see break
and golabel  below)
The elements of the loop are as follows:
5.2.1 Stopping a DO l oop: break and breakif
If the to option is not given, the co mmand block within the loop will be repeated indefinitely.
To stop looping, use either the break  or break if  command:
do !Number
if (!Number GT 100) then
break
endif!Result = !Result + !Number
enddo
do !Number
break if (!Number GT 100)!Result = !Result + !Number
enddoElement Purpose
!X A PML local (or global) variable that is automatically
updated with the value of th e loop-counter every time
round the loop.
If you do not supply a loop variable, a hidden unnamed
variable will be used for the counter. 
Note that the loop variable is REAL . PML will delete any
pre-existing variable of the same name.  After the loophas finished, the counter vari able will retain the value it
had last time through the loop.
from Defines the value of the counte r for the first time round the
loop. 
If you do not give a value, it will default to 1.
to Defines the value of the counter for the final time round
the loop. 
The default is infinity.
by Defines the step size (positiv e or negative) by which the
counter value is changed each time round the loop.
The default value is +1.

--- Page 52 ---
12 Series  5:6 Software Customisation Guide
Control Logic
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Any expression may be used with the breakif  command, even a PML Function, provided
the result is BOOLEAN  (i.e. TRUE  or FALSE ). 
The ( ) parentheses are optional but recommended.
The loop counter variable retains the value it had when the break from the loop occurred. 
5.2.2 Skipping Commands in a DO  Loop using Skip or Skip if
A skip  command is used to go back to the beginning of the do loop, to repeat the loop with
the next value of the do loop counter, omitting any commands following the skip  command.
The following example skips odd numbers: 
do !X
!Number = !Sample[!X]
if ((INT(!Number/2) NE (!Number/2)) then
skip 
endif
!Result = !Result + !Number 
enddo
The skip if  command can sometimes be more convenient:
do !X
!Number = !Sample[!X]skip if (INT(!Number/2) NE (!Number/2))
!Result = !Result + !Number 
enddo
5.2.3 Nested DO Loops
You can nest do-loops one inside the other.  The counter for each loop must have a different
name.
do !X to 10
do !Y ! Z=! X+! Y
break if (!Y GT 5)
enddo
enddo
The inner-most loop goes through all the values of !Y before the outer loop moves on to the
second value of !X. Note that the break  (or skip ) command acts just on the loop
containing it - in this case the inner-most loop.

--- Page 53 ---
 Software Customisation Guide
Control Logic
12 Series  5:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.5.3 Jumping to a Labelled Line
The golabel  command in PML allow you to jump to a line with a matching label name
LABEL /FRED
::
GOLABEL /FRED
The label name /FRED  has a maximum length of 16  characters, excluding the / slash which
must be present. The next line to be execut ed will be the line following LABEL /FRED ,
which could be before or after the GOLABEL  command.
5.3.1 Conditional Jumping to a Labelled Line
do !A
do !B to 3
!C = !A * !B
golabel /finished if (!C GT 100)!Total = !Total + !C
enddo
enddolabel /finished
$P Total is $!Total
If the expression !C GT 100  is TRUE  there will be a jump to LABEL /FINISHED  and PML
execution will continue with the line 
$P Total is $!Total
If the expression is FALSE , PML execution will continue with the line:
!Total = !Total + !C
5.3.2 Illegal Jumping
The following is an illegal jump into a nested do block. It is however permitted to jump out of
a nested block to a line in an enclosing block.
golabel /illegaL
do !Count to 5
!Total = !Total + !Count
label /illegal
enddo$* WRONG

--- Page 54 ---
12 Series  5:8 Software Customisation Guide
Control Logic
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 55 ---
 Software Customisation Guide
Arrays
12 Series  6:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.6 Arrays
6.1 Creating Array Variables
An ARRAY  variable can contain many valu es, each of which is called an array element . An
Array is created automatically by creating one of its array elements. 
For example to create element one of a new array named NewArray :
!NewArray[1] = !NewValue
This will create an ar ray variable named !NewArray  if it does not alre ady exist and will set
element 1 of that array to the value of !NewValue . If !NewArray  already exists as a simple
variable, you will get an error messa ge and the command will be ignored. 
Note: How array elements are referred to by means of a subscript expression in [ ]
square brackets and that there must be no space between the end of the array name
and the subscript. Array elements are accessed in the same way when using thevalue in an expression:
!Average =  ( !Sample[1] + !Sample[2] + !Sample[3] ) / 3
It is also possible to create an empty array which has no elements: 
!X = ARRAY()
The array subscript may be any expression which evaluates to a number. One of the
simplest expressions is the value of a variable:
!MyArray[!Next] = 15
The individual elements of an array variable can be set independently and in any order.
Thus you can set !X[1]  and !X[10]  without setting any of the intervening elements
!X[2]  to !X[9] .  In other words PML arrays are allowed to be ‘sparse’ and to have gaps
between the subscript numbers which have values set.
Note: Negative subscripts are no longer permitted.
An array subscript of zero is allowed but you are advised against using it as many of the
array facilities ignore  array element zero.
An array subscript may be an expression of any  complexity provided it evaluates to a
positive REAL  result and may even include a call to a PML Function:
!Value = !MyArray[!A + (!B * !!MyFunction() ) + !C ]
PML Arrays may be heterogeneous.  That is to say the elements of a PML array do not have
to be all of the same type. Array elements may even be user-defined objects. 

--- Page 56 ---
12 Series  6:2 Software Customisation Guide
Arrays
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Non-existent array elements — after the last set element of the array and the non-existent
elements in the gaps of a sparse array — are all UNDEFINED : the function Undefined()
will return TRUE  and the function Defined()  will return FALSE  for all these subscripts.
6.2 Arrays of Arrays (Multi-dimensional Arrays)
An array element may itself be an array:
!Surname = 1
!Forname = 2
!Employee[1][!Surname] = 'Smith'
!Employee[1][!Forname] = 'Samuel'!Employee[2][!Surname] = 'Bull'
!Employee[2][!Forname] = 'John'
!FullName = !Employee[1][!Forname] & ' ' & 
!Employee[1][!Surname]
The value !FullName  will be 'Samuel Smith' .  
It is also possible to assign an entire array to an array element:
!TempName[!Surname] = 'Truman'
!TempName[!Forname] = 'Harry'!Employee[3] = !TempName 
!FullName = !Employee[3][!Forname] & ' ' &
!Employee[3][!Surname]
The value !FullName  will now be 'Harry Truman'.
6.3 Array Methods
Note: The Software Customisation Reference Manual contains a list of all PML Methods.
Array methods are built-in functions for performing a variety of operations on the array.
These methods are invoked with a dot following the array name. The method name must befollowed by ( ) parentheses - even if the function has no arguments:
!Nelements = !MyArray.Size() 
This method sets !Nelements  to the number of elements currently in the array.  This is an
example of a no-effect  method which does not alter the array but returns a REAL  result
which can be assigned to another variable.
Here is method which does change the array:
!MyArray.Clear()
This is an example of a method which modifies  the array by deleting all the array elements
but produces no-result  value, so there is nothing to assign to another variable. 
There is a third kind of method which both changes the array and returns a result value.
Here the result is assigned to a variable:

--- Page 57 ---
 Software Customisation Guide
Arrays
12 Series  6:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!NewArray = !OldArray.RemoveFrom(5,10) 
This is an example of a method result which modifies the array by removing 10 elements,
starting at element 5. NewArray  value is a new array containing the 10 removed elements. 
If not required, the result can be simply discarded by invoking the method as a command
and not assigning the result to a variable:
!OldArray.RemoveFrom(5,10)
Note: Always use an array method, if one is ava ilable, in preference to constructing a do-
loop as it is far more efficient.
6.3.1 Appending a New Element to an Existing Array
To set a new element at the end of an exis ting array without needing to know which
elements are already set, use the Append()  method thus:
!Result.Append(!NewValue)
The new array element to be created is determi ned automatically by adding 1 to the highest
existing index for the array !Result . The data are stored in !Result[1]  if the array does not
yet contain any elements. 
The array !Result  must exist before you can call this  method. If necessary you can create
an empty array (with no elements) beforehand:
!Result = ARRAY()
If !Result  exists already as a simple variable , you will get an error and the command is
ignored.
6.3.2 Deleting an Array Element
To destroy an array element use the Delete()  method.
!MyArray[N].Delete()
The deleted array element would test as UNDEFINED . Note that the array continues to exist
even when you have deleted all its elements. 
6.3.3 Deleting an Array 
To  delete the entire array, together with any existing array elements, use the Delete methodon the array itself:
!MyArray.Delete()
6.3.4 Splitting a Text St ring into Array Elements
 You can split a text string into its component fields and store each field in a separate array
element using a text string’s Split()  method. This can be useful after reading a record
from a file into a variable. By default, the delimiter is any white-space character (tab, spaceor newline):
!Line = '123 456 789'
!ArrayOfFields = !Line.split()

--- Page 58 ---
12 Series  6:4 Software Customisation Guide
Arrays
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The white-space is treated as a special case since consecutive white-spaces are treated as
a single delimiter and white-spaces at the start or finish of the string are ignored.
The result is to create the array-variable !ArrayOfFields  (if it does not already exist) with
the element !FIELDS[1]  set to '123' , !FIELDS[2]  set to '456' , and !FIELDS[3]  set to '789' .
To specify a different delimiter, specify the required (single) character as the argument to the
Split()  method:
!Line = '123 ,456 ,,789'
!ArrayOfFields = !Line.split(',')
In this example, comma is used as the delimiter. !ArrayOfFields  is created if it does not
already exist with the element !FIELDS[1]  set to  '123' ,  !FIELDS[2]  set to '456' , !FIELDS[3]
created but set to zero length, and !FIELDS[4]  set to '789' . Note that in this case, unlike the
white-space delimiter, consecutive occurrences of the comma define empty elements.
Note: The only way to set the special white-space de limiter is by default; that is, by not
specifying any delimiter as an argument to the Split()  method. If a space is
specified explicitly as the de limiter (as ' '), it will behave in the same way as comma in
this example.
You can combine an array-append method with a text-string Split()  method in a single
command to append the fields of a text string to the end of an existing array variable, thus:
!ArrayOfFields.AppendArray(!Line.Split())
6.3.5 Length of String Array Elements
The length of the longest element in an array can be a useful thing to know, for example
when you are outputting the values in table form. You can do this using the Width()
method. 
For example, in the array !LIST :
!LIST[1]'One'
!LIST[2]'Two'
!LIST[3]'Three'
The command:
!Width = !List.width()
would set to !Width  to the value 5, the length of the longest element in !LIST , which is
‘Three' .
Note: If the array contained elements that were not strings, these are ignored when
calculating the maximum width.
6.4 Sorting Arrays Using Array Methods
The simplest way of sorting an array is to use the Sort()  method:
!MyArray.Sort()
This is a no-result method that modifies the array by performing a sort in-situ. 

--- Page 59 ---
 Software Customisation Guide
Arrays
12 Series  6:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The sort is into ascending order an d will be an ASCII sort on an array of STRING  elements
and a NUMERIC  sort on an array of REAL  values.
The Sort()  method returns the array itself as a list result, so it is possible to follow the call
to the Sort()  method immediately with a call to the Invert()  method, whic h will return a
descending sort:
!MyArray.Sort().Invert()
An alternative approach is an in direct sort using the method SortedIndices()  which
returns a REAL  array representing new index positions for the array elements in their sorted
positions:
!NewPositions = !MyArray.SortedIndices()
The array can be sorted by applying the new index values using the ReIndex()  method:
!MyArray.ReIndex(!NewPositions)
More important, the index values in !NewPositions  can be used to sort other arrays as well.
To use some simple examples, imagine we had the array !Animals  that contained:
The command:
!Animals.Sort ()
Would move the array elements so that they now appeared in the following order:
On the other hand, the command:
!Index = !Animals.SortedIndices()Index Animal
[1] Wombat
[2] Kangaroo
[3] Gnu
[4] Aardvark
[5] Antelope
Index Animal
[1] Aardvark
[2] Antelope
[3] Gnu
[4] Kangaroo
[5] Wombat

--- Page 60 ---
12 Series  6:6 Software Customisation Guide
Arrays
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Would create a new array !index  representing the subscript values of the array elements in
!Animals  then sort these index values (without altering the array !Animals ). After the sort,
!index  would look like this:
The command:
!Index.Invert()
Would result in !index  now looking like:
6.5 Sorting Arrays using the VAR Command
These facilities were designed to work with arrays of STRINGS.
Where a multi-level sort is requ ired it is still necessary to use the older facilities of the VAR
command to perform the sort. Using a different example, look at the arrays !Car, !Colour and
!Year:Index Subscript
[1] 4
[2] 5
[3] 3
[4] 2
[5] 1
Index Subscript
[1] 1
[2] 2
[3] 3
[4] 5
[5] 4
!Car !Colour !Year
[1] CHARIOT MUD 26
[2] FORD RED 1978
[3] VAUXHALL YELLOW 1990
[4] FORD YELLOW 1993
[5] FORD (Unset) 1986 
[6] (Unset) BLUE 1993

--- Page 61 ---
 Software Customisation Guide
Arrays
12 Series  6:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.If you want to sort the arrays by car model, then on colour, and then on year, you would give
the command:
The sorted index values are put into the array !Index , (for clarity shown here with the rows
of the original arrays they are pointing to),
By default values are sorted ascending order using the ASCII character-codes. Other
options which may be supplied after each array name are:[7] Ford GREEN (Unset)
[8] (Unset) (Unset) (Unset)
[9] vauxhall YELLOW 1994
[10 FORD YELLOW 1993
VAR !Index SORT !Car CIASCII !Colour !Year NUMERIC
!Index !Car !Colour !Year
[1] 1 Ö CHARIOT MUD 2
[2] 7 Ö Ford GREEN (Unset)
[3] 2 Ö FORD RED 1978
[4] 4 Ö FORD YELLOW 1993
[5] 10 Ö FORD YELLOW 1993
[6] 5 Ö FORD (Unset) 1986
[7] 3 Ö VAUXHALL YELLOW 1990
[8] 9 Ö vauxhall YELLOW 1994
[9] 6 Ö (Unset) BLUE 1993
[10 8 Ö (Unset) (Unset) (Unset)
Sorting Option Effect
CIASCII Sorts in ascending case-independent alphabetic  order.
DESCENDING Sorts in alphabetic in revers e order
CIASCII DESCENDING Sorts in descending case-independent alphabetic  order.
NUMERIC Forces an ascending numerical sort  on numbers held as
strings.
NUMERIC
DESCENDINGForces a descending numerical sort  on numbers held as
strings.

--- Page 62 ---
12 Series  6:8 Software Customisation Guide
Arrays
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.You can also modify the array to eliminate empty or repeated elements:
To sort these arrays and identify the last occu rrence of each group of the same car type, use
the LASTINGROUP  option:
This would create !Index  by sorting the values in the array !Car , but would also would also
create the array !Last :
A similar option FIRSTINGROUP  identifies the first row of each group.Option Effect
UNIQUE Eliminates instances of duplicated data. For example:
VAR !Index SORT UNIQUE !Car CIASCII !Colour !Ye
ar NUMERIC
!Index  would then have only 9 elements as the value in the
original row 10 was a second reference to a 1993 yellowFord which is discarded.
NOUNSET
NOEMPTYEliminates rows that contain only UNSET  values.
VAR !Index SORT NOUNSET !Car CIASCII !Colour !
Year NUMERIC
Again !Index  would have only 9 elements as the original
row 8 is discarded. 
The option NOEMPTY  discards rows with values that are all
blanks.
VAR !Index SORT !Car LASTINGROUP !Group
!Index !Group !Car
[1] 11 Ö CHARIOT
[2] 2 Ö FORD
[3] 4 Ö FORD
[4] 5 Ö FORD
[5] 10 2 Ö FORD
[6] 33 Ö VAUXHALL
[7] 74 Ö ford
[8] 95 Ö vauxhall
[9] 6 Ö (Unset)
[10] 86 Ö (Unset)

--- Page 63 ---
 Software Customisation Guide
Arrays
12 Series  6:9 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.6.6 Subtotalling Arrays with the VAR Command
Suppose we had sorted the array !Car and another array !Value  using the command:
The arrays would look like this:
We can then generate an array of subtotals for each type of car with the following command:
This would produce the result:VAR !Index SORT !Car !Value LASTINGROUP !Group
!Index !Group !Car !Value
[1] 11 Ö CHARIOT 50000
[2] 2 Ö FORD 1000
[3] 4 Ö FORD 100
[4] 5 Ö FORD 8000
[5] 10 2 Ö FORD 7000
[6] 33 Ö VAUXHALL 2000
[7] 74 Ö ford 1000
[8] 95 Ö vauxhall 3000
[9] 6 Ö (Unset) 9000
[10] 86 Ö (Unset) 6000
VAR !Totals SUBTOTAL !Values !Index !Group
!Index !Group !Car !Value !Totals
[1] 11 Ö CHARIOT 50000 50000
[2] 2 Ö FORD 1000
[3] 4 Ö FORD 100
[4] 5 Ö FORD 8000
[5] 10 2 Ö FORD 7000 16100
[6] 33 Ö VAUXHALL 2000 2000
[7] 74 Ö ford 1000 1000
[8] 95 Ö vauxhall 3000 3000

--- Page 64 ---
12 Series  6:10 Software Customisation Guide
Arrays
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.6.7 Arrays of Objects
6.7.1 DO Values with  Arrays of Objects
Imagine that we have already defined an object type EMPLOYEE  which contains a member
of type STRING .  We create an array of EMPLOYEE  objects and set the Name  member of
each of each object.
!MyEmployees[1] = object EMPLOYEE()
!MyEmployees[2] = object EMPLOYEE()!MyEmployees[3] = object EMPLOYEE()
!MyEmployees[1].Name = ‘James’
!MyEmployees[2].Name = ‘Joe’!MyEmployees[3].Name = ‘Mike’
We then wish to create a new array containing just the employees’ names.
!Names = ARRAY()do !Person VALUES !MyEmployees[9] 6 Ö (Unset) 9000
[10] 86 Ö (Unset) 6000 15000
VAR !variable SUBTOTAL .. This will sum va lue strings that contain values with or
without unitqualifiers. Unit qua lifiers within the strings
will be ignored. This is to allow REPORTER to stilloperate with unit qualified value strings that may havebeen introduced by other VAR or $!variablecommands.
VAR !variable EVALUATE … Will return string  variables and arrays of unit qualified
values if the evaluation generates quantities withphysical dimensions. 
VAR !D EVAL (DIAM) for all CYLI
sets !D to a set of strings such as '90cm' '60cm'  etc. -
when cm are the current length units).  The unit will bethe current working unit.
VAR !variable ATTRIBUTE This sets the variable to a string that contains the value
AND the unit qualifier for attributes with of  a physicalquantity
VAR !X XLEN sets !X to '46cm'  if current units are
cm)
The unit will be the current working unit.

--- Page 65 ---
 Software Customisation Guide
Arrays
12 Series  6:11 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!Names.Append(!Person.Name)
enddo
Each time round the do-loop, the do-variable becomes an object of the appropriate type,
even if the array is a heterogeneous mixture of objects.
6.7.2 Block Evaluation And Arrays
A convenient way of performing the same command on each element of an array is to useblock evaluation . This in effect provides a way of building your own array-methods.
There are two steps involved: first create a BLOCK  object from the command text, then
apply this BLOCK  to that array with the EVALUATE  array method. Here is an illustration:
First we create a BLOCK  out of the command to be processed for each array element:
!ExtractName = object
BLOCK('!MyEmployees[!Evalindex].Name')
Note that the command is enclosed in quotes. The special variable Evalindex  is
automatically incremented during the evaluation of the block to the index of each arrayelement in turn. Finally we use the Evaluate()  method to invoke block processing on the
array:
!Names = !MyEmployees.Evaluate(!ExtractName)
!Names  will contain the name s as an array of STRING  elements.
Take care that the expression does in fact return a value so that new array’s elements can
be created and assigned to it.
Alternatively, you may use an evaluation expres sion which does not return a result provided
you invoke the evaluation directly without trying to assign the result. For example, if youhave defined a !!Print()  function the following is valid:
!Output = object
BLOCK('!!PRINT(!MyEmployees[!Evalindex].Name)')
!MyEmployees.Evaluate(!Output)
Note: In this release there is no object-orient ed shorthand representing ‘this element’. It is
necessary to give the array name along with a subscript expression using!Evalindex .
6.7.3 Using Block Evaluate to Sort an Array of Objects
There are no built-in array methods yet for sorting an array of objects. A possible technique
is to use a block evaluation to create an array of keys to sort:
- - Create a block to extract the object member on which
to sort
!ExtractKeys = object BLOCK
('!MyEmployees[!Evalindex].Name')
- - Evaluate the block to generate an array of sort keys
!SortKeys = !MyEmployees.Evaluate(!ExtractKeys)

--- Page 66 ---
12 Series  6:12 Software Customisation Guide
Arrays
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.- - Create a new array containing the sorted element
positions
!NewOrder = !SortKeys.SortedIndices()
- - Apply the sorted element positions to the original
array
!MyEmployees.ReIndex(!NewOrder)
This Evaluate method is the equivalent of the older command:
VAR .. EVALUATE .. INDICES ARRAY
Note: In particular that there is no automatic database navigation.
6.7.4 DO VALUES and DO INDICES with Arrays
With do values the counter takes the value of each array element in turn: 
!Pump[1] = ’Fred’
!Pump[20] = ’Tom’!Pump[10] = ’Jim’
do !Name values !Pump
Sp array element is $!Name
enddo
This will produce th e following output:
Array Element is Fred
Array Element is JimArray Element is Tom
On exit from a do values  loop PML destroys the loop counter variable.
With do indices  the counter takes the value of each  array subscript at which an array
element is stored:
!Pump[1] = ’Fred’
!Pump[20] = ’Tom’!Pump[10] = ’Jim’
do !IN indices !Pump
!Value = !Pump[!IN]SP Array Element $!N is $!Value 
enddo
This will produce th e following output:
Array Element 1 is Fred
Array Element 10 is Jim
Array Element 20 is Tom

--- Page 67 ---
 Software Customisation Guide
Macros
12 Series  7:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.7 Macros
7.1 PML Macros
Macros are command se quences that are stored in text files.
To access a macro file and input the command sequence to your program, you run the
macro. The file is scanned line-by-line, with exactl y the same effect as if  you were typing the
lines in from a keyboard.
Macro files may include synonyms and user-defined variables. They may also act on data
which you define when you give the command to run the macro (parameterised macros).Macros are permanent records which may be called from within any working session of aprogram.
7.1.1 Naming and Running Macros
A macro file can be given any name that co nforms to the naming conventions of the
operating system.
The suffix .mac  is often used to indicate that the file name is that of a macro, but this is
optional.
The process of reading the contents of a macro file as program input is known as running
the macro . The program does not discriminate between input from the GUI, the keyboard,
or a macro file.
To run a macro, enter:
$M  filename
where filename  is the pathname of the macro file. The filename may optionally be
preceded by a slash (/) character.
If you give only the name of the file, the progra m will look for it in the directory from which
you executed the program.
An error message will be output if the file  cannot be found an d opened for reading.
7.1.2 Macros with Arguments 
It is often convenient to write a macro in a generalised form, using parameters to represent
dimensions, part numbers etc, and to assign specific values to those parameters only whenthe macro is to be run.
In the simplest case, parameters are a llocated positions in the command lines as macro
arguments  by inserting escape codes of the form

--- Page 68 ---
12 Series  7:2 Software Customisation Guide
Macros
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.$n
where n is an integer in the range 1 to 9. These arguments are then specified as part
of the command to run the macro. They follow the macro name, with spacesseparating the individual arguments.
For example, if a macro named beam.mac  includes the command line
NEW BOX XLEN $1 YLEN $2 ZLEN $3
then the macro call
$M/BEAM.MAC 5000 200 300
will run the macro and will set the lengths defined as $1, $2, $3 to 5000, 200 and 300
respectively.
Arguments may be either values  or text, but note that a sp ace in a text string will be
interpreted as a separator between two different arguments.
Apostrophes in text arguments are treated as parts of the arguments, not as separators
between them. For example, if a demonstration macro arg.mac  includes the lines:
$P First Argument is $1
$P Second Argument is $2
$P Third Argument is $3
and is called by the command
$M arg.mac ’Arg1a Arg1b’ ’Arg2’ ’Arg3’
the resulting output will be
First Argument is ’Arg1a’
Second Argument is ’Arg1b’Third Argument is ’Arg2’
whereas the intended output was
First Argument is ’Arg1a Arg1b’Second Argument is ’Arg2’Third Argument is ’Arg3’
If you need to include spaces or newlines in  an argument, you must enclose the argument
between the escape codes $< and $>.
The correct form for the preceding example is therefore
$M/arg.mac $<’Arg1a Arg1b’$> ’Arg2’ ’Arg3’
As an alternative, you may redefine the separator between arguments to be the escape
code
$,
instead of a space.
If you do this, you must end the argument list with the escape code
$.

--- Page 69 ---
 Software Customisation Guide
Macros
12 Series  7:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Note: The full stop is part of the escape code, not punctuation.
Using this convention, the preceding example becomes
$M/ARG.MAC $,’Arg1a Arg1b’$,’Arg2’$,’Arg3’$.
If an argument is omitted when a macro is called, the $n in the macro command line is
ignored. Whether or not this leaves a valid command depends upon the syntax whichapplies.
To avoid possible errors, a default setting may be defined for each argument. If the
argument is omitted when the macro is  called, the default setting will be used.
To define an argument’s default setting, use the command
$Dn = default_string
where n is the argument number (1-9) and default_string  is any sequence of
characters ending in a newline.
The default setting may be specified at any point in th e macro, but it will only be applied from
that point onwards. It is usually best, therefore,  to define any defaults at the beginning of the
macro. If an argument has been specifically de fined, a subsequent def ault specification is
ignored.
Arguments may be omitted in the following ways:
• If the normal macro calling seq uence is used (spaces as se parators, Return as end-of-
line marker), trailin g arguments may simply be omitted
• If a non-trailing argument is to be omitted, the escape code $<$>  must be used to
replace the argument which is not required
• If the $, argument separator is being used, the argument may be omitted from the list
For example, if the macro demo.mac  expects three arguments, the following calls to run the
macro all omit one of the arguments:
7.2 Using Macros and Functions Together
The existing mechanism for invoking a macro using $M continues to be available alongside
the new PML Functions. Most PML code in existing macros should continue to work
unmodified.
To call a macro, even from within a PML Function, use the $M command. Variables used as
arguments to a macro must be STRING  values. PML Variables must be converted to a
STRING  with a preceding $:
$M filename  $!X $!Y $!Z
Note: To gain the full benefits of using PML Func tions it is best not to mix Macros and
Functions extensively. Many of the adv antages of PML Functions depend on using
variables without $ which is not possible with arguments to macros.Macro Call Effect
$M/demo.mac arg1 arg2 Omits third argument
$M/demo.mac arg1 $<$> arg3 Omits second argument
$M/demo.mac $,$,arg2$,arg3$. Omits first argument

--- Page 70 ---
12 Series  7:4 Software Customisation Guide
Macros
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.7.3 Synonyms in PML Macros and Functions
You may use synonyms  in macros, although you can not use them in PML Functions. 
This restriction was introduced because changin g a synonym (which is global to the whole
program) can cause an unintentional change in behaviour of individual macros.
There is also a large performance penalty on  every line of PML executed where synonyms
are permitted.

--- Page 71 ---
 Software Customisation Guide
Using PML in AVEVA Products
12 Series  8:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.8 Using PML in AVEVA Products
Most of this manual describes how to use PML 2 to create and customise Forms and
Menus. This chapter describes how to use PML within AVEVA products. Note that for taskssuch as defining Rules and Report Templates,  you are restricted to the PML 1 expressions
package described in the Software Customisatio n Reference Manual,  and it is also
sometimes necessary to  use the VAR command.
8.1 Composing Text
It is sometimes necessary to arran ge text in multiple columns. The COMPOSE  facility of the
VAR command will help you do this.
For example, if we create the following text string:
!A = 'The quick brown fox jumped over the lazy dogs'
To compose the text we might use the following command:
VAR !Table COMPOSE |$!A|  WIDTH 11 C SPACES 2 |$!A|  WIDTH 15 RThis would give the following output:
COMPOSE  always returns an array with at le ast one element. The number of array
elements depends on the length of the text st rings supplied and the width of each column.
Notice that all of the STRING  array elements are space-padded to the same length.Index Value
[1] The quick The quick brown'
[2] brown fox  fox jumped over'
[3] jumped over  the lazy dogs'
[4] the lazy  '
[5] dogs  '

--- Page 72 ---
12 Series  8:2 Software Customisation Guide
Using PML in AVEVA Products
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Following the COMPOSE  keyword is a list of column defini tions. For each column, there is a
text string, such as |$!A|  which evaluates to a text string, followed by the column layout
keywords in any order:
8.2 Defining Variables for Late Evaluation (Rules)
The following are used to pass the name  of a variable into PDMS as part of a stored
expression so that the value is taken when PDMS processes the stored expression rather
than PML extracting the value at the time the line is read:
VVALUE( !X ) 
VTEXT( !AString )
VLOGICAL( !Aboolean) 
8.3 Using PML in PDMS
The following facilit ies are only app licable to PDMS.
8.3.1 Accessing DB El ements As Objects
A special global variable !!CE has been provided which always refers to the current
element  in the database. !!CE can be used to obtain the DB reference  of the current
element:Keyword Effect
WIDTH n Specifies the space-padded wid th of this column. If not
specified the width of the column will be the length ofthe input string.
SPACES n Specifies the number spaces between this and the next
column.
L
LEFTSpecifies text is to be aligned along the left edge of the
column.
R
RIGHT Specifies text aligned along the right edge of the column
C
CENTRE Specifies justification in the centre of the column.
DELIMITER ' ' This can optionally be used to specify an alternative
delimiter at which to break the input. 
By default the text will be  split at a white-space
character such as space which may be removed fromthe output text. 
If the delimiter is specified as an empty string, the text
will be split at the column edge whatever the content.

--- Page 73 ---
 Software Customisation Guide
Using PML in AVEVA Products
12 Series  8:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!Item = !!CE
!!CE is of type DBREF  so the new variable !Item  will also be of type DBREF . The dot
notation  can be used to access attributes and pseudo-attributes of a database element:
!Bore = !Item.bore
This form of access can also  be used directly on the !!CE variable:
!Owner = !!CE.owner
It is also possible to follo w references between DB elements using this mechanism:
!Rating = !!CE.cref.pspec.rating
Assigning a new reference to the !!CE variable makes the new reference the current
element by navigating to it in the database:
!!CE = !!CE.owner
P-points  are accessed using the P-point number like an array subscript. For example, to
access the direction of P-point[1] :
To access the position of P-point[3] :
A NULREF  is treated as UNSET , so a NULREF  can be tested for in two ways:
if ( !MyDBRef  EQ  NULREF ) then
if ( UNSET( !MyDBRef ) ) then
There is also the function BADREF  which will detect whether a da tabase reference is unset
or invalid (i.e. imposs ible to navigate to):
if (BADREF( !MyDBRef ) ) then . . .
Note: Use full-length names fo r attributes as listed in th e Appendix for compatibility with
future releases.
8.3.2 Assigning Values to Element Attributes
You can assign a new value to a DBREF  attribute, ensuring that the type of the new value
matches the type of the attribut
!!CE.Built = TRUE
You can still assign an attribute va lue in this way even if the PML DBREF  is not the current
element':
!A = !!CE
!!CE = !!CE.Owner!A.Built = TRUE
You can even assign a PML object, such as POSITION , where this corresponds to the type
of the attribute:!Dir = !!CE.Pdirection[1] $* !Dir is a DIRECTION object
!Pos = !!CE.Pposition[3] $* !Pos is a POSITION object

--- Page 74 ---
12 Series  8:4 Software Customisation Guide
Using PML in AVEVA Products
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!!CE .Position = !NewPosition
Note that where the type of an attribute is a PM L object, it is not possible to set an object
member value, such as the up value of a POSITION , directly - this must be done in two
stages:
!Pos = !!CE.Position
!Pos.Up = 2000
!!CE.Position = !Pos
8.3.3 Accessing Informat ion About a Session
A number of special commands have been provided to set a PML Variable with information
about the current session. The commands are:
Current Session
SessionsProjects
Teams 
UsersMDBs
DBs
These commands can be used as in  the following example. The SESSION  object has a
method that returns name of the MDB  in the current session. Hence:
!C = current session
!CurrentMDB = !C.MDB()
This will set !CurrentMDB  to the name of the current MDB .
8.3.4 Evaluating Sel ected DB Elements 
Using the facilities describ ed here you can create an expressi on and have it evaluated for all
elements which satisfy particular selection cr iteria. The results of the expression are then
placed in a named array. 
The command syntax is:
VAR !Array EVALUATE (Expression) FOR select COUNTVAR !Counter
Where:
!Array is the name of the arra y that will be created to contain the results of
(expression ) for all the elements selected within select .
(expression) is the expression that will be carr ied out for all the elements that
match the select  criteria.

--- Page 75 ---
 Software Customisation Guide
Using PML in AVEVA Products
12 Series  8:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.You can append the results of such an eval uation to an existing array using the APPEND
keyword. For example:
VAR !BOXES APPEND EVALUATE ( XLEN*YLEN ) FOR ALL BOXES
will add the values calculated fr om the expression for all BOXES  to the (already existing)
array BOXES .
You can also overwrite elements in the array by  specifying the first index in the array which
you want to be overwritten. The specif ied index, and the inde xes following it, will be
overwritten by the results of the evaluation. For example:
VAR !BOXES[99] EVALUATE ( XLEN*YLEN ) FOR ALL BOXES
will place the result of th e first evaluation for the selected elements at index 99, overwriting
any existing item, and the following results in the subsequent array elements.
8.3.5 RAW keyword When set ting Variables with VAR
Programs that use the Forms an d Menus interface (e.g. the DESIGN , DRAFT  and
ISODRAFT  modules) strip out line feeds and compress consecutive spaces to a single
space before text strings are assigned to array variables. If this is not the effect you want,
you can suppress this automatic editing by including the RAW keyword into the
variable-setting command line for these programs.
The syntax for setting array variable elements to unedited text strings  is
VAR !VarName  RAW  ...
where … represents any of the standard VAR syntax for setting variables.
8.3.6 Undo and Redo
The Undo and Redo functionality has been exposed to PML so you can create your own set
of undoable events.
There are several ways PDMS adds entries to the undo system:
• Using the MARKDB / ENDMARKDB commands.  The syntax is as follows:
MARKDB ‘text’
• where text is an optional description to be included with the mark.  This causes a mark
to be made in the database and an entry made in the undo stack.  You should make
your database changes, and then use the command
ENDMARKDB
• By creating a PML undoable object and adding it to the undo stack. See the Software
Customisation Reference Manual  for a fuller description of  this object. You should
create an undoable object, set up the undo and redo execution strings, and then call
the method add()  to mark the database and add the undoable to the undo stack.
Make your database changes, and then call the method endUndoable() .select is the selection criteria (see above, and the relevant Reference
Manual for your product for details of selection criteria)
COUNTVAR is an optional command which allows you to record how often the
expression is calculated in Counter  , which is increased by one
each time the expression is evaluated.

--- Page 76 ---
12 Series  8:6 Software Customisation Guide
Using PML in AVEVA Products
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.• Automatically whenever a model elemen t is moved using graphical interaction
techniques in Model Editor.
Additionally you may register to be info rmed whenever an undo or redo operation has
taken place, using the PML PostEvents object. See the Software Customisation
Reference Manual  for a fuller description of this object.
After an undoable has been removed from the stack and its state recovered then the user-
supplied method on the PostEven ts object is called, and will be passed the description text
that was associated with the undoable object.

--- Page 77 ---
 Software Customisation Guide
Copies and References  (for Advanced Users)
12 Series  9:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.9 Copies and References (for Advanced Users)
Assignment using = , the assignment operator , usually does what you would expect, but a
detailed explanation of how the different  data types are handled may be helpful.
9.1 Assignment
Assignment always makes a copy  of the right-hand-side to replace what is on the left-hand-
side. The following command copies !Y into !X:
!X = !Y 
If, for example, !Y is an array, this command will duplicate the entire array making a copy of
each of the array elements. The same is true if !Y is an OBJECT . 
The technical term for this is deep copy . Following this copy
!X[1] = ‘New Value’ 
will change !X[1]  but leave the original array !Y unchanged.  
9.2 Form and Gadget References
!!Form  and !!Form.Gadget  are both PML references .  After the command:
!X = !!Form.Gadget 
!X is now a new reference, but the gadget  itself has not been copied. Both PML Variables
now refer to the same gadget.
!X.val = ‘New Value’
!!Form.Gadget = ‘New Value’ 
will both have the same effect and will assi gn a new value origin al gadget. You can
think of a reference as another name for the same object or variable.
9.3 DB References
!!CE is a DB reference . Following the command:
!X = !!CE 
!X is now a new reference to the same DB element , but the element itself has not been
copied.
!Value =  !X.Attribute 

--- Page 78 ---
12 Series  9:2 Software Customisation Guide
Copies and References  (for Advanced Users)
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.will now return an attribute of the current element. 
When the current element changes, !!CE will point to a new DB elem ent. In this example, !X
will not be changed but remains as a reference to the previous  current element.  Because
!!CE is special, 
!!CE = !X
will navigate  to a new current element provided !X is another DB reference. In this
example the command would navigate to the previous current element.
9.3.1 Deep Copy involving References:
Where !Y is an array or object: 
!X = !Y
will make a deep copy of  !Y. However, if any of the array elements is a reference (e.g.
to a gadget or DB element), a copy is made of the reference , but not of the object it
refers to. In other words a deep copy stops copying when it reached a reference. 
9.4 Function Arguments
A function argument  is a PML reference to a value or object outside the function. In effect
the argument is another name for the original PML Variable. 
If we define a PML Function such as the following:
define function !!ChangeIt ( !Argument is STRING)
!Argument = 'New Value'
$P !Argument
$P !!Global Var
endfunction
Then invoke the function like this:
!!GlobalVar = ‘Old Value’!!ChangeIt (!!GlobalVar)
The values printed for !Argument  and !!GlobalVar  will both be 'NewValue' .
Warning: Be very careful about changing function arguments. It is a powerful feature
capable of causing unexpected results.
9.4.1 Constants as Function Arguments
Passing a constant  as a function argument, such as a STRING  in quotes, means the
argument is read only   and cannot be assigned a new value. So if we define a function
define function !!ChangeString( !Argument is STRING)
!Argument = 'New Value'
endfunction
The following will change the value of !S:

--- Page 79 ---
 Software Customisation Guide
Copies and References  (for Advanced Users)
12 Series  9:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!S = ‘Old Value’
!!ChangeString ( !S )
However, the following will result in a PML er ror message because the value passed to the
function as an argument is a CONSTANT  STRING  value which cannot be modified.
9.4.2 Form and Gadget Proper ties Passed as Function Arguments
A form or gadget value passed as a function ar gument is read only so cannot be assigned a
new value. If you wish to change the value of a gadget passed as an argument, pass thegadget itself as an argument, not its value:
define function !!ChangeValue( !Argument is GADGET)
!Argument.val = 'NewValue'
endfunction
9.5 Database Attributes 
PDMS Database Attribute are read only, and so they cannot be given new values by
assigning to them.!!ChangeString ( 'OldValue' ) $* WRONG

--- Page 80 ---
12 Series  9:4 Software Customisation Guide
Copies and References  (for Advanced Users)
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 81 ---
 Software Customisation Guide
Errors and Error Handling
12 Series  10:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.10 Errors and Error Handling
10.1 Error Conditions
An error condition  can occur because a command could not complete successfully or
because of a mistake in a PML Macro or function. The presence of an error normally hasthree effects:
• An Alert box appears which the user must acknowledge
• An error message is output  together with a traceback  of any calling macros or
functions.
• Any currently running PML Macros and functions are abandoned.
This example of an error is caused by an atte mpt to use a PML Variable that does not exist:
(46,28) ERROR - Variable FRED not defined
The 46 is the module  or program section which identified the error and is the error code
itself is 28. 
If the input line had been typed interactively that is  the end of the story.  However, if the input
line was part of a PML Macro or function the error may optionally be handled .
10.2 Handling Errors
An error arising during the processing of a PM L Macro or function does not immediately give
rise to an error message - this depends on the next line of input. 
Provided the next command processed by PML is a matching ha ndle command, the error is
not output and the commands within the matching handleblock  are processed instead. 
elsehandle  blocks may optionally also be present — if the handle  block does not match
the error one elsehandle  will be processed — if  it matches the error:
$* a command causes Error(46, 28)
handle (46, 27)
$* handle block - not processed this time
elsehandle (46, 28)
$* The commands in this matching handle block are processed
next
elsehandle ANY
$* An ANY Handle Block is processed for any errors. I
$* n this position it would handle errors other than (46, 27)
and (46, 28)
elsehandle NONE

--- Page 82 ---
12 Series  10:2 Software Customisation Guide
Errors and Error Handling
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.$* A NONE Handle Block is processed only if there were no
errors
endhandle
$* This line is processed after the handle block.
If (46,27)  matches the error, PML processes the commands in that handle block instead of
outputting an error. Processing of the current PML Macro or function continues at the lineafter the endhandle  command. 
Note: The keywords ANY and NONE  which can optionally  be used in place of a specific
error code.
If the line following a line which has caused an error is not a handle command, the outcome
depends on the current setting of onerror  (see next section ). The default setting is
onerror  RETURN  and the current macro or function is abandoned.
However, if in the calling  PML Macro or function the next command to be processed is a
handle  command, it now gets an opportunity of handling the er ror (and so on up the calling
PML).
10.3 Setting the ONERROR Behaviour
The default setting is:
onerror RETURN
which causes the current macro or function to be abandoned and gives the calling macro orfunction an opportunity to handle the error. 
Another possibility is to jump to  one section of code in the sa me macro or fu nction after any
unhandled error:
onerror GOLABEL /LabelName
$* The first command to be executed after the label $* must be a handle command - it could for example be a
handle ANY command:
label /LabelNamehandle ANY
$* handle block
endhandle
To suppress errors, and error alerts  the following may be used, for example during non-
interactive testing:
onerror CONTINUE
Although the effect of errors is suppre ssed, any error messages generated will still be
output. Beware of using this  option which can have unpredictable effects. The option is
applied to all subsequently nested PML Macro and function calls.
When debugging, you may interrupt normal PML processing after an error:
onerror PAUSE

--- Page 83 ---
 Software Customisation Guide
Errors and Error Handling
12 Series  10:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The effect is the same as $M- and will allow you to type co mmands while the PML File is
suspended. You must type $M+ to resume the PML processing. 
Do not leave this in working code.
10.4 Other Responses to an Error
After handling an error, you ca n still output the detail of the error message with the following
commands:
$P $!!Error.Text
$P $!!Error.Command$P $!!Error.Line
do !line VALUES !!Error.Callstack
$P $!Line
enddo
To abandon the running PML Macro or function, but to re-instate  the error so that the calling
PML code has a chance to handle it, you can use the command:
return error
You can also re-instate the error but suppress the alert using the command:
return error noalert
To generate a new error (or replace an error with your own error) plus an optional message,use one of the following 
return error 1
return error 1 ‘Your error message’return error 1 NOALERT
To handle such an error there is a special form of the handle  command:
handle  1
PML code to handle a user-defined error numberendhandle

--- Page 84 ---
12 Series  10:4 Software Customisation Guide
Errors and Error Handling
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 85 ---
 Software Customisation Guide
Handling Files and Directories
12 Series  11:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.11 Handling Files and Directories
Reading and writing files is gr eatly simplified by using the FILE  object. This chapter
describes the methods most frequent ly used for reading and writing.
Methods are also provided for moving, copying an d deleting files and extracting information
such as the pathname of a file, its size data and time last modified.
A FILE  object may refer to a directory rather than a file and methods are provided for
navigating around the directory structure.
For a complete list of the meth ods available, refer to the Software Customisation Reference
Manual.
11.1 Creating a File Object
A file object is crea ted by invoking the FILE  constructor with the name of the file as its
argument.  For example:
!MyFile = object FILE (‘c:\users\bob\list.txt’)
!MyFile = object FILE (/net/usr/bob/list’)
!MyFile = object FILE (‘%PDMSUSER%\bob\list.txt’)
At this stage, the file may or may not exist — creating the FILE  object does not open or
access the file in any way. 
11.1.1 Example
This example reads pairs of numbers from file data, adds them together and writes theanswers to file RESULTS .
!Input = object FILE('DATA')
!Input.Open(‘READ’)
!Output = object FILE('RESULTS')
!Output.Open(‘WRITE’)do
!Line = !Input.ReadRecord()
if (!Line.set()) then
!array = !Line.Split()
!Total = !Array[1].Real() + !Array[2].Real()

--- Page 86 ---
12 Series  11:2 Software Customisation Guide
Handling Files and Directories
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!Output.WriteRecord( !Total.String() )
else
break
endif
enddo
!Output.Close()
!Input.Close()
11.2 Reading from Files
When reading a file one line at a time using the ReadRecord()  method you must open the
file first with the Open(‘READ’)  method and close it afterwards with the Close()  method.
Each line read from the f ile will be returned as a STRING  until the end of the file is reached,
when you will get an UNSET  STRING  returned.
The UNSET  string can be detected using the STRING  object's Set()  method (or Unset() )
as in the example above (See Example ).
11.3 Writing to Files
When you open a file for writ ing, the file will be created if it does not already exist. 
If you use Open(‘WRITE’)  and the file already exists, the user will be shown an alert
asking whether the file can be overwritten.  Alternatively you may specify OVERWRITE , to
force overwriting of a file if it already exists or APPEND  if you want to add to the end of a file
if it already exists.
11.4 Reading and Writing ARRAYS
You will obtain much quicker performance if you read or write an entire array in a single
operation.  In particular you are recommended to use the ReadFile()  method which
returns the whole file as an array of string s, opening and closing the file automatically:
!Input = object FILE('DATA')
!Output = object FILE('RESULTS')!Lines = !Input.ReadFile()
!ResultArray = ARRAY()
do !Line VALUES !Lines
!Numbers = !Line.Split()
!Total = !Numbers[1].Real() + !Numbers[2].Real() 
!ResultArray.Append(  !Total.String() )
enddo
!Output.WriteFile('WRITE', !ResultArray)

--- Page 87 ---
 Software Customisation Guide
Handling Files and Directories
12 Series  11:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Note: With the ReadFile()  method you may optionally specify the maximum number of
lines you are prepared to read and an error is raised if this number is exceeded. If not
specified, a limit of 10000 is imposed.
11.5 Error Handling When Using a File Object
Errors will mainly be enc ountered when an attempt is made to open a file that does not
exist, has been mistyped or to which you do  not have access. Anticipated errors may be
dealt with in a handle  command following use of the Open()  method.
The errors most commonly encountered include the following:
(160,7) Argument to method is incorrect
(160,9) File does not exist(160,36) Unable to read file record, file is not open(160,37) Unable to write file record, file is not open
(160,44) File exists, user does not want to overwrite it
(160,47) File length has exceeded N lines(41,319) Cannot access file (Privileges insufficient)

--- Page 88 ---
12 Series  11:4 Software Customisation Guide
Handling Files and Directories
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 89 ---
 Software Customisation Guide
Developing PML Code
12 Series  12:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.12 Developing PML Code
All PML variables of type STRING hold thei r data in Unicode UTF8 format. Refer to Using
Unicode Text  for further information.
Fully developed PML code should - if required to - interact with the user by means of forms,
menus, and alert boxes. Howeve r, while you are still developing  your PML code the facilities
described here might be useful. 
The commands described here should normally on ly be typed interactively or included in a
PML File on a temporary basis. None of these commands should remain in fully developedPML code.
12.1 Using Unicode Text
The PDMS command processor supports Unic ode characters. All PML string variables
support Unicode values. You can use Unicode characters in PML variable names, PMLobject form and gadget names, PML method and function names.
Filenames and directory names can also contain foreign Unicode characters, but remember
that you may have problems saving files with foreign Unicode names in some sourcemanagement systems e. g. ClearCase, so be very wa ry about using this facility.
At PDMS12.1 it is mandatory  that PML Appware source files are stored ( in order of
preference ) as:
1.Unicode UTF8  encoding with a BOM  present.
2.Unicode  UTF16 or UTF32 encoding (big-endian or little-endian) with a BOM  present.
3.ASCII 7bit  encoding – no BOM needed
Notes:
•U s i n g  Unicode  encodings with a BOM  means that your (multilingual) Appware can be
read successfully anywhere.
• Restricting your characters to ASCII 7bit  (32 – 127) means that your (restricted)
Appware can be read successfully anywhere  (this is a strict subset of Unicode).
• If you use 8-bit single byte non-Unicode characters e.g. degree sign ° (Latin1
encoding), Euro € (CP1252(ANSI) encoding ), Œ (CP1252(ANSI) encoding) etc. then
you will probably experience difficulty wh en trying to read your Appware with
CADC_LANG set to Korean, Chinese, Japanese etc.
12.1.1 Textual File Handling
By default all sequential text files read by PDMS will be expect ed to be in UTF8 format with
a Byte Order Mark (BOM) present to identify them. Similarly by default all sequential text
files written by PDMS will be in Unicod e UTF8 format with a BOM present.

--- Page 90 ---
12 Series  12:2 Software Customisation Guide
Developing PML Code
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The following PDMS environment variables ar e available for users to modify how PDMS
handles sequential text files:
CADC_LANG  specifies file encoding for reading PDMS external files which do not have an
expected Unicode BOM present. If the variable is  unset, then default to LATIN1 format. Files
with the following Unicode BOMs will be translat ed to UTF8 on reading : UTF16 little-endian,
UTF16 big-endian, UTF32 little-endian, UTF32 big-endian. 
CADC_LANG_NEW  specifies the file encoding for new files written by PDMS. If the
variable is unset, then default to Unicode UTF8 format with a BOM present.
The following encodings are currently supported:
Unicode
      UTF8 Unicode UTF8      UTF16LE UTF16 little-endian      UTF16BE UTF16 big-endian      UTF32LE UTF32 little-endian      UTF32BE UTF32 big-endianISO      LATIN1 ISO8859-1      LATIN2 ISO8859-2       LATIN5 ISO8859-5 CyrillicWindows code page      CP932 Japanese shift-JIS      CP936 Simplified Chinese GBK      CP949 Korean      CP950 Traditional Chinese Big5      CP1250 Central European      CP1251 Cyrillic      CP1252 LATIN1 + some extras (beware)For backwards compatibility with legacy PDMS Projects      JAPANESE Japanese shift-JIS      CHINESE Simplified Chinese (EUC)      KOREAN Korean (EUC)      TCHINESE Traditional Chinese (used in Taiwan for 
example) (EUC)

--- Page 91 ---
 Software Customisation Guide
Developing PML Code
12 Series  12:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.12.1.2 File Transcoding Utility
PDMS provides a file transcod ing utility transc.exe which user s may find useful, particularly
for moving files between PDMS12. 1 and previous PDMS versions.
Transc is a command line application to transcode files from one encoding to another, and
can also be used to add or remove the BOM from existing UTF8 (or UTF16) files. 
The basic syntax is:
Transc -encoding> <input-file> -encoding> <output-file>
See Transc - text file transcod ing utility.doc for more details.
12.1.3 Using Unicode as the new PDMS Internal Format
The major design decision for the Unicode conversion of PDMS was to use (32bit) Unicode
Scalar (US) instead of ASCII codes as it's integer character representation (holding 1 US
character code per array element), and to use UTF8 format for its character byte strings,
with up to 4 bytes to represent 1 character.
The section below describes a few important properties of Unicode Scalars and the UTF8
format.
1. A Unicode scalar is a 32 bit integer code  which uniquely represents a single Unicode
character. Unicode assumes that  the 32 bit range will cope uniquely with all the world's
character sets. 
2. For the ASCII character set (codes 32 to 127) the codes are equal to the Unicode
scalar codes.
3. UTF8 encoding needs 1, 2, 3 or 4 bytes to represent a Unicode scalar. For UTF8 we
need to be able to clearly distinguish the nu mber of characters held and the number of
bytes needed to represent them - as they cannot be assumed to be the same.
4. Within UTF8 the ASCII characters can a lways be found by a simple byte by byte
search in either direction.
5. UTF8 allows the first byte of any adjacent character to be found by simple byte by byte
search in either direction, and every firs t byte yields the number of bytes in the
character. 
6. After having found a UTF8 character first by te (which could be an ASCII character e.g.
$, /, &, space, ~ etc.) then  subsequent bytes of the char acter are never ASCII bytes. So
when you've found an ASCII byte it is a genuine character and not part of another
character.
12.2 PML Tracing
If a PML File does not appear to be running in the way you expect the easiest thing to do is
to turn on PML Tracing with the command:
PML TRACE ON
With PML Tracing switched on, each of the PML lines executed is output to the parent
window together with its line number. Additional  tracing messages tell you when you have
begun to process a new PML File and when it  has finished.  To turn off tracing type:
PML TRACE OFF
These commands can also be put into a PML File on a temporary basis.

--- Page 92 ---
12 Series  12:4 Software Customisation Guide
Developing PML Code
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.You can also turn PML tracing on by setting the Environment Variable PMLTRACE  to ON
before you start the program. 
For more precise control of PML tracing you can use the $R command. $R100  is the
equivalent of PML TRACE ON  and $R0 is the same as PML TRACE OFF .
Type the command $HR for online help on how to use the $R command.
12.3 Diagnostic Messages From Within PML Files
It is often useful to output a line to the screen from within a running PML File to indicate that
the execution of the program has re ached a particular stage. Use the $P command:
$P !Total is: $!Total and !Maximum is: $!Maximum
Note: The use of $ to convert the value of a variable to a STRING . 
12.4 Alpha Log
The alpha-log  is a file containing a record of all the commands processed together with any
text output and error messages. To start recording use one of the following commands:
To finish recording and close the file use:
alpha log ENDl
12.5 Alpha Log and PML Tracing
The alpha-log does not include standard PML tracing from the command PML TRACE ON .
For PML tracing to be included in the alpha- log, PML tracing should be directed to the
alpha-window . For example, to obtain standard PML tracing in the alpha-log use the
command:
$R102
Refer to the online help given by $HR for other options.
12.6 Suspending a Running PML Macro
If you cannot find out what is going wrong by means of PML trace output or writing out the
values of PML Variables, you may suspend a running PML File at a particular point byincluding the command:
$M-
You can then query the values of any PML Variables of interest and even change the valuesof some PML Variables. To resume processing of the suspended PML File type into thecommand line : alpha log /filename $* to open a new file
alpha log /filename OVERWRITE $* to replace an existing file
alpha log /filename APPEND $* to add to an existing file

--- Page 93 ---
 Software Customisation Guide
Developing PML Code
12 Series  12:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.$M+
Use these facilities only for debugging and do not leave thes e commands in a finished PML
File.
Note: These facilities do not apply to  PML Functions or methods.
12.7 Querying PML
A variety of queries are available to help diag nose problems.  Typically you might type these
queries into the command line  whilst a PML File is suspended. Alternatively you could
include any of these commands temporarily within a PML File.
12.7.1 Querying the Curren tly Running PML File Stack
If you are interested in the name of the currently running PML File and the other PML Files
from which the current file was invoked use the command:
$QM
12.7.2 Querying the Valu es of PML Variables
The table below gives some useful commands for querying PML Variables.
12.7.3 Querying What Can Be Typed Next
When you are typing commands into a macro or into a command line, you may not
remember exactly what arguments are available or what other commands are related. 
You will find full details in the appropriate Reference Manuals to th e module, but you can
also ask the command processor  what sort of command or commands it is expecting next
by typing:
$Q
This will produce a list of every  valid command word or argument type that you may enter
next.Command Effect
q var !LocalName Queries the value of a specific  local variable,
use the command.
q var LOCAL Queries the values of all local variables.
q var !!GlobalName Queries the value of a specific  global variable.
q var GLOBAL Queries the values of all global variables
q var !MyArray[1] Queries the value of a specific  element of an
array.
q var !MyArray Queries the values of all elements of an array.
q var !MyArray.Size() Queries the number of elements currently in an
array.

--- Page 94 ---
12 Series  12:6 Software Customisation Guide
Developing PML Code
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The list may be long and could include every valid command for the module that you are in.
The $Q facility is also useful to establish wh at is allowed as th e next component of a
command.  Type the beginning of the command sequence followed by $Q.

--- Page 95 ---
 Software Customisation Guide
Form Concepts: Getting Started
12 Series  13:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.13 Form Concepts: Getting Started
13.1 Overview
As a user of AVEVA products,  you will already be familiar with forms, an d the gadgets
(buttons, textboxes, etc) on them.
The AVEVA software module which provides the ability for users to customise the PDMS
graphical user interface using the PML is referred to as PML Forms & Menus (or just F&M).
The default ‘system font’ used by Forms and Menus to display character data is Arial
Unicode MS  which contains a large number of the world’s alphabets. Internally F&M uses
full Unicode, but can only display the characters  accessible in its current ‘system font’. You
will be able to copy and paste Unicode characters  from and to textual fields of F&M gadgets.
In PML 2, forms are a type of object represent ed by a global variable — the form’s name, for
example !!EntryForm . This means that a form cannot have the same name as any other
object type, global variable, or any other form.
The form object owns a set of predefined  member variables and built-in methods. In
addition, you can define your own members — form variables and form gadgets — and your
own form methods. All these will determine the content and function ality of the form.
Gadget objects are user-defined members of the form object. Form members are always
accessed using the dot notation , for example
!!EntryForm.TextField
Gadgets own a set of predefined member vari ables and built-in meth ods which determine
the content and functionality of the gadget. For example, the value of a text field gadget is
accessed by:
!!EntryForm.TextField.val. 
Note that gadgets do not support user-defined  member variables or user-defined gadget
methods.
Note: All the in-built members and methods of forms and gadget-types are listed in the
Software Customisation Reference Manual . 
Callbacks  are user-defined actions assigned to a form and its gadgets and that are
executed when the operator interacts with the fo rm, for example, by clicking a mouse button
on a gadget.
The callbacks are supplied as text strings and may be any valid PML expression, PML
Function or method call, including any form,  gadget or user defined object method.
Effectively, these callbacks determi ne the intelligence of the form.

--- Page 96 ---
12 Series  13:2 Software Customisation Guide
Form Concepts: Getting Started
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.13.2 Naming Forms and their Members
The following are examples of the format of form and member names:
Note: That total length of the name is limited to 1024 characters even though the length
each individual components is limited to 64 characters. Within the form definition, the
members of the form should be referred to by using !This  to replace the form name
part of the gadget name. For example:
!This.GadgetName
!This.GadgetName.val
Note: The obsolete convention of using an underscore to replace the form name has been
retained for compatibility with earlier versions.
13.3 Simple Form
You define a form using a command sequence that starts with:
setup form !!formname
and ending with:
exit
Between these two commands come a number of optional subcommands which define thegadgets on the form. 
The following example defines a small form, containing the text ‘Hello World’ , and a
button labelled ‘ Goodbye’ , which removes the form when pressed:
setup form !!hello
paragraph .Message text 'Hello world'
button .bye 'Goodbye' OK
exit
Figure 13:1. A Simple Form
Some points to note about the above definition and the form it creates are:
• there are no user-defined methods on this form, and so the setup form . . . exit
sequence is the complete form definition;!!EntryForm The name of a form
!!EntryForm.GadgetName The name of a gadget on a form
!!EntryForm.GadgetName.val The data value held by that gadget


--- Page 97 ---
 Software Customisation Guide
Form Concepts: Getting Started
12 Series  13:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.• the paragraph command adds a paragraph gadget to the form (a paragraph gadget is
just a piece of text displayed on th e form). The name of the gadget is Message , and
the dot before the name indicates that the gadget is a member of the form. The text
itself is specified after the keyword TEXT .
• the button  subcommand adds a button gadget named .bye. The text on the button
will be ‘Goodbye’ . The keyword OK is a form control attribute  that specifies that the
action of this button is to remove the form from the screen. (For more about form
control attributes, see Form Attributes .)
To display the form in this example, you can use the command:
show !!Hello
13.3.1 Adding a Gadget Callback
 To perform intelligent actions  a form or gadget must invo ke a callback We will now add a
simple gadget callback to the hello form. 
We will add a second button, change message , which will execute a callback to modify the
Message  paragraph gadget.
setup form !!hello 
paragraph .Message text 'Hello world'
button .change ‘Change message’ callback |!this.message.val =
‘Modified’|
button .bye 'Goodbye' OK
exit
Figure 13:2. A Form with a Gadget Callback
A gadget callback is defined by the callback  command followed by a command or PML
Function enclosed in text delimiters. As we are giving a text string as part of the command
which is itself supplied as a text string, we  have had to use two kinds of delimiter: the
apostrophe, ( ‘) and the ( |) vertical bar.
Note: The use of This to mean the current form.  When the callback is executed,
!this.message.val = ‘Modified’ 
will set the value member of the gadget Message  on this form to read Modified  rather
than Hello world .
Note: The gadget callback could have been
|!!OtherForm.Para.val = ‘Modified’|
to change the value of a paragraph gadget on another form named !!OtherForm.
Typically a callback will involve many command s and could be a complex piece of code in
its own right. In practise, the recommended way of defining a complicated callback is to use
a form method .


--- Page 98 ---
12 Series  13:4 Software Customisation Guide
Form Concepts: Getting Started
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.First though, we need to store ou r form definition in a file so  that we can edit it at will.
13.4 Form Definition File
Form definitions must be held one per file. The file name must be the form’s name in
lowercase with the file extension .pmlfrm . For example, our form !!Hello  would be
captured in a file called hello.pmlfrm . This definition file should be stored in a directory
pointed to by the PMLLIB  environment variable. It will th en be loaded automatically on
execution of the show !!Hello  command.
The form definition file contains:
• The form definition between setup form  and exit . This includes the commands
which create the form itself, and set its attributes, such as its size and title, thecommands which create the gadgets on the form and specify how they are arranged,
and the definitions of any variables which are to be members of the form.
• Any method definitions should follow the exit  command, each method beginning with
the define method  command and ending with endmethod . Methods on forms are
just like methods on any other kind of object - see Methods on User-Defined Object
Types
• In particular, it will contain the form's default constructor method . This is a method
with the same name as the form, and no arguments. It is the only method calledautomatically when the form is loaded, and so it can be used, among other things, to
set default values for the gadgets on the form.
• The form may be given an initialisation method , which is run whenever the form is
shown (as opposed to when it is loaded). See Form Initialisation Callback .
• No executable statements should appear in the file outside of the form definition or
form methods. The effect of misplaced executable statements is indeterminate. You
can put comments anywhere in the file.
13.5 How Forms are Loaded and Displayed
A form definition must be loaded before the form can be displayed.  If you have stored the
definition in a .pmlfrm  file then loading will be automatic when the form is displayed for the
first time. Normally, a form is displayed as a result of the operator making a menu selection
or pressing a button on a form. This is achiev ed either by using the Form Directive in the
menu or button definition (see next section) or by means of the command show
!!formname  used in the gadget’s callback.
However, to display forms when you are developing them, you may find it convenient to type
the command:
show !!formname
Sometimes it is useful to force the loading of a form’s definition file before the form isactually displayed, so that you can edit the form or gadget attributes from another form’s
callbacks before the form is actually displayed.  Using the command
loadform !!formname
from a callback will force load th e definition if the form is un known to PML, but do nothing if
the form has already been loaded.
Once a form has been displayed you can remove it from the screen using the command

--- Page 99 ---
 Software Customisation Guide
Form Concepts: Getting Started
12 Series  13:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.hide !!formname
Note that if you show it again it will appear on the screen, but its definition is already known
to PML and so it will not be loaded.
It is possible to remove a form definition from PML using the command
kill !!formname
The form is then no longer known to PML until a new definition is loaded.
Note: Earlier AppWare used form definitions in ma cro files which had to be loaded explicitly
via $M path-name-to-file . This mechanism still operates for backwards
compatibility, but is strongly di scouraged when writing new AppWare.
13.6 PML Directives
PML directives  are commands used to control PML itself. 
For example, you use a PML di rective to instruct PML to re-make its index when you have
added a new file. Some of these directives have been described in Storing and Loading
PML Files : the information is repeated here, with additional directives for loading forms.
Note: Unlike the PML commands described in How Forms are Loaded and Displayed , PML
directives should not be included in callbacks, but are generally for command lineuse.
You will need to use PML dire ctives when you are developi ng new form definitions or
modifying existing ones. PML direct ives are commands of the form pml . . .
The table below gives some useful PML directives.
Command Effect
pml rehashWhen you create a new PML Form while
an AVEVA product is running, you must linkin the file storing the form by giving thiscommand.
It causes PML to scan all the directories
under the PMLLIB  path, and to create a file
pml.index , which contains a list of all the
.pmlfrm  files in the directories.
pml indexThis command re-reads all the
pml.index  files in your search path
without rebuilding them.
If other users have added PML Files and
updated the appropriate pml.index  files,
you can access the new files by giving thiscommand.

--- Page 100 ---
12 Series  13:6 Software Customisation Guide
Form Concepts: Getting Started
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.See Developing PML Code  for tracing commands that will be useful when you start to
develop PML code.
13.7 Revisiting our Simple Form
Our simple form !!Hello , which we constructed ea rlier in this chapter, is not very intelligent.
Once we have pressed the Change  button the .Message  paragraph will read ‘ Modified’
for ever more, even if we hide the form and re-show it. 
The extended version of form !!Hello  below:
• illustrates the use of th e form definition file;
• illustrates form me thods as callbacks;
• introduces some important predefined form members. 
First save the definition in a file called hello.pmlfrm  and ensure that its directory is in
your PMLLIB  search-path.
setup form !!hello 
title ‘Display Your Message’
paragraph .Message width 15 height 1
text .capture ‘Enter message’ width 15 is STRINGbutton .bye 'Goodbye' OK
exit
define method .hello()
-- default constructor - set gadget load-time default
values
!this.message.val = ‘Hello world’!this.capture.callback = ‘!this.message.val = !this.capt
ure.val’pml reload form  !!formname
When you edit an existing form while an
AVEVA product is running, you must usethis directive to reload the form definitionfile.
kill !!formname If you experience problems of an editedform definition not being re-loaded, youcan use this directive followed by the pml
reload  directive.
pmlscan directory_nameThis command runs a utility supplied with
AVEVA products. When you are notrunning an AVEVA product, you can usethis command to update the pml.index
file in a given directory.
See the Installation Guides  for more
information.

--- Page 101 ---
 Software Customisation Guide
Form Concepts: Getting Started
12 Series  13:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!this.Okcall = ‘!this.success()’
endmethod
define method .success()
-- action when OK button is pressed!this.message.val = ‘Hello again’
!this.capture.val = ‘’
endmethod
Figure 13:3. A Smarter Form
In the form definition:
•title  sets the formtitle  member and hence displays a title;
•para  adds a PARAGRAPH  gadget size 15 chars by 1 line with no content;
•text  adds a TEXT  field gadget with tag ‘Enter message’ , width 15 chars, to hold
data of type STRING .
The constructor method .hello()  does the following:
• initialises the paragraph’s default value to ‘Hello world’ ;
• defines the callback on the text input field: to insert its value into the paragraph;• sets the form member Okcall  (in the line beginning !this.Okcall ). This is a
callback that gets executed when a button with control-type  OK is pressed.
The definition of method .success()  does the following:
• Sets the paragraph’s value to ‘Hello again’ .
• Resets the text field’s value to empty.
Now load and show the form by typing:
PML rehash 
show !!Hello
This will auto-load the form defin ition and execute t he default constructo r method (which will
set the message paragraph to ‘Hello world’  and define the gadget  and form callbacks).
It will also display the form.
Type your message into the Enter message  field and press the Enter  key.  This will
execute the field’s callback, which will write yo ur typed text into the message paragraph.
Type a new message and press Enter . The paragraph updates to reflect what you typed.
Click the Goodbye  button. This executes the form’s Okcall  action which calls the
success()  method. The success()  method sets the paragraph to ‘Hello again’  and
blanks out the text field. Finally, the OK control action hides the form.


--- Page 102 ---
12 Series  13:8 Software Customisation Guide
Form Concepts: Getting Started
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Show the form again and observe that the paragraph reads ‘Hello again’  and not
‘Hello world’ . This demonstrates that when you re -show the form the form’s constructor
is not run, because the form is already loaded.
If you want to reset the form ev ery time it is shown, you mu st define a form initialisation
callback — see Form Initialisation Callback .

--- Page 103 ---
 Software Customisation Guide
Form and Gadget Callbacks
12 Series  14:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.14 Form and Gadget Callbacks
Note: This chapter looks at the callback in more detail. If you are reading this manual for
the first time then you may want to ski p this chapter and re turn to it later.
Before you read this chapter you should have read and understood the Form Concepts
chapter, in which we saw that  callbacks are user-defined actions which are assigned to a
form and its gadgets 
They are supplied as text strings and may be any valid PML expression, PML Function or
method call, including any form, gadget or user-defined object method.
14.1 Callbacks: Expressions
A callback may be any valid expression, including any AVEVA product commands. Forexample, the following is a PDMS command:
‘new box xlen 10 ylen 20 zlen 50’
It can also include PML general commands like
‘$m %pathname%/MyMacro’
to execute a given command macro, or
‘q var !!form’
‘q var !!form.gadget’
which will write out details of the form or ga dget and its members. You might like to try
it on the form !!Hello .
Typical expressions for a callback are
‘!this.gadget.val = !MyObject.count’
‘!MyObject.count = !this.gadget.val’
which get or set the value of a gadget on the form from or to a user-defined object.
14.2 Callbacks: Form Methods / PML Functions
Note: Before you read this section, make sure that you understand user-defined methods,
as described in Methods on User-Defined Object Types .
Most callbacks require more t han a single command, so invoking a method or function (or
macro) is an essential requirement.

--- Page 104 ---
12 Series  14:2 Software Customisation Guide
Form and Gadget Callbacks
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The advantage of using form methods as callbacks is that this keeps the whole form
definition in a single file. Forms defined in early versions of PML 2 used PML Functions as
callbacks. This is still valid and is sometime s even essential as you may need to manage a
group of forms; but mostly the callbacks on a form are specific to that form.
You should note that a method or function invo cation is just a valid PML expression, but
such a powerful expression that it is worthy of its own section in the manual.
We have already used a form method as a callback in the revised !Hello  form in Form
Concepts  chapter:
setup form !!hello 
title ‘Display Your Message’paragraph .Message width 15 height 1text .capture ‘Enter message’ width 15 is STRINGbutton .bye 'Goodbye' OK
exitdefine method .hello()
--default constructor - set gadget default values!this.message.val = ‘Hello world’!this.capture.callback = ‘!this.message.val = !this.capture.val’!this.Okcall = ‘!this.success()’
endmethoddefine method .success()
!this.capture.val = ‘’
endmethod
The .success()  method above could only deliver a fixed string ‘Hello again’  to the
message  PARAGRAPH  gadget. The great advantage of methods is that you can pass
variables as arguments to the method, so it can be used more generally, for example as thecallback to several gadgets. 
define method .success( !output is GADGET, !message is STRING,
!input is GADGET )
output.val = !messageinput.val = ‘’
endmethod
We have added three arguments, an output gadget, an input gadget and a message string
variable. This has made the method very  general. We can still use it as the Okcall  callback:
!this.Okcall = |!this.success( !this.message, ‘Hello again’,
!this.capture )|
When the OK button is pressed the Okcall  action will invoke the success()  method,
passing to it the message paragraph gadget as !output , the message text ‘Hello
again’  as !message  and the text input field gadget capture  as !input . The method will do
just what it did before.
However, we could use it differently. We could add another button gadget, Restart , to the
form:
button .restore 'Restart' callback |!this.success( !this.message,
‘Hello world’, !this.capture )|

--- Page 105 ---
 Software Customisation Guide
Form and Gadget Callbacks
12 Series  14:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.When clicked, the Restart  button‘s callback will execute and set the message  paragraph
gadget to read ‘ Hello world’  and clear the capture  text field, thus restoring the form to
its state when it was displayed for the very first time.
If we invoked the success()  method as:
!this.success( !this.capture, ‘Hello world’, !this.message )
it would set the value ‘Hello world’  into the capture  text input field and clear the
contents of the message  PARAGRAPH  gadget. Not what you need here perhaps, but you
can see how versatile methods can be!
Note: The arguments to methods can be any valid PML object types, built in or user
defined.
14.3 PML Open Callbacks
14.3.1 Events
When the operator interacts with a GUI, an ev ent occurs. For example, when the operator:
• types something into a field on a form;
• moves the cursor into a window;• presses down a mouse button;• moves the mouse with button down;• lets the button up.
The events are queued in a time-ordered qu eue. The application software services this
queue: it gets the next event, determines th e object of the event (for example, form,
gadget, menu) and the event type (for exam ple, enter, leave, select, unselect, popup
etc), deduces appropriate actions and carries  them out. When one event is completed,
the software looks for the next event. 
14.3.2 Open Callbacks at Meta-events
There are a very large number of possible ev ents, and most of them are very low level and
have to be serviced very quickly to produce a usable GUI. It would be inappropriate to allowthe (interpreted) PML AppWare access to them all.
However, the application software defines a set of meta-events for forms and gadgets.
When a meta-event occurs, the application software checks for user-defined callbacks andexecutes them. Hence callbacks are the AppWare’s way of providing actions to be carriedout at these meta-events.
Callbacks provide a simple ye t versatile mechanism for the AppWare to create and manage
the GUI. Sometimes there is mo re than one meta-event associated with a gadget. In this
case, the simple assigned callba ck is insufficient to fully exploit the gadget's possible
behaviours. To overcome this shortcoming we can use open callbacks  to allow the
AppWare to be informed whenever a meta-event is encountered.
Open callbacks can be used wherever callbacks can be used. They always involve methods
or PML Functions with a fixed argument list as follows:
define method .Control( !object is FormsAndMenusObject, !action
is STRING)
•!object is a Forms and Menus  object, for example, a form, gadget or menu.

--- Page 106 ---
12 Series  14:4 Software Customisation Guide
Form and Gadget Callbacks
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.•!action  is the meta-event that occurred on th e object and represents the action to be
carried out by the method. 
The open callback is a string of the form:
'!this.MethodName('
Note: The open bracket ' (', no arguments and no closing bracket. The callback is to an
open  method or function.
We might assign an open callback to a multi-choice list gadget as follows:
setup form !!Open
title 'Test Open Callbacks'
list .choose callback '!this.control(' multi width
15 height 8
exit
define method .open()
do !i from 1 to 10
!fields[!i] = 'list field $!i'
enddothis.choose.dtext = !fields
endmethod
define method .Control( !object is GADGET, !action is
STRING)
if ( !action eq 'SELECT' ) then
--find out all about our gadget object!form = !object.owner()
$*get object’s owner
!type = !object.type() $*get object type
!name = !object.name() $*get object name
!field = !object.PickedField $*get picked field
number 
!s = !object.DTEXT[!field] $*get DTEXT 
-- do something with the data
$p selected $!form$n.$!name $!type field $!field, D
text{$!s}
elseif (!action eq 'UNSELECT' ) then
!n = !object.PickedField $*get picked field
number
$p unselected field $!n $*do something withdata

--- Page 107 ---
 Software Customisation Guide
Form and Gadget Callbacks
12 Series  14:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.• Note in the constructor method open()  we have initialised the list so that field n will
display list field n. DTEXT  is a shorthand for display-text, that is the text displayed in
the list field.
• Control is the method which manages interaction with the list. Note the open callback
defined in list choose.
• Note the use of $* for in-line comments
• Note the use of the printing command $p to print information to the system Request
channel.  $!form  replaces the variable !form  with its current value as a string - this
only works for PML simple  in-built scalars types REAL , STRING , BOOLEAN . $n in
$!form$n.$!name  is a separator needed to separate $!form  from the following ‘ .’
which would otherwise be thought of as part of the variable name.
When a list field is clicked, the list’s ca llback will be examined and if it is an open
method or function, then the Forms and Menus soft ware will supply the arguments
required to comple te the function. 
Thus in this case the actual  callback string executed will be
|!this.control( !!Open.choose, ‘SELECT’ )|
Inside the control()  method we branch on the value of !action  and access the data of
!object  (in this case our list). Finally we perform our application’s resultant action - in this
case just printing out all we know abo ut the operator interaction using the $p command,
which for a selection of an un-h ighlighted list field will write:
Selected OPEN.CHOOSE LIST field 5, Dtext{list field 5}
Notice that the same method could be used to manage several or even all gadgets on our
form since the variable !object  is a reference to a gadget object and is supplied as
!!Open.choose , the full name of the gadget includin g its form. This allows us to find
everything about that object from its in-built methods, including its gadget type ( LIST,
TOGGLE , etc) and its owning form:
!type = !object.type()
!form = !object.owner()
All the in-built members and methods of forms and gadget types are listed in the Software
Customisation Reference Manual.
14.3.3 Using a PML Function in an Open Callback
All the examples so far have used form methods as open callbacks. The code would be
essentially the same if we used PML Functions. The PML Function must be in a file of itsown called control.pmlfnc . The body of the definition wo uld be identical but must be
bracketed by:
define function !!Control( !object is GADGET, !action is
STRING)
  . . .
endfunction
Note that the function has a global name !!control , that is, it is not a member of any form
or object and thus cannot use the !this  variable.endif
endmethod

--- Page 108 ---
12 Series  14:6 Software Customisation Guide
Form and Gadget Callbacks
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The open callback on the choose  list gadget would become
list .choose callback '!!control(' multi width 15 height 8
The rest of the story remains the same.
14.3.4 Objects That Can Have Open Callbacks
Note: The 2D and 3D VIEW  objects supplied in AVEVA products, in particular those in
which Event-Driven Graphics  are used, may have open PML Functions as
callbacks. However, open callbacks on thes e gadgets are not supported as a user-
definable facility at this release.
14.4 Undo/Redo Support for Callbacks
PDMS Undo/Redo is supported by certain callback actions for FORM, MENU and GADGET
objects. Appware can decide, for any callback action, whether it is 'undoable', that is,
supports  the Undo/Redo buttons on the main toolbar. If so then a PDMS UNDOABLEobject must be created and populated with t he required Undo and Redo action strings, and
then assigned to the appropriate F&M object callback.
For example:Object Object 
ClassificationCallback
LIST  multichoice Gadget SELECT, UNSELECT, START,
STOP
LIST  singlechoice Gadget SELECT, UNSELECT
OPTION Gadget SELECT, UNSELECT
ALPHA  VIEW  Gadget SELECT
BUTTON  Gadget SELECT, UNSELECT
TOGGLE  and RTOGGLE Gadget SELECT, UNSELECT
MENU  (command fields) Menu SELECT, INIT
MENU  (toggle fields) Menu SELECT, UNSELECT, INIT
FORM Form INIT, QUIT, CANCEL, OK,
KILLING, FIRSTSHOWN
TEXT Gadget SELECT, MODIFIED, VALIDATE
SLIDER Gadget START, STOP, MOVE
FRAME Gadget SELECT, UNSELECT, 
SHOWN, HIDDEN
NUMERICINPUT Gadget SELECT, MODIFIED
COMBOBOX Gadget SELECT, UNSELECT, VALIDATE

--- Page 109 ---
 Software Customisation Guide
Form and Gadget Callbacks
12 Series  14:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.In the form definition extract below:
Setup form !!myform . . .
Title |MyForm with undoable callbacks|
-- create form members as UNDOABLE objects for each F&Mcallback action,
-- which is to be undoable, e.g. form OK callback, gadget
callbacks etc.member !okUndo   is UNDOABLE
member !doitUndo is UNDOABLE
. . .button .doit  |Do it|  …
. . .
button .ok | OK |  … OK
exit
define method .myform()
-- Constructor
. . .
-- Set up callbacks and assign any undo/redo actions to
their undoable objects!this.okCall = !this.formOK()
!this.okUndo.description( 'MyForm OKcall undo/redo
actions' )!this.okUndo.undoAction( ' ' )
!this.okUndo.redoAction( ' ' )
-- assign undoable to form OK callback!this.setUndoable( 'OKcall', !okUndo )
--
!this.doit.callback = '!this.gadgetActions('!this.doitUndo.description( 'MyForm doit button undo/redo
actions' )
!this.doitUndo.undoAction( '!this.undoitAction( )' )!this.doitUndo.redoAction( 'this.doitAction( )' )
-- assign undoable to do-it button callback
!this.doit.setUndoable( !this.doitUndo ). . .
endmethod
define method .formOK()
-- OKcall callback
. . .
endmethod
define method .doitAction()
-- doit button callback
--  actions for doit/re-doit
. . .
endmethod

--- Page 110 ---
12 Series  14:8 Software Customisation Guide
Form and Gadget Callbacks
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.define method .undoitAction( )
-- undo method for doit button
--  actions to undo the doit/re-doit action. . .
endmethod
Notes
1.In most cases the Undoable object's undoAction and redoAction are not
required!  This is because undo/redo is essent ially linked to the state of the PDMS
database rather than to the state of a form or its gadgets. Once a form is dismissedfrom the screen its state is not usually maintained, but is regenerated by the INIT
callback next time it is displayed. Most fo rms which are sensitive to database changes,
and remain displayed, are updated via their AUTOCALL callback (Tracker system),which again removes the need for explicit undo/redo support.
2. The Undoable object must be a form member (preferred) or a global variable or it
cannot be held by F&M.
When a callback is executed, if an UNDOABLE  object is present, then F&M modifies the
undo/redo stack by means of the following actions:
undoable.Add( )
execute gadget callbackundoable.endUndoable( )
Methods to assign a PDMS UND OABLE object to a callback, and to query a callback's
UNDOABLE object are supported.
Not all callbacks are candidates for undo/r edo. The following sect ions detail what is
possible.
14.4.1 Form Callbacks
Forms currently support undo/redo for the following callbacks only: 
Form methods:
!form.setUndoable( !callbackName is STRING, !undo is UNDOABLE )
!form.undoable( !callbackName is STRING ) is UNDOABLEName Purpose Event/Action Undo/Redo Comments
INIT Initialisation at show INIT yesOK OK action OK yes
CANCEL Cancel action CANCEL yes

--- Page 111 ---
 Software Customisation Guide
Form and Gadget Callbacks
12 Series  14:9 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.14.4.2 Gadget Callbacks
Gadgets support the following: 
Gadget methods:
!gadget.setUndoable(!undo is UNDOABLE )
!gadget.undoable( ) is UNDOABLE
14.4.3 Menu and Menufield Callbacks
Menus and menu-fields support the following: 
Menufield methods:
!menu.setUndoable( !menufieldName is STRING, !undo is UNDOABLE
)
!menu.undoable( !menufieldName is STRING ) is UNDOABLE
14.5 Core Managed Objects
AVEVA developers can define PML forms, menus, and gadgets that can be core-code
controlled. See Core Managed Objects .Name Purpose Events/Actions Undo/Redo Comments
CALLBACK Standard gadget
actionGadget specific e.g.
SELECT, UNSELECT,START, STOP yes
CALLBACK View handler
native actionsNATIVE no Supported by
FEXVNC
CALLBACK View handler
interactioncallbacksHandler specific e.g.
POPUP, ESCAPEyes Supported by
FEXVCA
Callback namePurpose Events/Actions Undo/Redo Comments
CALLBACK Initialisation
at fill menuINIT no
Menufield:
CALLBACK Field  action SELECT yesCALLBACK Toggle field
actionSELECT
UNSELECT yes

--- Page 112 ---
12 Series  14:10 Software Customisation Guide
Form and Gadget Callbacks
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 113 ---
 Software Customisation Guide
Forms
12 Series  15:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.15 Forms
Before reading this section you should have read the Form Concepts chapter.
15.1 Modules and Applications
A PDMS GUI module consists of a set of co -operating applications running within the
Application Window.
Each module has:
• A Main form to present the default app lication and to control access to the other
applications.
• One or more document forms usually displaying the application model.• Transient floating dialog forms that relate to specific tasks.• A small number of docking dialog forms to provide frequently required services.
The Main form has a menu bar  that provides access to all the functionality of the
current application of the module, from its pull-down menus (the main  menu system),
and a set of toolbars , each containing gadgets (usually icon buttons, icon toggles and
pull-down lists) designed to give fast access to frequently used functions.
The Main form is not displayed directly, but supplies all its menus and toolbars to be
displayed in the Application Window.
15.1.1 Application Window
The Application Window(AppWin)  normally occupies most of the screen. When a Main
form is assigned to it, the AppWin’s components are replaced by correspondingcomponents of the Main form.
From top to bottom the AppWin comprises:
• The AppWin Menu Bar, which contains the Main form’s menu bar.
• The Dialog Bar, which contains the Main form’s toolbars.• The Document Area, which contains one or more document forms, which are normally
constrained to this area.
• The Status Bar, which displays current status, messages and general information to the
user.
The picture below shows a typical exam ple of what the AppWin looks like:

--- Page 114 ---
12 Series  15:2 Software Customisation Guide
Forms
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.15.1.2 Current Document
The AppWin supports the Windows ™ Multi-Document Interface (MDI) to manage its forms
of type Document. When a document is shown, or when the user selects a document fromthe menubar’s Window menu or from the window management buttons on the status bar,the document becomes current, and may then be the target for actions selected frommenubar, toolbars or from any do cking dialogs currently displayed.
15.2 Defining a Form
The structure of a form definition f ile has already been discussed in Form Definition File .
The form definition is a command sequence starting with:
setup form !!formname
and ending with:
exit
The sequence includes:
• The commands which create the form itself and set its attributes, such as its minimum
size and title.
• The commands which create the gadgets on the form, and specify how they are
arranged.
• The definitions of any variables which are to be members of the form.


--- Page 115 ---
 Software Customisation Guide
Forms
12 Series  15:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.15.2.1 Form Attributes
All the form attributes are optional and have sensible defaults. Those which can only be set
once must be specified on the setup form line. These are:
• Form type.
• Layout mode.• Minimum size.•R e s i z e .•D o c k i n g .• Form position.• NOQUIT• NOALIGN
Other attributes are specified as sub-commands in the setup form . . . exit
sequence. They can be edited after the form has been created by means of the form’s
in-built member s and methods.
15.2.2 Form Type
The appearance and behaviour of a form is determined by its Type  attribute:
Type of Form Description
MAIN The form that will be swapped to as  a Main form . These forms
are not usually displayed directly, but serve to provide gadgetsfor the application’s toolbar and menus for the application’smain menus.
DOCUMENT Resizable form usually with a view gadget, but no menu bar.
All document forms can be floated or un-floated using theright-mouse popup menu in the form’s top border. When it isfloating, you can drag the form away from the MDI frame andposition it and resize it without constraint. This allows you todrag the document form away to another screen of a multi-screen configuration.
DIALOG This is the default ty pe the form will assume if you give no type
when you set up the form. The default DIALOG  form will be
non-resizable, floating, and non -docking. You can specify the
DOCKING  attribute to allow the form to be docked within the
application frame. By default, a docking dialog is displayedfloating, and you can interactively dock it. When a dialog isdocked it will be resized to ma tch the application frame edge
to which it is docked, and so is resizable by default. Thequalifiers LEFT , RIGHT , TOP, and BOTTOM , specify the edge
of the application frame to  which the dialog form will be
docked when first displayed.
BLOCKINGDIALOG Normal form layout and conten t, but will block access to all
other forms while it is displayed.

--- Page 116 ---
12 Series  15:4 Software Customisation Guide
Forms
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Here are some examples of ways you can set up forms of different types:
15.2.3 Layout Modes
Two layout modes are supported, namely VarChars and FixChars.
VarChars  is a new layout mode, based on measuring precise string widths. It is better
suited to the use of variably spaced fonts, and tends to produce smaller, more pleasing
forms, without unwanted space.
FixChars  is the old layout mode (prior to PDMS12.1), which is based on the use of notional
character width  to calculate the approximate sizes of textual gadgets and gadget tags. 
VarChars is the recommended layout mode for all new forms. Refer to Form Layout  for more
information. 
15.2.4 Minimum Size and Resizability
A form will automatically stretch to  fit the gadgets you add to it.
You can use the SIZE  keyword to give a minimum size in multiples of the character width
and line height . For example:
setup form !!New1 size 25.5 10 
•Character width  is the notional character width for the selected character font. 
•Line height  is the height of the tallest single line gadget, that is a TOGGLE , BUTTON ,
RADIO  BUTTON , OPTION  gadget or single-line PARAGRAPH  for the selected
character font.
The RESIZABLE  command means that the form will be  displayed with re-sizing controls at
its corners. This will allow the user to chang e the size of the form. Docking forms and all
document forms are resizable by default; but for other types, if you do not include the
RESIZABLE  command, the size of the form is fixed.
setup form !!New1 RESIZABLE
setup form !!New2 size 25 10 RESIZABLESetup Code Description
setup form !!myform dialog dock 
leftCreates a resizable docking dialog ;
setup form !!myform dialog 
resizableCreates a resizable fl oating dialog ;
setup form !!myform dialog Creates a non-resizable floating
dialog ;
setup form !!myform Creates a non-resizable floating
dialog ;
setup form !!myform document Creates a resizable MDI child
document ;
setup form !!myform document Float Creates a floating resizable non-MDI
document .

--- Page 117 ---
 Software Customisation Guide
Forms
12 Series  15:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.15.2.5 Intelligent Resizable Forms
All gadgets except ALPHA  and VIEW  gadgets have DOCK  and ANCHOR  attributes that
allow you to define gadgets th at have intelligent positioni ng and resizing behaviour when
their container gadget resizes.
This allows you to have more than one resiza ble gadget on a form an d still have predictable
and potentially complex resize behaviour. An example of an intelligent resizable form isgiven in Complex Form Layout .
However, the DOCK  and ANCHOR  attributes are mutually exclusive: setting the DOCK
attribute resets the ANCHOR  to the default; setting the ANCHOR  attribute resets DOCK  to
none.
ALPHA  and VIEW  gadgets do not support DOCK  or ANCHOR  attributes. They do,
however, expand to fill their containers, so yo u can put them in a fr ame and set the frame’s
DOCK  or ANCHOR  attributes to get the behaviour you desire.
15.2.6 Gadget Alignment Control
Certain gadgets, known as the linear  gadgets, have their centres auto-aligned
approximately to aid simple layout without the user having to know about PATH  and ALIGN
concepts.
This pseudo-alignment gives sensible layout for simple forms, but introduces small errors in
all other circumstances and prevents accurate  controlled layout bec ause the user doesn’t
know the offsets applied. The NOALIGN  keyword allows you to switch off this pseudo
alignment.
NOALIGN  is now the recommended setting for forms of any complexity, and is explained in
more detail in Form Layout .
15.3 Form Members
15.3.1 Form Title and Icon Title
The title  sub-command is used to supply a string that is displayed in its banner at the top
of the form's window. To set the title:
title 'Quite a Long Title for a Form'
You can modify the title at any time using the FormTitle  member:
!!MyForm.FormTitle = 'Modified Title'
The icontitle  sub-command is used to supply a string that is used when a form is
iconised. To set the icon title:
icontitle 'Short Title'
You can also modify the icon title at any time using the IconTitle  member:
!!MyForm.IconTitle = ‘New Icon’

--- Page 118 ---
12 Series  15:6 Software Customisation Guide
Forms
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.15.3.2 Form Initialisation Callback
The form’s initialisation callback  allows the form’s gadgets to be initialised every time it is
shown to reflect the current state of the application and possibly to validate whether the formcan be displayed in the current context. 
The callback will usually be a reference to a fo rm method or possib ly an open callback
where several forms share a global initialisation function. See PML Open Callbacks .
You can set the callback by assigning to the form’s initcall  member. This can be done with
the INITCALL  command:
INITCALL ‘!This.InitCallBack()’
or directly by
!!MyForm.initcall = ‘This.InitCallBack()’
Note: The form initialisatio n callback must not attempt to display another form. You may
invoke an ALERT  object but not otherwise seek any input from the user.
If the callback discovers an error so serious that the form cannot be displayed it can abort
the display of the form by returning an error.  You can supply the text of an error message
that is to be presented in an error alert in place of the form:
define method .initcallback()
:
return error 1 'You do not have write access to this
database'
endmethod
If the initialisation callback has already caused an alert to be raised then you can prevent
the raising of a new error alert by using the NOALERT  keyword:
define method .initcallback()
:return error 1 NOALERT
endmethod
15.3.3 Form OK and CANCEL Callbacks
The form supports the concepts of OK and CANCEL  actions:
The OKCALL  callback is executed when a form’s OK button is pressed or when the OK
button of a form’s ancestor has been pressed (see Free Forms and Form Families ).
It allows operators to approve the current gadg et settings and carry out the function of the
form. The form is then remove d from the screen. Typically th is callback will gather all the
data from the form’s gadgets and perform the form’s major task. If you do anything ofsignificance in callbacks on other gadgets you may have a hard time undoing everything ifthe user presses the CANCEL  button.
You can assign to the form’s OKCALL  member using the command
OKCALL ‘CallbackString’

--- Page 119 ---
 Software Customisation Guide
Forms
12 Series  15:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.You can modify the Okcallback  at any time using
!this.Okcall = ‘CallbackString’
The CANCELCALL  callback is executed when a form’s CANCEL  button is pressed, when the
CANCEL  button of a form’s ancestor is pressed (see section on Form Families ) or when the
window’s CLOSE  gadget is used. It allows the operator  not to proceed with the functions of
the form.
The form is then removed from the screen and all gadgets are automatically reset to the
values they had when the form was displayed or when any APPLY  button was last pressed.
Typically this callback allows you, the PML programmer, to undo any actions already carriedout on the form that ought to be undone in the light of the CANCEL  request
You can assign to the form’s CANCELCALL  member using the command
CANCELCALL ‘CallbackString’
You can modify the CANCELcallback  at any time using
!this.Cancelcall = ‘CallbackString’
See also Button Gadgets .
15.3.4 Quit/Close Callback
All Forms have a QUITCALL  member that you can pass a standard callback string. This is
executed whenever the user presses the Quit/Close  icon (X) on the title bar of forms and
the main application window.
If an open callback is used then it is called with the FORM  object as its first parameter and
‘QUIT’  as its action string. 
QUITCALL for MAIN Forms
For forms of type MAIN , the QUITCALL  callback is executed, if present. This permits the
user to terminate the application, and so the associated PML callback should prompt theuser for confirmation.
If the user confirms the quit, then the callback should close down the application, and not
return. If the user decides not to  quit, then the callback should re turn an error to  indicate the
decision to F&M. 
Use return error …noalert  if you want to avoid displaying an error alert. If the form
has no QUIT  callback, then the QUIT  event will be ignored.
The following example shows a (global) PML func tion, that you could be use from all forms
of type MAIN :
define function !!quitMain( )
-- Sharable method Quit the application 
!str = !!Alert.Confirm('Are you sure you want to quit the
application?')
if( !str eq 'YES' ) then
-- execute application termination command, which should
not return
finish

--- Page 120 ---
12 Series  15:8 Software Customisation Guide
Forms
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.else
return error 3 |user chose not to QUIT| noalert 
endif
endfunction
This would be called from the form definition function body or from its constructor method as
shown below:
Setup form !!myApplication MAIN
...
quitCall ‘!!quitMain( )’...
exit
define method .myApplication( )
-- Constructor!this.quitCall = ‘!!quitMain( )’
...
endmethod
QUITCALL for Other Forms
Essentially, if no QUIT callback is present, th en the form is cancelled (hidden with reset of
gadget values). If a QUIT callback is prov ided then you can prevent the default Cancel
action by returning a PML error, but you must hide the form from your callback method (It ismore efficient the use ‘!this.hid e()’, rather than ‘h ide !!myform‘ from yo ur form methods). 
Note: F&M does not display an alert for the returned error, it is merely for communication.
You don’t need a QUIT  callback if you just want to allow the form to be hidden. For
DOCUMENT  forms (MDI children)  only, the callback must not display an alert as
this will cause some gadgets to malfunction  afterwards.
15.3.5 FIRSTSHOWN callback
Typically assigned in the Constructor by
!this.FirstShownCall = '!this.<form_method>'
The purpose is to allow the user to carry ou t any form actions which can only be completed
when the form is actually displayed. There ar e a variety of circumstances where this arises
and it is often difficult to find a reliable solution. A couple of examples are given below.
Commands which manipulate form, menu or gadg et visual properties, executed from a PML
macro, function or callback may not happen  until control is re turned to the window
manager's event loop. For example, in th e application's start-up macro the command
sequence show !!myForm … hide  !!myform will result  in the form not be ing displayed, but
also not becoming known at all to the window manager. Attempts to communicate with thisform via the External callbac k mechanism (possibly from ano ther process) will not work.
This can be rectified by doing the '!this.hi de()' within the FIRSTSHO WN callback, because
the form will be guarant eed to be actually displayed (and hence known to the window
manager), before it is hidden.

--- Page 121 ---
 Software Customisation Guide
Forms
12 Series  15:9 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.It is sometimes difficult to achieve the correc t gadget background colour setting the first time
the form is displayed. This can be resolved by setting the required colour in theFIRSTSHOWN callback. 
15.3.6 KILLING callback
Typically assigned in the Constructor by
!this.KillingCall = ' !this.<form_method>'
The purpose is to notify the form that it is being destroyed and allow the assigned callback
method to destroy any associated resource s, e.g. global PML objects which would
otherwise not be destroy ed. This may be nece ssary because PML global objects will survive
an application module switch, but may not be valid in  the new module.
Notes:
1. The callback method MUST NOT  carry out any modifications to the Gadgets belonging
to the form or to the Form itself (e.g. don't sh ow or hide the form). Attempts to edit the
form or its gadgets may cause unwanted side effects or possible system errors.
2. Form callbacks designed for other Form events (e.g. CANCEL, INIT) are rarely suitable
as killing callbacks.
3. Restrict form and gadget operations to querying.
15.3.7 Form Variables: PML Variables within a Form
It is often convenient to store additional inform ation on a form which will not be displayed to
the user. This is achieved by defining form variables . 
These are variables which can be any of the PML data types, including ARRAYS  and
OBJECTS . These variables have the same lifetime as the form and are deleted when the
form itself is killed. 
Form members are defined in just the same way as object members:
setup form !!MyForm...
:
member .MyNumber is REAL
member .MyString is STRINGmember .MyArray is ARRAY
:
exit
The value of a form member can be set and used in just the same way as an object
member:
!!MyForm.MyNumber = 42
!Text = !This.MyNumber
!ThirdValue = !This.MyArray[3]
In a callback function you can use !this.  to represent 'this form':
!ThirdValue = !This.MyArray[3]

--- Page 122 ---
12 Series  15:10 Software Customisation Guide
Forms
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.15.3.8 Querying Form Members
You can query the members of a form using the command:
q var !!formname
This will list all the attributes of  the form, and all the gadgets def ined on it. This is a useful
debugging aid.
To query all the gadgets of a form (excludes USERDATA  gadget) use:
!!gadgetsarray = !!MyForm.gadgets()
Returns array of GADGET .
15.4 Loading, Showing, and Hiding Forms
15.4.1 Free Forms and Form Families
Forms are displayed on the screen either as free-standing forms  or as a member of a
form family .
A form can be displayed as a free standing form, for example by show !!form free . It
then has no parent so it will not disappear when  the form which caused it to be displayed is
hidden. 
When one form causes another form to be displayed, such as when a button with the FORM
keyword is pressed or a gadget callback executes a show !!form  command the result is a
child form . 
A form can have many child forms (and grand-children …) but a child form has only one
parent - the form which caused the child form to be displayed. The nest of related forms is
called a Form Family. 
The Form Family exists just as long as the forms are displayed. If a form is already on the
screen when it is shown, it is brought to the fr ont of the display. If the child form is already in
a Form Family it is transferred to the new parent.
If the user presses the OK button of a parent form, the system in effect presses the OK
buttons on each of the child forms, 'youngest' first, invoking their OKCALL  callbacks. The
parent form and all child-forms are hidden and the Form Family then ceases to exist. 
If the user presses the CANCEL  button or uses the window's CLOSE  controls, the system
in effect presses the CANCEL  buttons of each of the child forms, 'youngest' first, invoking
their CANCELALL  callbacks, and all the forms in the Form Family are hidden.
The action of RESET  and APPLY  buttons does not affect family members.
15.4.2 Loading and Showing Forms
A form definition must be loaded before the form can be displayed.
If you have saved the definition in a .pmlfrm  file then loading will be automatic when the
form is displayed for the first time.
Note: Earlier AppWare used form definitions in ma cro files which had to be loaded explicitly
via $m path-name . This mechanism still operates fo r backwards compatibility, but is
strongly discouraged when writing new AppWare.

--- Page 123 ---
 Software Customisation Guide
Forms
12 Series  15:11 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Normally, a form is displayed as a result of the operator making a menu selection or
pressing a button on a form. This is achieved either by using the Form  directive in the menu
or button definition or by means of the command:
show !!formname
used in the gadget’s callback. In either case the form becomes a child of the menu’s orgadget’s owning form.
A form may be displayed free-standing, i.e. not as a child, by:
show !!formname free
Sometimes it is useful to force the loading of a form’s definition file before the form is
actually displayed, so that you can edit the form or gadget attributes from another form’s
callbacks before the form is actually displayed. Using the command:
loadform !!formname
from a callback will force load  the definition if the form is unknown to PML, but do
nothing if the form has already been loaded.
If you are sure that a form’s definition has been loaded then you can show the form as a
child or free-standing respectively using the form methods:
!!formname.show( )
!!formname.show( ‘free’ )
but note that this will not dynamically load the form definition.
15.4.3 Position of Forms on the Screen
Mostly forms are automatically positioned by t he system according to their type and the way
they are shown.
The origin  of a form is its top left hand corner.
When a form is displayed as a child form then it is always  positioned with respect to its
parent. 
For a form shown from a MENU , its origin is at the origin of the parent. If the form is
displayed from a BUTTON  or any other gadget, its origin is at the centre of the gadget.
When a form is shown as a free form for the first time then it s default position is at the top
left-hand corner of the screen.
We strongly recommend that you allow the system to position forms whenever
possible.
You can force the screen position of free-standing forms using the following commands or
methods:
show !!MyForm Free At xr 0.3 yr 0.5
show !!MyForm Free Centred xr 0.5 yr 0.5!!MyForm.show( 'At', 0.3, 0.5 )!!MyForm.show( 'Cen', 0.5, 0.5 )
The At option puts the origin of the form at the specified position; alternatively the Cen
option puts the centre of the form at the given position. The co-ordinate values are fractions
of the screen width or height respectively and are referred to as screen co-ordinates .
For example:

--- Page 124 ---
12 Series  15:12 Software Customisation Guide
Forms
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.show !!MyForm free At xr 0.25 yr 0.1
positions the origin of !!MyForm  one quarter of the way across from the left edge of
the screen, and one tenth of the way down from the top.
!!MyForm.show( 'Cen', 0.5, 0.5 ) 
centres !!MyForm  at the middle of the screen.
15.4.4 Hiding Forms
The recommended way for a form to be removed from the screen is for the user to press a
button with the OK or CANCEL  attribute. 
Forms may also be cancelled by using the window’s close controls . Both these
mechanisms will remove the form and any of its children executing their OK or CANCEL
callbacks appropriately.
Sometimes it is required to hide a form and other forms which are functionally associated
but not part of the form family or as a result of a button press on a form you may want to hide
other associated forms but not the form whose button was pressed. The hide  command or
method allows this:
hide !!MyForm
!!MyForm.hide()
Note: When you explicitly hide a form in this way its gadgets will be reset to their values at
display or at the last APPLY , just like a CANCEL  action, but the CANCELCALL
callbacks for the form and its nest will not be applied. This me ans that before you
execute the hide  you should use any pertinent data from the forms to be hidden.
15.4.5 Killing Forms
You can destroy a loaded form definition using the command
kill !!MyForm
The form is hidden and then its definition is de stroyed so that it is then no longer known to
PML. You cannot then access the form or its gadgets, members or methods (including its.show()  method.
Normally you will not need to include the kill command within your AppWare.If you re-show the form using the show  command then the syst em will attempt to demand
load the definition again. This is slow and expe nsive if you haven’t modified the definition so
avoid it: use loadform !!MyForm  and !!MyForm.show()  instead.
If you execute a setup form !!MyForm...  while the form !!MyForm  already exists then
it is killed and a new definition is started. Th is mechanism may be usef ul because it makes it
possible to generate a form definition in teractively from within your AppWare. 
This can be very powerful but should be used with great care.
15.4.6 NOQUIT Form Status
You can stop forms from being hidden from th e border close/quit pull-down menu by setting
the NOQUIT  attribute:
Setup form !!MyForm  . . .  NOQUIT

--- Page 125 ---
 Software Customisation Guide
Forms
12 Series  15:13 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.By default, you can quit from any user-defin ed form, except for the current system Main
form.
15.5 CORE Managed Forms
Core managed forms are shown and hidden by  core-code actions and cannot be ‘killed’ by
PML AppWare. See Form Core Support .

--- Page 126 ---
12 Series  15:14 Software Customisation Guide
Forms
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 127 ---
 Software Customisation Guide
Menus
12 Series  16:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.16 Menus
Menus are always members of forms but can be employed in various ways by the form and
its gadgets.
Menus come in two types: main menus and popup menus. You determine what type a menu
is when you create it. If you do not specify th e type, then the system will try to infer its type
from the context of its first use.
For example, if the first action in a form definit ion is to define the menubar, then the system
will infer any menus re ferenced in the bar…exit  sequence to be of type MAIN .
Or, as a second example, if a menu is assigned  as the popup for the form or a gadget of the
form, then the system will infer the menu to be of type POPUP .
16.1 Menu Types and Rules
Forms may have a bar menu gadget or main menu, which appears as a row of options
across the top of the form. When you select one of the menu options, a pull-down  menu is
temporarily displayed. Fields on a menu may have pull-right arrows (>) that open a pull-down sub-menu when selected.
Forms and gadgets can have popup menus assigned to them. When you move the cursor
onto them and press the mouse popup button, the menu pops-up at the cursor and you canthen select from the displayed options.
The following rules determine how you can use menus:
• Each menu belongs either  to the Main menu system  or to the Popup menu system ,
but cannot  belong to both .
• A menu in the Main system can appear only once. i.e. it cannot  be a sub-menu of
several menus.
• A menu in the Popup system may appear only once  in a given popup tree, but may be
used in any number of popup trees.
• A menu cannot reference itself , either directly as a pullright of one of its own fields or
be a pullright of another menu in its own menu tree.
• Any pullright field of a menu  references a sub-menu that will be infe rred to be of the
same type as the referencing menu.
16.1.1 Hints and Tips for Using Menu Types
In general:
• It is not necessary to specify the menu usage type on a form that has only main menus
(and this includes most Main forms).
•I t  is always  necessary to specify the usage-type for menus that are part of the POPUP
menu system.

--- Page 128 ---
12 Series  16:2 Software Customisation Guide
Menus
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.For forms that contain a mixture of main and popup menus:
• First define the bar before defining the menus.
• Next define the menus of the main system.• Next define menus of the popup sys tem, declaring them all as type POPUP .
• If you are dynamically creating new menus with the NewMenu()  form methods, then
always specify the menu type. This will maximise  the system’s chance of alerting you to
any errors.
16.1.2 Core-Code Based Menus
AVEVA developers can define core managed PML menu fields.  See Form Core Support .
16.2 Defining a Bar Menu Gadget
A bar menu is defined within a form defi nition. The menu bar is created with the bar
subcommand. Note that its name is ‘bar’: there can be only one bar menu on a form. Then
you can use the bar’s Add()  method to add the options. For example:
setup form !!MyForm Dialog size 30 5
bar
!this.bar.add ( 'Choose', 'Menu1')!this.bar.add ( 'Window', ' ' )
!this.bar.add ( 'Help', ' ' )
exit
This code specifies the text  of three options labelled Choose , Window , and Help .
Figure 16:1. A Simple Menu
•T h e  Choose  option when picked will open Menu1  as a pull-down (assuming you have
defined Menu1 ).
Note: That Menu1  need not exist when the bar is defined , it can be defined later in the form
definition, but it mu st exist before the Choose  option is selected or an error alert will
be raised.
•T h e  Window  and Help  options will open the Window  and Help system menus
(described later in  this chapter).


--- Page 129 ---
 Software Customisation Guide
Menus
12 Series  16:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.16.2.1 Defining a Menu Object
A menu is a set of menu fields, each representi ng an action that is invoked when the field is
selected. The fields’ display text  indicates to the user what the actions are, and the fields’
replacement text  defines what the actions are.
Within the form definition a menu obj ect can be created using the form’s NewMenu  method
or the menu  sub-command. You can then use the menu’s Add() , InsertAfter() , and
InsertBefore()  methods to add or insert named me nu fields. A menu field can do one of
three things: 
• Execute a callback.
• Display a form.• Display a sub-menu.
You can also add a visual separator between fields.
Below is an example of a complete menu definition:
!menu = !this.newmenu( 'file', ‘main’ )
!menu.add( 'MENU', 'Send to', 'SendList', 'SendTo' )
!menu.add( 'SEPARATOR', 'saveGroup' )
!menu.add( 'CALLBACK', 'Save', '!this.SaveFile()', 'Save' )
!menu.add( 'FORM', 'Save as...', 'SaveFile', 'SaveAs' )!menu.add( 'SEPARATOR' )
--core-code managed field for Explorer Addin, ticked. 
--Note no Rtext needed
!menu.add( 'CORETOGGLE', 'Explorer', '', 'Expl' ) 
!menu.add( 'MENU', 'Pull-right1', 'Pull1')
--initialise toggle field as ticked (typically in the
constructor)
!menu.SetField( 'Expl', 'Selected', true )
This creates a new main menu called Menu  with six fields and two separators between
them. For example:
•T h e  SAVE  field when picked will exec ute the callback command this.SaveFile().
•T h e  Save as...  field when picked will load and display the form !!SaveFile . By
convention, the text on a menu fi eld leading to a form ends with three dots , which you
must include with the text  displayed for the field. 
•T h e  SEPARATOR , usually a line, will appear after the previous field.
•T h e  Pull-right1  field when picked will display the sub-menu !this.Pull1  to its right. A
menu field leading to a sub-menu  ends with a > symbol : this is added automatically.
Named Menu Fields
You can add menu fields with an optional fieldname  that you can later re fer to when editing
the menufield or modifying its attributes ’. If you do not specify a field name then you will not
be able to refer to the field again. You can also assign a name to separator fields, whichallows separator group editing.
The general syntax is:

--- Page 130 ---
12 Series  16:4 Software Customisation Guide
Menus
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!menu.Add( ‘<FieldType>’,’ <Dtext>’, ‘<Rtext>’, { ‘<FieldName>’
} )
!menu.Add( ‘SEPARATOR’, { ‘<FieldName>’ })
Where the fields have the following meanings:
16.2.2 Window Menu
You can add the system Window  menu to a bar menu using:
!this.bar.add (‘<Dtext>’, ‘window’)
This menu is dynamically created on use with a list of the titles of the windows currently
displayed as its fields. Selecting a field will po p that window to the front. This can be very
useful on a cluttered screen.
16.2.3 Online Help Menu
You can add the system Help  menu with the specified display text to a bar menu using
!this.bar.add (‘Dtext’, ‘Help')
!this.bar.InsertAfter(‘window’, ‘<Dtext>’, ‘Help’)Field Description
<FieldType> has allowable values: ‘CALLBACK’ , ‘TOGGLE’ ,
‘MENU’ , and ‘FORM’ . 
<Dtext> is the display-text for the field (cannot be null or
blank). May contain multi-byte characters.
<Rtext> is the replacement-text for the field. 
A null string indicates no replacement-text. The
allowable values for RTEXT  for the different field
types are:
‘CALLBACK’  - callback string
‘TOGGLE’  - callback string
‘MENU’  - menu name string (without preceding ‘.’).
It cannot be blank.
‘FORM’  - form name string (without preceding ‘!!’). It
cannot be blank.
<FieldName> is an optional argument, which, if present, is the
unique field name within the menu.

--- Page 131 ---
 Software Customisation Guide
Menus
12 Series  16:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.When selected, this Help  option displays a system-help pull-down menu that gives access
to the application help system. The fields are:
You can access On Window help  by pressing the F1 key while the form has keyboard
focus, or by including a Help  button in the form’s definition.
Note: By convention, the help menu should be the last one defined for the menu bar, which
will ensure that it ap pears at the right-hand  end of th e menu bar.
16.2.4 Popup Menus
You can use any of your defined menus as po pup menus for most interactive gadgets and
for the form background as long as you have specified them as belonging to the popupmenu system.
When the cursor is moved over it with t he popup mouse button pressed down, and then
released, the menu will be displa yed, and you can select fr om it in the normal way.
A popup is added to a gadget or form using its Setpopup()  method, with the popup menu
as the argument to the method. Note th at the menu pop1 must exist when the Setpopup()
method is executed. 
For example:
setup form !!MyForm resizable
menu .pop1 popup
!this.pop1.add( 'MENU', 'Options', 'optionmenu' )
!this.pop1.add( 'MENU', 'More', 'moremenu' )!this.pop1.add( 'MENU', 'Last', 'Lastmenu' button .b1 ...
. . .
!this.b1.setpopup( !this.pop1 ). . .
exitField Description
Contents This displays the Help  window so that you can find
the required topic from the hierarchical contents list.
Index This displays the Help  window with the Index  tab
selected, so that you can browse for the topic youwant to read about from the alphabetically-arrangedlist. You can locate topics quickly by typing in thefirst few letters of their title.
Search This displays the Help  window with the Search  tab
at the front so that you can find all topics containingthe keywords you specify.
About To see the product version information.

--- Page 132 ---
12 Series  16:6 Software Customisation Guide
Menus
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.16.2.5 Finding Who Popped up a Menu
You can find out whether a menu was popped up from a gadget, and if so, the gadget’s
name. The method is:
!menu.popupGadget() is GADGET
If the menu was a popup on a gadget then the returned GADGET  variable is a reference to
the gadget. If the menu was popped up from a pulldown-menu or from a popup on the formitself, the value is UNSET . 
Example:
!g = !menu.popupGadget()
if !g.set() then
!n = !g.name()$p menu popped up by gadget $!n
else
!n = menu.owner().name()$p menu popped up by form $!n
endif 
16.2.6 Toggle Menus
A menu TOGGLE  field is a menu field with a callback ac tion and a tick-box to show that the
field has been selected or unselected.
By default the field will be unsel ected so the box will not be ticked. When picked the fields
callback action will be execut ed and the tick-box ticked.
If you pick the field again the callback acti on will again be executed and the tick removed.
Note that the open callback is an obvious candidate for toggle menus as the SELECT  or
UNSELECT  action is returned as the second argument to the callback method. See PML
Functions and Methods
For example, in your form definition  you can add a toggle field as follows:
setup form !!Myform Dialog size 30 5
. . .
!menu = !this.newmenu(‘Test’, ‘popup’)!menu.add( 'Toggle' ,’Active/Inactive’, '!this.toggle(‘,
'OnOff' )
. . .
exit
. . .
define method .toggle( !menu IS MENU, !action IS STRING )
!name = !menu.fullname()

--- Page 133 ---
 Software Customisation Guide
Menus
12 Series  16:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!field = !menu.PickedFieldName
$P menu $!name $!action field: $!field
endmethod
Note: How we use the PickedFieldName  member of the menu object to obtain the last
picked field.
If you pick this menu field the callback method will print:
menu !!MyForm.Menu1 SELECT field: OnOff
16.3 Editing Bars and Menus
The contents of menu bars and menus can be modified at any time using the members and
methods of the bar menu gadget object and the menu object.
16.3.1 Inserting Menus into a Bar
You can insert new fields into a menu bar using the InsertBefore()  and
InsertAfter()  methods, which insert the new fields  relative to existing named menus.
The methods use named menus to determine the point where they should insert the newmenu.
The general syntax is:
InsertBefore(<TargetMenuName>, <Dtext>, <MenuName>)
InsertAfter(<TargetMenuName>, <Dtext>, <MenuName>)
Where the fields have the following meanings:
For example:
setup form !!MyForm Dialog size 30 5
bar-- adds a pulldown for menu1 labelled with <dtext>!this.bar.Add( ‘<dtext>’, ‘menu1’ )
-- adds a window pulldown labelled with <dtext>
!this.bar.Add( ‘<dtext>’, ‘Window’ )-- adds a help pulldown labelled with <dtext>
!bar.InsertAfter( ‘Window’, ‘<dtext>’, ‘Help’ )
...Field Description
<TargetMenuName> is the name of the menu immediately before or after
where you want the new menu to go.
<Dtext> is the display-text for the menu.
<FieldName> is the unique name for the menu within the bar.

--- Page 134 ---
12 Series  16:8 Software Customisation Guide
Menus
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.exit
If you use the identifier ‘ Window’  or ‘Help’  as the name of th e menu, the system will
interpret them as system Window  and Help  menus, although they  will still be displayed with
the string given in <dtext> .
Named menus and the methods that create them  are discussed in more detail in the rest of
this section.
16.3.2 Inserting New Menu Fields
You can insert new fields  into a menu using the InsertBefore()  and InsertAfter()
methods, which insert the new fields relative to existing named menu fields.
The methods use named menu fiel ds to determine the point where they should insert the
new field.
The general syntax is:
InsertBefore(<TargetFieldName>,<FieldType>,<Dtext>,<Rtext
>,{<FieldName>})
InsertBefore(‘SEPARATOR’,{<FieldName>})
InsertAfter(<TargetFieldName>,<FieldType>,<Dtext>,<Rtext>
,{<FieldName>})
InsertAfter(‘SEPARATOR’,{<FieldName>})
Where the fields have the following meanings:
Field Description
<TargetFieldName> is the name of the field immediately before or after
where you want the new field to go.
<FieldType> has allowable values: ‘CALLBACK’ , ‘TOGGLE’ ,
‘MENU’ , and ‘FORM’ .
<Dtext> is the display-text for the field (cannot be null or
blank). May contain multi-byte characters.
<Rtext> is the replacement-text for the field. A null string
indicates no replacement-text. The allowable valuesfor RTEXT  for the different field types are:
‘CALLBACK’  - callback string
'TOGGLE’  - callback string
‘MENU’  - menu name string (without preceding ‘.’).
It cannot be blank.
‘FORM’  - form name string (without preceding ‘!!’). It
cannot be blank.
<FieldName> is an optional argument, which, if present, is the
unique field name within the menu.

--- Page 135 ---
 Software Customisation Guide
Menus
12 Series  16:9 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.16.3.3 Changing the State of Menufields
There are two methods you can use to set and read the status of menu- and menu-field
properties.
Setting Menu-Options’ Status
You can de-activate a menufield on a m enu bar and a field in a menu with the
SetFieldProperty()  so that it cannot be selected. Similarly, you can make them
invisible so the user cannot see them.
You can also use SetFieldProperty()  to hide a menu field and to select or unselect
toggle-type fields.
The general syntax is:
!menu.SetFieldProperty (<FieldName>, <PropertyName>, Boolean)
Where the fields have the following meanings:
Note: The property names may optionally be truncated to the first three characters ‘ ACT’ ,
‘VIS’, and ‘ SEL’ .
For example:
!bar = !!MyForm.bar
!menu = !!MyForm.Menu1
sets local variables !bar and !menu  to be references to the bar gadget and Menu1  of
form !!MyForm .
Then
!bar.SetFieldProperty( 'Foo', ‘ACTive’, false)
will grey-out the menufield on bar that has the field-name “ Foo”. And
!menu.SetFieldProperty ( 'Bar', ‘ACTive’, true)
will activate the menufield on Menu1  that has the field-name “ Bar”.
You can use the same method to change the selected status of a toggle menu field.Field Description
<FieldName> The name of the field you want to change.
<PropertyName> The name of the property you want to change in the
named field. The allowed values are:
‘ACTIVE’  - greyed in or out
‘VISIBLE’  - visible or invisible
‘SELECTED’  - selected or unselected (toggle type
fields, only. Specifically, this value cannot be usedwith bars).
Boolean The value, TRUE  or FALSE , for the property.

--- Page 136 ---
12 Series  16:10 Software Customisation Guide
Menus
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Reading the Status of Menus and Menus’ Fields
To read the status of a menu or of a menu-field property, you can use the
FieldProperty() method.
The general syntax is:
Boolean = !menu.FieldProperty (<FieldName>, <PropertyName>)
Where the fields have the following meanings:
Note: The property names may optionally be truncated to the first three characters ‘ ACT’ ,
‘VIS’, and ‘ SEL’ .
For example:
!bar = !!MyForm.bar
sets local variable !bar to be a reference to the bar gadget of form !!MyForm .
Then
!isSet = !bar.FieldProperty( 'Foo', ‘ACT’)
will get the greyed-o ut status of the menufield on bar that has the field-name “ Foo”.
You can use the same method to change the selected status of a toggle menu field.
16.3.4 Implied Menu-field Groups
A separator field and all following fields up to but not including the next separator field
implies a menu-field group . You can modify the ACTIVE  and VISIBLE  properties of all
fields in the group, by reference to its separator name.
For example, for the menu:
!menu = !this.newmenu( 'file', 'Main' )
!menu.add( 'MENU', 'Send to', 'SendList', 'SendTo' )
!menu.add( 'SEPARATOR', 'SaveGroup' )
!menu.add( 'CALLBACK', 'Save', '!this.SaveFile()',
'Save' )
 menu.add( 'FORM', 'Save as...', 'SaveFile', 'SaveAs' )
!menu.add( 'SEPARATOR', 'explGroup' )
!menu.add( 'FORM', 'Explorer...', 'ExplFile', 'Expl' )Field Description
<FieldName> is the name of the field you want to change.
<PropertyName> is the name of the property you want to change in the named
field. The allowed values are:
‘ACTIVE’  - greyed in or out
VISIBLE’  - visible or invisible
‘SELECTED’  - selected or unselected (toggle type fields, only.
Specifically, this value cannot be used with bars)

--- Page 137 ---
 Software Customisation Guide
Menus
12 Series  16:11 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Executing the method
!menu.SetField( 'saveGroup', 'visible', false ) 
will make the all the fields invisible for the gr oup currently implied by the separator field
‘SaveGroup’ , i.e. the fields SaveGroup , Save  and SaveAs .
The combination of named SEPARATOR  fields, insertion and fi eld group visibility will be
useful for managing the sharing of menus between co-operating sub-applications. Thisfacility should be used with great care.
16.3.5 Creating Menus Dynamically
You can create new menus from within your appware dynamically using the form methodNewMenu() .
For example, you could equip your form with the methods popupCreate()  and
popupAction()  which would allow you create and service a popup menu from an array of
strings.
Executing !this.popupCreate(‘NewPopup’, !fieldArray)  will create a new popup
menu and assign it to the form.
define method .popupCreate( !name is STRING, !fields is ARRAY )
--!fields is an array of field name strings
!menu = !this.newmenu( !name, ‘popup’ )--add all the fields with same open callback
do !n from 1 to !fields.size()
!menu.add( 'Callback', !fields[!n], '!this.menuAction(' )
enddo
-- assign the new menu as the form’s popup menu
!this.setpopup( !menu )
endmethod
define method .popupAction( !menu is MENU, !action is STRING )
-- General popup menu action routineif ( !action eq ‘SELECT’ ) then
!name = !menu.fullname()
!field = !menu.pickedField-- execute application actions according to the field
selected
$P selected field $!field of menu $!name
...else
-- execute applications for unselected field (toggle)
...
endif
endmethod

--- Page 138 ---
12 Series  16:12 Software Customisation Guide
Menus
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 139 ---
 Software Customisation Guide
Form Layout
12 Series  17:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.17 Form Layout
The Form Layout section explains how to lay gadgets out on a form. It is an essential that
you have read Defining a Form  first.
17.1 System Font and Unicode characters
F&M  supports a system font  which provides the character representations used within any
forms, gadgets and menus which you define. This system font has variable width characters
(referred to as VarChars ), so different characters may have different widths. A notional
character width  for the font is also supported. This is a sort of average width (usually the
width of upper-case X), and provides a rough gui de to the width of a text string as (number
of characters X notional width).
The recommended system font also supports ma ny of the World's char acter sets, so forms
can be designed to use non-English characters, and even to mix different languages on thesame form. In order to achieve this PML and F&M now use the Unicode  standard as their
internal character format.
17.2 Layout Modes
Two layout modes are supported, namely VarChars and FixChars.
VarChars  is a new layout mode, based on measuring precise string widths. It is better
suited to the use of variably spaced fonts,  and removes the need for most uses of the
TagWidth specifier. The bene fits of using VarChars are:
• It tends to produce smaller, more pl easing forms, without unwanted space.
• No text wrap-around, except poss ibly in conjunction with TagWidth.
• No truncation of explicitly defined text ex cept possibly in conjunction with TagWidth.
The recommended layout mode for all new forms is:
setup form !!formname . . .  VarChars
FixChars  is the old layout mode (prior to PDMS12.1), which is based on the use of notional
character width  to calculate the (approx.) sizes of textual gadgets and gadget tags.
Because the calculated sizes are only approximat e the user has to make frequent use of the
gadget's Width specifier and TagWidth specifier and considerable trial and error to achieve a
desired layout.
The default layout mode  for setup form is FixChars, because this will be the least
disruptive for existing user Appware, so FixChars mode will cu rrently result from either of
setup form !!formname . . .
setup form !!formname . . . FixChars

--- Page 140 ---
12 Series  17:2 Software Customisation Guide
Form Layout
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.See the FMSYS object method
!!FMSYS.SetDefaultFormLayout(layout is STRING)
that allows users to change the default layout mode for Setup form . This can be used to
help test any existing appware which is using setup form !!formname . . . , in either
mode to determine which forms need layout adjustment.
17.2.1 Future Change to VarCha rs as Default Layout Mode
The intention is to change the recommended la yout mode to be VarChars at a subsequent
PDMS release. 
It is probable that this will be ac hieved by introducing the alternative,  optional, form definition
syntax
Layout form !!<form_name> . . . exit
This will ensure VarChars mode  (and NoAlign) by default. 
17.3 Containers, Grid Co-ordinates and Gadget Boxes
The Form and its Frame gadgets act as containers  for holding gadgets. Typically gadgets
are laid out in their containers from left to right and from top to bottom. Each container has arectangular co-ordinate grid with origin (0, 0) at the top at the top left-hand corner.
Each gadget has an origin  at its top left-hand corner and a width  and height , which
together define a notional gadget box , which contains the gadget including its tag-text if
defined. Layout involves positio ning each gadget, by its origin, at a specified position within
the grid of its container and indicating its width and height.
• The grid horizontal pitch is the notional character width for the system font. Because
this font is variably spaced, n horizontal grid units do not  equate to n characters.
Generally, it is more than n unless the string has a high proportion of wide characters
e.g. capitals, numerals, w's, m's etc. It is important that you understand this concept
when you specify gadget sizes.
• The grid vertical pitch is the line-height , which is the height of the tallest of the textual
gadgets: TOGGLE, BUTTON, OPTION, TEXT or single-line PARAGRAPH.
Figure 17:1. Conceptual X and Y Coordinates
For the Form  container its extremities are referred to as XMIN form , YMIN form , XMAX
form  and YMAX form . 
The extremities of a gadget box are referred to as XMIN.gadget , YMIN.gadget ,
XMAX.gadget  an YMAX.gadget .01234567890
1
23
4
5
6
7
YX1 character width per unit
1 line height per unit

--- Page 141 ---
 Software Customisation Guide
Form Layout
12 Series  17:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Figure 17:2. Gadget Box Extremities
When new gadgets are added to a container, the XMAX  and YMAX  extremities grow to
include the gadget boxes.
17.4 Positioning, Alignment and Size of Gadgets
We strongly recommend that you lay out your form using auto-placement  in combination
with relative placement  and use the NoAlign  keyword.
Note: This is vital because it allows gadgets  to be added, removed, and repositioned,
without having to adjust the geometry of all the other gadgets on the form.
Auto-placement  chooses a gadget's position coordinate  automatically rela tive to the last
placed gadget.
Relative placement  uses the AT syntax to specify a ga dget's position coordinate relative to
a previously placed gadget.
NoAlign  switches off the default approximate centre-alignment of the gadgets TEXT,
OPTION, COMBO, TOGGLE and si ngle line PARAGRAPH for path right and path left, which
interferes with Auto-placement.
A gadget's size component , width or height, is either a literal value, or a previous gadget's
size component, or an extension to a previous  gadget's co-ordinate limit, i.e. min or max.
The last option, referred to as sizing to Positional Extent , uses the width to…  and height
to… syntax. This makes it much simpler to lay out complex and resizable forms.
The following example form demonstrates layout of a simple, fixed size dialog form using
the VarChars  layout mode. Each gadget's position is  set within the gadget definition either,
implicitly using auto-placement , or using the AT syntax. Gadget sizes are set implicitly, or
relative to the size of other gadgets or to the positional extents of other gadgets.


--- Page 142 ---
12 Series  17:4 Software Customisation Guide
Form Layout
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Figure 17:3. Form definition using the VarChars  layout mode
Note: No actual co-ordinate positions are requ ired to specify this form. It is mostly
undesirable and unnecessary to specify a gadget's position as absolute grid co-ordinates, e.g. at x 12, y 5; we reco mmend defining the layout of each gadget
relative  to a predecessor. This allows simple editing of the layout, without having to
calculate new positions. There are exceptio ns, for example, for the first gadget in a
form or frame, where you may want to establis h an initial x or y co -ordinate that is not
at the default position.
Here is the corresponding PML code for the form: usingVarChars.pmlfrm . The 'layout'
keywords are emboldened and explained later in the chapter.


--- Page 143 ---
 Software Customisation Guide
Form Layout
12 Series  17:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.17.5 Auto-placement
Auto-placement  uses the PATH , DISTANCE  and ALIGNMENT  commands, which have the
following meanings:
Relative placement  means specifying the new gadget position by reference to the
extremities  of a previously defined gadget.
It is also possible to position gadgets using ex plicit form coordinate s, but this is rarely
necessary. Refer to Absolute Gadget Positioning .setup form !!usingVarChars  dialog Varchars NoAlign
$*-- layout form !!usingVarChars  dialog
title |Form !!usingVarChars|
path down
paragraph .para1 text 'Simple form layout using VarChars'frame .frame1 |frame1: See my gadgets|
paragraph .para2 text 'text positioned implicitly in frame1'frame .frame2 |frame2: path right|
toggle .tog1 |BBC news 24|path righttoggle .tog2 |BBC 1|toggle .tog3 |BBC 2|path downvdist 0frame .frame3 |frame3: path down, vdist 0| at xmin.frame2
width to max.frame2
-- path down, vdist 0 gives minimum vertical spacing
rtoggle .rad1 |ClassicFM| at xcen.frame3 - 0.5 * sizertoggle .rad2 |Caroline|rtoggle .rad3 |BBC Radio 2|
exit
exit
exitbutton .cancel |CANCEL| at xmin form CANCEL
path rightbutton .ok |OK| at xmax form-size  OK
exit
PATH The direction in which the next g adget origin will be placed relative
to the previous gadget.
DISTANCE The distance increment between gadgets along the current path. 
ALIGNMENT Specifies how the next gadget aligns to the previous one for the
current path.

--- Page 144 ---
12 Series  17:6 Software Customisation Guide
Form Layout
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.17.5.1 Positioning Gadget s on a Defined Path
The path along which gadgets are to be added, is set using a PATH  attribute: Usually PATH
right  or PATH up , occasionally PATH left  or PATH down .
The default  direction is PATH right . The current path direction is set until you give a
different PATH  command.
17.5.2 Setting the Auto-displacement between Gadgets
To specify the horizontal and vertical di splacement between adjacent gadgets, use the
HDISTANCE  and VDISTANCE  keywords, respectively. 
The default  displacements are HDIST 0.2 grid units, VDIST 1.0 grid units.
Note that these specify clearance distances  between gadgets (for example, the distance
between the XMAX  of one gadget and the XMIN  of the next), not the distance between
gadget origins, thus:
Figure 17:4. Distances Between Gadgets
17.5.3 Gadget Alignment
To specify horizontal and vertical alignments " of adjacent gadgets, use the HALIGN  and
VALIGN  commands, respectively. The options are:
HALIGN left, HALIGN centre, HALIGN right
VALIGN top, VALIGN centre, VALIGN bottom
For the default PATH right  the alignments are HALIGN left  and VALIGN top .
17.5.4 How It All Works
The position of a new gadget relative to the preceding one depends on the combination of
the current path, distance increment and alignment.
For horizontal paths, LEFT  and RIGHT , the HDIST  and VALIGN  apply.
For vertical paths, UP and DOWN , the VDIST  and HALIGN  apply.
The following diagram shows the valid alignment settings for paths Right, Left, Down and
Up, with clearance distances D grid units in each direction.  .GADG1   .GADG2
  .GADG3HDIST ANCE
VDIS T ANCE

--- Page 145 ---
 Software Customisation Guide
Form Layout
12 Series  17:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Figure 17:5. Effect of Path and Alignment Settings
Combinations of path, distance and alignment commands allow you to set up correctly
aligned rows and columns of gadgets without th e need to calculate any grid coordinates. 
For example, the following command sequence gives the layout shown in Figure 17:6.:
Example Layout of Gadgets :
button .But1
PATH down$* default placement
HALIGN centreVDIST 2
paragraph .Par2 width 3 height 2
$* auto-placed
toggle .Tog3 $* auto-placed
PATH right
HDIST 3.0
VALIGN bottom
list .Lis4 width 2 height 3 $* auto-placed
PATH up
HALIGN right
paragraph .Par5 width 3 height 3 $* auto-placed 
PATH 
PATH VALIGN top 
last
next D 
last next D 
PATH HALIGN left 
PATH 
last next 
D 
last next 
D 
last next 
D 
last next 
D last 
next D last 
next D last 
next D last 
next D last 
next D last 
next D last 
next D last 
next D VALIGN bottom 
lastnext 
D 
HALIGN right 
last
nextD 
lastnext
D last nextD VALIGN centre
HALIGN centrelast next
D 
last nextD
last
nextD 
lastnext
D 

--- Page 146 ---
12 Series  17:8 Software Customisation Guide
Form Layout
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Figure 17:6. Example Layout of Gadgets
17.5.5 Default Positions in Gadget Containers
For a Form  the default position of first gadget is at the form’s grid origin (0,0). 
For a Frame , the default position of the first gadget within a frame depends on the current
settings of PATH , HDIST  and VDIST . The frame's tag name (if specified) is positioned on the
top border HDIST from the top-left-hand corner . The first gadget is placed at the position
(HDIST/2, VDIST/2). A similar offset is allow ed at the right hand side and the bottom, before
the frame's bounding box. 
17.6 Relative Placement using the AT-syntax
Refer to AT Syntax  for the complete AT syntax graph.
17.6.1 Positioning Relati ve to a Previous Gadget
To specify the position of a new gadget relative to an extremity of the last placed  gadget,
use the AT keyword as follows:
toggle .OnOff AT XMIN YMAX+1
This positions the origin of th e new toggle gadget with respect to the extremities of the last-
created  gadget (indicated by the absence of an explicit gadget name in the AT command).
The new gadget’s origin is at the coordinates ( XMIN , YMAX+1 ) of the last gadget:
Figure 17:7. Positioning Relative to Specific Previous Gadgets .But1 
.Par2 .Par5 
.Tog3 .Lis4 The gadgets are created in numeric order with the 
arrow direction showing the current path when each new gadget was placed (down, down, right, up).  
The arrow positions show the current alignment 
when each gadget was placed (centre, centre, bottom, right). 
 0 1 2 3 4 5 6 7 8 9 0 
1 
2 
3 4 
5 
Y X 
XMIN YMAX
6 
new  toggle gadget YMAX+1previously-created gadget used as 

--- Page 147 ---
 Software Customisation Guide
Form Layout
12 Series  17:9 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The command
toggle .OnOff AT XMIN gadget1 YMAX gadget1+1
positions a new gadget relative to extremities of the previous gadget gadget1 . The effect is
similar to that illustrated above.
toggle .OnOff AT XMIN gadget1-2 YMAX gadget1+1
positions the new gadget to the left of gadget1  as the specified X offset is negative.
Figure 17:8. Newly Placed Gadget
Note: The new gadget need not be adjacent to the referenced gadget. You can omit the X
or Y co-ordinate. The co-ordinates can be set relative to different previous gadgets.
17.6.2 Positioning Relative to the Form Extremities
You can also position a new gadget relative to the current  size of the form, and the current
size of the gadget.
For example, if you want to place an OK button at the extreme right-hand bottom corner of
the form, you could use the commands:
button .OK AT XMAX FORM-SIZE YMAX FORM OK
XMAX FORM  and YMAX  FORM  refer to the maximum X and Y coordinates for the entire form
so far . 
XMAX  FORM  - SIZE  subtracts the current ga dget’s size so that the form will not expand. The
net result of the above command is to add the OK button so that in the X-direction it just
finishes at the form’s current maximum extent  without increasing the form width, and in the
Y-direction the gadget’s origin is placed at the form’s current maximum depth and extends it
to include the gadget’s height. The result is:
Figure 17:9. Positioning Relative to Form’s Extremities
Typical code to add CANCEL  and OK gadgets to a form would be: 0 1 2 3 4 5 6 7 8 9 0 
1 2 
3 
4 5 
Y X 
XMIN YMAX
6 
new  toggle gadget YMAX+1existing gadget used as reference 
XMIN-2 
 0 1 2 3 4 5 6 7 8 9 0 
1 2 
3 
4 
5 
6 BUTTON .OK gadget
7 Original YMAX FORM 
New YMAX FORM

--- Page 148 ---
12 Series  17:10 Software Customisation Guide
Form Layout
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.button .CANCEL at xmin form ymax form CANCEL
button .OK at xmax form - size OK
17.7 Mixing Auto and Relative Placement
Note that each gadget coordinate is i ndependent with respect to auto and explicit
placement. All the following are legal constructs:
toggle .t1 AT XMIN.gadget1 YMAX.gadget2
places . t1 with respect to XMIN  of one gadget and YMAX  of a different gadget.
toggle .t2 AT XMAX YMAX.gadget2 + 0.25
places .t2 with respect to XMAX  of the last placed gadget and YMAX  of a specific gadget
gadget2 .
PATH down
toggle .t3 AT xmin.gadget1
places . t2 with respect to XMIN  of gadget .gadget2 , whilst the Y coordinate for .t2 is auto-
placed at current VDIST  value below the last placed gadget.
17.8 Absolute Gadget Positioning
Note: Absolute positioning is not the recommended way to define your forms: use relative
positioning.
For example, each of the commands:
toggle .OnOff at 3  3.5 
TOGGLE .ONOFF AT X 3  Y 3.5TOGGLE !This.TOGGLENAME AT Y 3.5  X 3
creates a new toggle gadget positioned at grid coordinates (3, 3.5).
17.9 AT Syntax
The AT syntax is used to define the position of a gadget’s origin within a form. The position
may be specified absolutely (i n form layout grid units) or relative to the extremities of
existing gadgets, or relative to the size of the form and the gadget.
The rest of the Forms and Menus syntax is described in Software Customisation Reference
Manual:  refer to that manual for more informatio n, in particular about conventions used in
the syntax graphs. The AT syntax graph is the easiest wa y of illustrating all the possible
options, and so it is included here:

--- Page 149 ---
 Software Customisation Guide
Form Layout
12 Series  17:11 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Figure 17:10. Syntax Graph -: Gadget positioning
where <FGREL> , shown below, sets the gadget position  relative to another gadget or the
form’s extent. For example, it can be used to position a gadget half-w ay across the width of
a form:
Figure 17:11. Syntax Graph -: Re lative Placing of Gadgets
17.10 Gadget Size Management
Each gadget has a width  and height  attribute, which may be specified in the gadget
definition, with values in grid units
• as a literal distance in grid units
• as the width or height of a previously placed gadget • as the distance from the gadget's position to the positional extent of a previously placed
gadget
A gadget will have up to three pa rts which contribute to the size, enclosed by the gadget
box, namely, Tag (to show the gadget title), Data-box  (to hold the gadget value) and
Decoration (e.g. interaction button, pull-do wn arrow, padding space etc.).
17.10.1 Tag Width
All gadgets have a TAG attribute which may be set in the gadget definition or modified after
the gadget has been defined. The size of a gadget is dependent on whether its tag is
specified, whether it is displayable, and its value at the time of definition.>-- AT --+- val -- val ----------------------------.
+- X val ---------------------------------|
+- XMIN -. |
+- XCEN -| |+- XMAX -+- <fgrel> -. |
'--------'-----------+- Y val ------------|
+- YMIN -. |+- YCEN -| |
+- YMAX -+- <fgrel> -|
 '--------'-----------'--->
>----+- <gname> -.
+-- FORM ---|
'-----------+- * val --.
+- + val --|+- - val --+- + val * SIZE -.
| +- - val * SIZE -|
'----------+- + SIZE -------|
+- - SIZE -------|
'----------------'--->

--- Page 150 ---
12 Series  17:12 Software Customisation Guide
Form Layout
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.•SLIDER, PARAGRAPH, G3D  and G2D do not display their tag at all and so it doesn't
affect the gadget size.
•FRAME  gadgets display their tag as an integral part of their data-box, and so the tag, if
specified, contributes to the ga dget height (but not the width).
•LIST, SELECTOR  and TEXTPANE  gadgets display their tag above the data-box, so if
specified, it affects the gadge t height (but not the width).
•OPTION , COMBO , TEXT , TOGGLE  and RADIO_BUTTON  gadgets display their tag
horizontally in-line with the decoration and/or data-box and so, if specified, affects the
width but not the height.
•BUTTON  gadgets display their tag inside the decoration, and there is no data-box, so
width and height directly set the gadget-box size independently of the actual tag string.
•ALPHA  gadgets (not in FRAME s) display their tag above the data-box, so it affects the
gadget height but not the width. ALPHA  views within FRAMES  do not display their tag
at all, so it has no effect on the size.
Gadgets with an in-line tag support a TagWidth  keyword, which allows the tag width to be
specified in horizontal grid units.
toggle .tog1 tagwid 9 |BBC news 24|
toggle .tog2 tagwid 9 |BBC 1|
This is only necessary to:
• Reserve space for a tag, which is to be set or modified later.
• Ensure alignment of the data-boxes of two or more such gadgets.
Otherwise the tag will be sized dire ctly by the gadget's tag text.
17.10.2 The Meaning of Size  for the PML Gadget Types
The WIDTH  and HEIGHT  settings mean the following for the PML gadget set:
Category Gadget Effect of WIDTH and HEIGHT
Gadgets with an
optional in-line tag.TEXT,OPTION,COMBO
TOGGLE,RTOGGLEWIDTH and HEIGHT define the
data-box and decoration in gridunits. This excludes the tag.
Boxed gadgets with
optional tag above.LIST,SELECTOR, 
TEXTPANEWIDTH defines the width of the
data-box and decoration in gridunits and HEIGHT defines thenumber of visible data lines.The data-box may include scrollbars to expose data lines thatdo not fit into the display spacedefined. This excludes the tag.

--- Page 151 ---
 Software Customisation Guide
Form Layout
12 Series  17:13 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.17.10.3 Specifying Gadget Size Relative to a Previous Gadget
A gadget's width and/or height components can be specified relative to the size of
previously placed gadgets, e.g.
frame fr1 |Frame 1| ... Width.gad6 Height
The width of fr1 is set to the width of gadget gad6 and its height is set to the height of thelast (most recently defined) ga dget, where the meaning of Size  is gadget type dependent as
explained in the previous section.
A gadget's width and/or height components can also be specified as the distance from its
position co-ordinate to the positional extent of another gadget, e.g.
frame fr2 |Frame 2| ... Width to min.fr1 Height to max
The width of fr2 extends from its specified (o r implied) X-position to the XMIN-position of
gadget fr1, and its height extends from its specified (or implied) Y-position to the YMAX-
position of the most recently defined gadget. No te that the positional extents always refer to
the full gadget box.
17.10.4 Gadget Size Syntax
The full syntax for gadget size (width and height) is as follows:Gadgets with no tag
or with an integral(optional) tag.Gadgets that never display a
tag: SLIDER, G2D, G3D,
GM3D, PARAGRAPHWIDTH and HEIGHT define the
gadget box directly in grid units.
Gadgets with integral
(optional) tag: FRAME,
BUTTON .WIDTH and HEIGHT define the
gadget box directly in grid units.
ALPHA : a boxed gadget
with optional tag above.WIDTH defines the width of a
data-box in grid units andHEIGHT defines the number ofvisible data lines. The data-boxmay include scroll bars toexpose data lines that do not fitinto the display space defined,and may also include a datainput line with a prompt above.This excludes the tag.

--- Page 152 ---
12 Series  17:14 Software Customisation Guide
Form Layout
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Where:
1.val is a real value
2.<gname>  is a gadget dot-name such as .gadgetA
3.MIN, CEN, MAX  refer to the gadget or FORM  limits
4.HDIST  and VDIST  are the horizontal and vertical auto-placement increments for the
layout path
5.PADDING  is the extra spacing that F&M adds to left, right, top and bottom of a frame or
the form.
The following example is valid syntax, which could be used to construct a frame .fr2 within
an existing frame .fr1 (note that the sp ace before and after the * is mandatory):
Frame .fr2 ... wid to max.fr1 * 0.5 + hdist  hei to max.fr1 * 0.5 -
padding
17.11 Intelligent Positioning and Resizing
So far we have considered the static layout of the form, but often our forms need to be
resized by the user at run-time.
Most gadgets have DOCK and ANCHOR  attributes that allow you to define intelligent
position and resize behaviour when the gadget’ s container resizes. This allows you to have>-- <vwid> -- WIDth --+- val -->
|
+- TO --+- MIN -.| +- CEN -|
| '- MAX -'-+- <gname> -. .---<---.
| +-- FORM ---| / || '-----------'-+- * val -+-->
| +- + --.
| '- - --+--- val ---.| +-- HDIST --|
| '- PADDING -'-->
+- <gname> -. .---<---.|| / |
'-----------+- * val -+-->
+- + --.'- - --+--- val ---.
+-- HDIST --|
'- PADDING -'-->
>-- <vhei> -+- HEIght -.
+- LENgth -|
'- LINes --+- val -->
|
+- TO --+- MIN -.
| +- CEN -|| '- MAX -'-+- <gname> -. .---<---.
| +-- FORM ---| / |
| '-----------'-+- * val -+-->| +- + --.
| '- - --+--- val ---.
| +-- VDIST --|| '- PADDING -'-->
+- <gname> -. .---<---.
|| / |'-----------+- * val -+-->
+- + --.
'- - --+--- val ---.
+-- VDIST --|
'- PADDING -'-->

--- Page 153 ---
 Software Customisation Guide
Form Layout
12 Series  17:15 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.more than one resizable gadget on the same form and to have predictable and potentially
complex resize behaviour.
Note: The recommended way to build intelligent re sizable forms is to initially design the
form as a simple (non-resizable) dialog, and get the static layout correct. Then apply
the ANCHOR and DOCK attributes to the static gadgets to produce the desireddynamic resize effect.
The DOCK  and ANCHOR  attributes are mutually exclusive. Setting the DOCK  attribute
resets the ANCHOR  to the default; setting the ANCHOR  attribute resets DOCK  to none.
You can set these attributes only when yo u define the gadget: you cannot change the
setting after the exit from form setup. Thus you are not allowed to change the resizebehaviour at run-time.
ALPHA  and VIEW  gadgets do not support DOCK  or ANCHOR  attributes. However, these
gadgets expand fully to fit their containers; so you should always place them in their ownframe, with no other gadgets, and set the frame’s DOCK  or ANCHOR  attributes to get the
behaviour you desire.
17.11.1 ANCHOR Attribute
The ANCHOR  attribute allows you to control the po sition of an edge of the gadget relative to
the corresponding edge of its container.
For example ANCHOR  RIGHT  specifies that the right hand edge of the gadget will maintain
a fixed distance from the right hand edge of its owning container.
The ANCHOR  attribute may have any combination of the values LEFT , RIGHT , TOP, or
BOTTOM ; or it may have the values NONE  or ALL. When the container is resized, the fixed
distance is maintained for any anchored edges.
17.11.2 DOCK Attribute
The DOCK  attribute allows you to dock a gadget to the left, right, top, or bottom edge of its
container, typically a form or a frame; or you ca n cause the gadget to dock to all edges, or to
no edges.
When the gadget’s container is resized, the docked gadget’s e dges will remain ‘stuck’ to the
corresponding container edge or edges. Any docked edge w ill be resized to be the same
size as its container’s edge.
17.12 Useful Form Layout Quick Checklist
The layout for complex dynamic forms can be difficult to get right, so the simpler the codethe easier it is to adjust.
1. It is rarely necessary to set th e form width and height explicitly.
2. Use VarChars  - variable spaced text layout mode (current default is FixChars). This
gives more accurate layout and where text is explicit for a gadget it should remove the
need to use TagWidth (except where specific alignment of a set of gadgets is needed).
Also avoids need to use 'width' for buttons, toggles.
3. Use of 'path down' with 'vdist 0,2' removes the need to keep using ‘at ymax + 0.2' etc4. Use of 'path right' with 'hdist 1.0' removes the need to keep using 'at xmax + 1.0' etc.
5. When using 'anchor' for a gadget the default setting is 'Top + Left' so no need to say
anything if this is all you need.

--- Page 154 ---
12 Series  17:16 Software Customisation Guide
Form Layout
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.6. Minimize the use of literal values for co-ordinate positions and lengths whenever
possible - use relative layout , which makes it easier to adjust the form later, e.g.
frame .page2 Panel anchor all at xmin.page1 width.page1
7. It is not usually necessary to set the frame width and height, except for specific
alignment purposes
8. You can use the 'form - size' and ‘.gad - size’ constructs to right align gadgets in a
dynamic frame, e.g. 
button .nextPage linklabel 'Next' anchor bottom + right at
xmax form-size ymin
9. There are some instances with layout of docking dialogs that sometimes the calculated
frame size is slightly smaller than actual, it is always useful to compare with a simple
dialog (with and without 'resize' set). 

--- Page 155 ---
 Software Customisation Guide
Frames
12 Series  18:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.18 Frames
Frames are very special and versatile gadgets that are crucial for form definition, layout, and
run-time behaviour. This section gives an ov erview of frame gadgets. Their definition and
details are discussed in Gadgets and their Attributes .
18.1 Types of Frame
There are five different types of frame, a nd each type has different constraints on what
gadgets it can contain and what it can be used for.
The five types of frame are normal , tabset , toolbar, Panel and Foldup Panel .
18.1.1 Normal Frames
A frame of type NORMAL  is a container with a visible border that can contain any type of
gadget, including other frames. This simple frame displays its tag as a title to describe thegadget group as a whole.
Normal frames can be nested  and as an inner frame expa nds, an outer frame will also
expand to accommodate it.
The FRAME has a Radio Group property which operates on the set of RTOGGLE gadgets
(radio buttons) owned directly by it.
18.1.2 Tabset Frames
The TABSET  frame type defines a container for a set of tabbed page frames. The container
has no visible border and no tagtex t i.e. it has no displayed title.
Any normal frame defined directly within a TABSET  frame will become a tabbed page
frame , with its tag text displayed in the tab; se lecting a tab will bring the tabbed page frame
to the front, and hide the previously shown tabbed page frame. A page SHOWN  event is
raised for the tabbed page frame whenever the user interactively selects a new page tab.
Handling this event allows the AppWare to mo dify the content of gadgets on the selected
page before it is displayed to the user.
Only one page can be visible at one time, and one page is always visible. To change the
visible page programmatically, you have to se t the new page visible — setting the current
page invisible has no effect. It’s not possible to remove a tabbed-page from the set, but youcan deactivate it, so it is  inaccessible to the user.
The tabbed page frame may contain any form gadgets including normal frame gadgets.

--- Page 156 ---
12 Series  18:2 Software Customisation Guide
Frames
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.To create a multi-paged tabbed form , you can define a dialog or document form with a
single TABSET  frame that contains a set of tabb ed page frames, with each page containing
the gadgets for the desired page of the form.
The form will automatically resize to take accoun t of the larges t tabbed page frame. There is
an example showing the definition of tabbed frames in Complex Form Layout
You cannot nest TABSET  frames.
18.1.3 Toolbar Frames
Main forms support the notion of user-defined toolbars (see Modules and Applications ). You
can create these using toolbar frames.
The frame type TOOLBAR  allows you to define formal tool bars that contain all the gadgets
within the frame’s scope.
A toolbar frame can contain only a subset of gadget types: BUTTON , TOGGLE , OPTION ,
TEXT, COMBOBOX , SLIDER and NUMERICINPUT . It must have a name and can appear
only on main forms; moreover, a toolbar frame is the only kind of frame a main form cancontain.
The frame gadget’s visibility attribute allows  you to show and hide toolbars, as well as
individual gadgets within the toolbar.
Note that any gadgets belonging to a main form and defined outside of a formal toolbar
frame definition are interpreted as a default toolbar with the name ‘ Default’ .
18.1.4 PANEL Frames
This is like a Normal frame but with no enclos ing box (by default). You can formally follow
the PANEL keyword by INDENT to get a 3D indented surround. The Panel also neverdisplays its tag text.
18.1.5 Fold Up Panel Frames
This is like a Panel but has a formal title bar,  which displays the tag text and provides an
icon which can be clicked to fold-up and hide, or unfold and show the contained gadgets.

--- Page 157 ---
 Software Customisation Guide
Gadgets and thei r Attributes
12 Series  19:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.19 Gadgets and their Attributes
As a user, you will already be familiar with form s and their gadgets. T he types of gadgets
that you can define on the body of the form are summarised below. 
Gadget Purpose
FRAME  A container that groups other gadgets visually and logically. It also
acts as a radio group for all directly included RTOGGLE gadgets.
PARAGRAPH Display-text, for information.
BUTTON Act as visual buttons and are pushed to achieve some action. 
The buttons like OK and Apply , which appear on many forms, are
examples of a special type of button, which use form control
attributes  to control the display of the form and whether it is
actioned.
COMBOBOX Similar to a Window Combobox. A combination of a dropdown list
and a single line textbox.
LINE Allows horizontal and vertical lines to be drawn on a form to assist
visual grouping of gadgets.
NUMERIC INPUT Allows numeric input wi thin a specific range.
TOGGLE These gadgets have just two settings: on or off. 
You can have several TOGGLE  gadgets on a form, and they will
normally all be independent.
OPTION Has a pull-down list of options asso ciated with it, from which the
user can choose one only.
LIST Displays one or more lines of data from which the user can select
one or several. The list can be scrollable if there are too manyoptions to be displayed at once.
CONTAINER Allows the hosting of an external control inside a PML defined form.
DATABASE
SELECTORUsed to display a list of database elements, from which the user can
choose.
TEXT A text-box where the user can type input.
TEXTPANE An area where the user can type and edit multiple lines of text, or
cut and paste text from elsewhere on the screen.

--- Page 158 ---
12 Series  19:2 Software Customisation Guide
Gadgets and thei r Attributes
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.19.1 Gadget Definition Commands
You can define gadgets only within the form definition sequence,
setup form... exit.
A gadget definition (except for menu bars) has the format:
For example:Common properties  can appear in any order. These include:
Specific properties : the order of these commands generally matters. See the syntax
graphs in the Software Customisatio n Reference Manual for definitive information about
order.
Most gadget properties can be changed using the members and methods supported by
each gadget object.
Note: You cannot change a gadget’s geometry except for a VIEW  gadget on a resizable
form.
The Software Customisation Reference Manual  contains detailed information on the
methods available for editing each type of gadge t. This chapter describes some of the most
frequently used editing operations.VIEW Used to display alphanumeric or graphical views. There are several
different types, used for displaying different types of information. 
SLIDER The SLIDER  gadget allows you interactively to generate values in a
specified range, at specified steps. PML supports both vertical andhorizontal SLIDERS.
RTOGGLE A FRAME may have a set of RTOGGLE gadgets defined directly
within it which act in concert as a radio group.Gadget Purpose
type name {common properties} {specific properties}
paragraph .mytext at X... Y... width 10 lines 3
position All gadgets have this
tag
tooltipcallbackanchordockingMost  but not all  gadgets have these

--- Page 159 ---
 Software Customisation Guide
Gadgets and thei r Attributes
12 Series  19:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.19.2 Some Generic Gadget  Members and Methods
For full list see Customis ation Reference Manual.
The following members are shared by all gadgets regardless of gadget type:
The following methods are shared by all gadgets regardless of gadget type:
19.3 Gadgets that Support Pixmaps
Some gadgets support pixmaps as content as an alternative to text. e.g. Buttons, Toggles,
and Paragraphs.
Pixmaps are pixelated pictures held in files of type .png .
When pixmaps are required you will need to sp ecify pathnames to the pixmap file and the
maximum required size of the image in width and height, both measured in pixels
The default size for pixmaps is assumed to be 32x32 pixels.For example:
button .ButtonName pixmap /buttonpix WIDTH 26 HEIGHT 26
19.3.1 Selected and Unselected States
BUTTON  and TOGGLE  gadgets may have two associated pixmaps for the states
SELECTED and UNSELECTED , in that order. 
button .B1 pixmap /pix1_sel /pix1_unsel WIDTH 26 HEIGHT 26
• If only one pixmap file is supplie d, it will be used for all states.
• If the Selected pixmap is unset, t hen it reverts to the Unselected one. 
19.3.2 AddPixmap Method
The AddPixmap method is the best way of setting or changing a gadget's associated
pixmaps. Member Name Type Purpose
type STRING 
Read onlyGadget type e.g.'BUTTON, LIST etc.
name STRING 
Read onlyUser's defined gadget name
Method Name Result Purpose
subtype() STRING Gadget subtype e.g. for Frame gadget
returns one of NORMAL, TABSET,
FOLDUPPANEL etc.
container( ) FMO 
GADGET or FORMReturn reference to  the Forms & Menus
object (FMO) which di rectly contains the
gadget.

--- Page 160 ---
12 Series  19:4 Software Customisation Guide
Gadgets and thei r Attributes
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.AddPixmap( !pixmap is STRING )
!pixmap is a string holding the file pathname of the required .png file.
AddPixmap( !pixmap1 is ST RING, !pixmap2 is STRING )
!pixmap1 corresponds to the Un-selected stat e of the gadget, and pixmap2 corresponds to
the Selected state. Specifying !pixmap1 as th e null string ' ', will le ave the current Selected
pixmap unchanged.
PARAGRAPH gadgets only have one pixmap which is represented by the .VAL member,
and so can be directly set or changed  using !this.myPara.val = '<pixmap-pathname> .
Notes:
1. The PML function !!PML.GetPathname ('<myPixmap>.png') returns the required
pixmap pathname for pixmaps held in the standard PDMS Appware pixmap directories.
2. It is recommended that when you define the gadget you set its size to encompass the
largest pixmap which you will la ter add. Failure to do this may give rise to unexpected
behaviour.
3. Historically you could add a third pixmap which was used when the gadget was de-
activated. This practice is no lon ger necessary as the gadget pixmapped is
automatically greyed-out on de-activation.
19.4 De-activating Gadgets: Greying Out
You may de-activate a gadget by setting its active  status  to FALSE :
!!MyForm.List.Active = FALSE
You may re-activate a gadget by setting its active  status  to TRUE :
!!MyForm.List.Active = TRUE
When a gadget is de-a ctivated, it has a greyed-out  appearance and the user is prevented
from interacting with it.
19.4.1 Greying Out Gadgets on Forms
You can de-activate or re-act ivate all the gadgets on a form using the form method:
!MyForm.setactive( TRUE )
!MyForm.setactive( FALSE )
If you want most of the gadgets on the form to be de-activated, yo u can de-activate all
gadgets on the form (and then activate the ones you want, individually) using the followingform methods:
SetGadgetsActive( active is BOOLEAN )
SetActive( active is BOOLEAN )
SetActive(false)  greys out all gadgets on the form, but doesn’t set their Active status,
so that SetActive(true)  restores the form to the precise state it was in before greying-
out, that is, any inactive gadgets will still be inactive.
The command:
SetGadgetsActive( false )

--- Page 161 ---
 Software Customisation Guide
Gadgets and thei r Attributes
12 Series  19:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Greys-out all gadgets on the form and sets their active  status  to inactive  i.e. their previous
active state is lost. Similarly
SetGadgetsActive( true )
greys-in all gadgets and sets their active  status  to active .
19.5 Making Gadgets Visible and Invisible
All gadgets have a visibility member attribute  that you can access with PML. For
example, to make a gadget invisible:
!!myform.mygadget.visible = false 
And to check a ga dget’s visibility:
!bool = !!myform.mygadget.visible
19.5.1 Making Gadgets Visibl e and Invisible in Frames
To make invisible the gadgets owned by a frame, you can set the visible status  of the frame
to false . Conversely, to make them visible again you can set the visible status  to true.
The frame’s visible  property will automatically apply to all of its children, but will not
overwrite their corresponding property values. 
So, for example, if frame .f1 contains button . b1 and f1 and b1 both have Visible =
true . 
The command:
!!form.f1.visible = false 
will cause the frame and all its gadg ets to be hidden , but the query:
!value = !!form.b1.visible 
will still return true.
19.6 Setting Keyboard Focus
The keyboard focus  defines which gadget will receive keystrokes. The FORM  object has
as one of its properties the nam e of the gadget which will init ially have the keyboard focus.
This default keyboard focus can be changed by setting the keyboardfocus  member of the
form:
!!MyForm.keyboardfocus = !!Myform.gadget
The keyboard focus can be moved at any time  to one of the following types of gadget by
calling the setfocus()  method on the target gadget:
• TEXT
• TEXTPANE•B U T T O N• TOGGLE•R T O G G L E•S L I D E R

--- Page 162 ---
12 Series  19:6 Software Customisation Guide
Gadgets and thei r Attributes
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.•L I S T
• SELECTOR• OPTION•A L P H A  V I E W  
For example:
!!MyForm.Textfield.Setfocus()
19.7 Refreshing Gadgets
In general, when a gadget is edited inside  a PML callback function or macro the visual
change is delayed until the entire callback has been executed or interactive input is sought.If you want to see the gadget’s appearance ch ange immediately it is edited, use the method
!Gadget.Refresh()
You can also use the command REFRESH  to refresh all gadgets of all displayed forms.
REFRESH is required after deleting PDMS elements in an interactive DO LOOP. The
following example, from a DRAFT macro, calls a Cursor Function from a DO LOOP to allow
the user to interactively select SLAB elements  for deletion, until terminated by pressing the
ESC key.
do
  id slab@
  handle (61,528) $* Esc to exit
    return  endhandle
!result = 'Picked ' + !!ce.name
$p $!result
delete slabrefresh  $* Must refresh to force full PDMS update, else macro 
fails
enddo
Warning: Refreshing gadgets should be used  sparingly, especially for View gadgets,
as it will cause their content to be regenerated.
19.8 Gadget Background Colour
The gadget methods Background() and setBackground(colourname as STRING) allow youto query and set a gadgets background colour as a colourname string. See the table in theCustomisation Reference Manual for definitive list of which gadgets support the methods. 
The following restrictions apply:

--- Page 163 ---
 Software Customisation Guide
Gadgets and thei r Attributes
12 Series  19:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.• Some gadgets do not support this property in  all circumstances, e.g. gadgets showing
a pixmap.
• Gadgets whose colour has not been set explicitly, may not have a colour with a known
colourname. In this case  an error is raised.
Gadgets also have the Background property, whic h allows query and setting of the integer
colour index.
The special colour index value, zero, allows you to reset the color of the gadget to its default
value. The default col our will be different a ccording to the type of the form on which the
gadget is defined, and in some cases will not have a colorname string.

--- Page 164 ---
12 Series  19:8 Software Customisation Guide
Gadgets and thei r Attributes
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 165 ---
 Software Customisation Guide
Gadget Set
12 Series  20:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.20 Gadget Set
This chapter describes all the gadgets supported by PML. It covers their definition and use.
Note: In some of the examples the relative gadget positioning commands are indicated by
the AT keyword followed by three dots . . . See Relative Placement using the AT-
syntax  for details.
20.1 Examples
There are various examples of the gadgets and form layout in this manual, and you can
download the code for them from the AVEVA Customer Support website.
For an example of simple form layout refer to  Figure 17:3.: Form definition using the
VarChars layout mode
The following example constructs a fully functional, resizable complex form.
20.1.1 Complex Form Layout
The figure below illustrates Tabs et frames, Text gadgets, Co mbobox, Lists, Text Panes,
Paragraphs and Buttons. Note th at this is a fully functional, docking form which illustrates
the use of form methods, particularly the Constructor method, and the use of open
callbacks. It also demonstrates the use of the gadget’s dock and anchor attributes to
achieve forms with intelligent resize behaviour.

--- Page 166 ---
12 Series  20:2 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Figure 20:1. Complex Form Layout


--- Page 167 ---
 Software Customisation Guide
Gadget Set
12 Series  20:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Figure 20:2. The tabbed pages of a complex form
The file layout2.pmlfrm , shown below, defines the form shown in Figure 20:2.: The
tabbed pages of a complex form . Within the form definition the TABSET  frame is defined
and directly contains a frame gadget for each tabbed page. Note its ANCHOR ALL  setting
which maintains the distance between each edge of the frame and the corresponding edgeof the form, when the form is resized by the user. This allows the frame to grow and shrinkwithout overwriting gadgets outside of it. 
Each tabbed page frame contains the definition of all the gadgets belonging to the page.
Note the use of the DOCK FILL  setting which allows each edge of the tabbed page frame to
stick to the corresponding edge of the TABSET  frame so that they grow and shrink in
unison.
Alternatively, when you define a TABSET  FRAME , you can specify its DOCK  or ANCHOR
attributes to determine its resize behaviour within your form.
For each tabbed-page frame within the TABSET , it is no longer necessary to specify any
DOCK  or ANCHOR  attribute settings, an d any that are specified will be ignored. Each
tabbed-page frame will always f ill the available space in its TABSET  parent (it exhibits
DOCK  FILL  behaviour).
The gadget ANCHOR  attribute is used extensively to allow resizable gadgets to expand in
specific directions and not others for. It is also used by non-resizable gadgets, e.g.


--- Page 168 ---
12 Series  20:4 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.BUTTON s, to allow them to move wi th edges of their containers  and so avoid being overlaid
by resizing gadgets.
Note also, the extensive use of form methods to  provide the intelligence of the form as
gadget callbacks. In particular the method listCallback(!list is GADGET, !event
is STRING) , which just reports details of select and unselect events on list fields, has the
standard form of an open callback, and is used as such on the list gadgets LI1 and LI2, i.e.
!this.Li1.callback = |!this.listCallback(|.  Open callbacks are described in
PML Open Callbacks .
-- PDMS Customisation User Guide
-- Form: layout2 - Demonstrate complex form layout--       Extended for PDMS12.0 to illustrate ComboBox gadget
setup form !!layout2 dialog dock left VarChars NoAlign  title 'Form !!layout2'  -- define context menus:
  -- for colour option gadget  !menu = !this.newmenu( 'ColourActions', 'POPUP' )    !menu.Add( 'CALLBACK', 'Add new colour', 
'!this.serviceMenu( ', 'AddColour' )
    !menu.Add( 'TOGGLE'  , 'Editable' , '!this.serviceMenu( ', 
'ToggleEdit' )
    !menu.Add( 'CALLBACK', 'Delete Colour', 
'!this.serviceMenu( ', 'DelColour' )
  paragraph .Message width 40 lines 3  path DOWN
  frame .Tabset TABSET 'tabset' anchor All    --Page 1-------------------------------------------------    frame .page1 |Page 1| dock Fill
      frame .frame4 'Frame 4'
        paragraph .Message4 text 'This is a ComboBox gadget' 
width 18
        combobox .Colour tagwid 5 'Colour' scroll 20 width 5 
tooltip'set/add colour for paragraph'
      exit
      frame .frame6 'Frame 6' width.frame4
        halign right        paragraph .Message6 text 'These are right aligned text 
gadgets' width 16 lines 2

--- Page 169 ---
 Software Customisation Guide
Gadget Set
12 Series  20:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.        text .Width  tagwid 5 'Width'  width 5 is REAL
        text .Height tagwid 5 'Height' width 5 is REAL        text .Area   tagwid 5 'Area'   width 5 is REAL        halign left        button .b3 |area| tooltip'calculate the area'      exit
      frame .frame5 'Frame 5' at Xmax.frame4+2 Ymin.frame4 
anchor All
        paragraph .Message5 text 'This is a multi-choice list 
gadget' wid 12 lines 2
        list .Li1 'Select some of these' anchor all MULTIPLE 
width 12 height 11
        button .b1 |print| Anchor L + B tooltip'print list 
selections'
      exit
    exit    --Page 2-------------------------------------------------    frame .page2 |Page 2| at 0 0 dock Fill
      frame .frame7 'Frame 7' anchor all width 20 height 13
        --Force use of fixed width font        textpane .text 'Textpane: Fixed width font' FixChars 
dock Fill width 1 height 1
      exit
      frame .frame8 'Frame 8' at Xmax.frame7 ymin.frame7 
anchor T+B+R wid.frame7 hei.frame7
        path down        paragraph .Message8 text 'Multi-column, single-choice 
list' width 15 lines 2
        list .li2 |Cars (zero-select)| anchor T+B+L+R columns 
single zerosel width 15 height 12
        button .b2 |print| Anchor L + B tooltip'print list 
selection'
      exit    exit  exit
  path right
  button .CANCEL at XMIN form YMAX form anchor L + B CANCEL  button .RESET anchor L + B RESET  button .OK at XMAX form-size anchor R+B OK
exit

--- Page 170 ---
12 Series  20:6 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.define method .layout2()
$P************************$P !!layout2 CONSTRUCTOR()$P************************-- CONSTRUCTOR - initialise gadget values  !this.firstShownCall = '!this.firstShown()'
  -- main form gadgets
  -- paragraph  !this.message.val = |Complex form layoutThis shows a dockable, resizable form with tabbed page frames 
and use of the gadget Dock and Anchor attributes|
  -- tooltips
  !this.CANCEL.setTooltip('discard values and hide the form')
  !this.RESET.setTooltip('reset to initial values')  !this.OK.setTooltip('accept values and hide the form')
  --Page 1
  -- frame 4    -- option    !ColourArray[1]='White'    !ColourArray[2]='Black'    !ColourArray[3]='Red'    !ColourArray[4]='Green'    !ColourArray[5]='Blue'    !This.Colour.Dtext=!ColourArray    -- set callback    !this.colour.callback = |!this.ServiceColourOption( |    -- assign context menu    !this.colour.setPopup(!this.ColourActions)
  -- frame 5
    -- multi-choice list    do !i from 1 to 20      !Elements[!i] = 'list element $!i'    enddo    !This.Li1.Dtext= !Elements    -- set callbacks    !this.b1.callback =  
|!this.printListSelections(!this.li1)|
    !this.li1.callback = |!this.listCallback(|

--- Page 171 ---
 Software Customisation Guide
Gadget Set
12 Series  20:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.  -- frame 6
    -- make Area read-only    !this.Area.seteditable( false )    !this.Width.val = 6.0    !this.Height.val = 3.5    !this.b3.callback = '!this.calcArea()'    !this.b3.background = 'pink'
  --Page 2
  -- frame 7    -- textpane - add data    !s[1] = 'Try editing the contents of this textpane 
gadget:='
    !s[2] = |         1         2         3         4         5|
    !s[3] = 
|12345678901234567890123456789012345678901234567890|
    !s[4] = | 4 Ford       Escort|    !s[5] = | 5 Ford       Fiesta|    !s[6] = | 6 Vauxhall   Nova|    !s[7] = | 7 Vauxhall   Astra|    !s[8] = | 8 Vauxhall   Lotus|    !s[9] = | 9 LandRover  RangeRover   £62000|    !s[10]= |10 LandRover  Defender     £23999|      do !i from 11 to 99       !s[!i] = '$!i--+---1---+---2---+---3---+---4---+----5'    enddo        !this.text.val = !s
  -- frame 8
    -- multi-column list    -- Define headings    !a[1] = 'Make'    !a[2] = 'Model'    !a[3] = '  Price'    !this.li2.setHeadings(!a)    -- set up dtext rows as array of array    !Row1[1] = 'Landrover'    !Row1[2] = 'RangeRover'    !Row1[3] = '£62000'
    !Row2[1] = 'Landrover'
    !Row2[2] = 'Defender'

--- Page 172 ---
12 Series  20:8 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.    !Row2[3] = '£23999'
    !Row3[1] = 'Lancia'
    !Row3[2] = 'Delta'    !Row3[3] = 'not for sale'
    !Row4[1] = 'Fiat'
    !Row4[2] = 'Tempra'    !Row4[3] = 'offers'
    !Row5[1] = 'VW'
    !Row5[2] = 'Golf GTi'    !Row5[3] = 'p.o.a.'
    do !i from 1 to 5
      !dtext[!i] = !Row$!i    enddo    !this.li2.setRows( !dtext )    -- Add data    do !i from 1 to !dtext.size()      !rtext[!i] = 'row $!i'    enddo    !this.li2.rtext = !rtext    -- set callbacks    !this.b2.callback =  
|!this.printListSelection(!this.li2)|
    !this.li2.callback = |!this.listCallback(|
    -- Initialise menus
    !this.ColourActions.setFieldProperty('ToggleEdit', 
'selected', true)
-- end of CONSTRUCTORendmethod
define method .firstShown()
$P************************$P !!layout2.firstShown()$P************************  -- carry out actions which need form to be shown  !this.message4.background = !this.Colour.selection('DTEXT')endmethod
define method .listCallback(!list is GADGET, !event is 
STRING)

--- Page 173 ---
 Software Customisation Guide
Gadget Set
12 Series  20:9 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.  -- open callback to report on list events
  -- can be used for any list gadget  !name = !list.fullname()  !n = !list.pickedField  if(!n gt 0) then    !sel = !list.dtext[!n]    $P $!event callback on field $!n<$!sel> for list $!name  endifendmethod
define method .calcArea()
  -- calculate the area  !area = !this.width.val * !this.height.val  !this.Area.val = !areaendmethod
define method .printListSelection(!list is GADGET)
  -- report single-selection list gadget selection  -- can be used for any single-choice list  !sel = !list.selection('Dtext')  !num = !list.val  !name = !list.fullname()  $P -----------------------------------------------  $P selected field for list $!name  $P Field $!num: <$!sel>  $P -----------------------------------------------endmethod
define method .printListSelections(!list is GADGET)
  -- report multi-selection list gadget selections  -- can be used for any multi-choice list  !sels = !list.selection('Dtext')  !nums = !list.val  !name = !list.fullname()  !nvals = !sels.size()  $P -----------------------------------------------  $P $!nvals selected fields for list $!name  do !n from 1 to $!nvals    $P Field $!nums[$!n]: <$!sels[$!n]>  enddo  $P -----------------------------------------------endmethod

--- Page 174 ---
12 Series  20:10 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.define method .serviceMenu(!menu is MENU, !event is STRING )
  -- Service selections on menu fields  !menuname = !menu.name()  !fieldname = !menu.pickedFieldname  -- $P $!event $!menuname > $!fieldname  if( !menuname eq 'ColourActions' ) then    if( !fieldname eq 'AddColour' ) then      if( !event eq 'SELECT' ) then        !this.ServiceColourOption(!this.Colour, 'VALIDATE')      endif    elseif(!fieldname eq 'ToggleEdit' ) then      !this.Colour.Editable = (!event eq 'SELECT')    elseif(!fieldname eq 'DelColour' ) then      !this.Colour.Clear(!this.Colour.displayText())      -- reselect in case its changed      !this.message4.background = 
!this.Colour.Selection('dtext')
      handle (61,620)        return      endhandle    endif  endifendmethod
define method .ServiceColourOption(!option is GADGET, !event 
is STRING)
  -- Service Colour Option gadget  !name = !option.fullname()--$P************************--$P !!layout2.ServiceColourOption($!name, $!event)--$P************************  if( !event eq 'VALIDATE' ) then    -- add new colour to list, without duplicates    !colnam = !option.displayText().trim()    $p $!name $!event $!colnam    !vals = !option.Dtext    do !i from 1 to !vals.size()      golabel /finished if( !vals[!i] eq !colnam )    enddo    -- try to use the colour, only add if valid    !this.message4.background = !colnam    handle (61,620)

--- Page 175 ---
 Software Customisation Guide
Gadget Set
12 Series  20:11 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.      return error 1 'Colour $!colnam is not in the Colour 
Table'
    endhandle    --add to list and make current    !option.add(!colnam)    !option.select('DTEXT', !colnam)    --    label /finished  elseif( !event eq 'SELECT' ) then    -- change background colour of paragraph    !colnam = !this.colour.selection('dtext')    $p $!name $!event $!colnam    !this.message4.background = !colnam  elseif( !event eq 'UNSELECT' ) then
    !fld = !this.colour.pickedField
    !colnam = !this.colour.dtext[!fld]    $p $!name $!event $!colnam  endifendmethod
20.1.2 Multi-lingual Form
This section shows a multi-lingual form using a Tabset frame with three Tabbed-page
frames and a Fold-up panel. Each page shows essentially the same page design but usingRussian, Chinese and English (Unicode) characters.
The extract from the PML code of the form Un icode.pmlfrm demonstartes the use of multi-
lingual gadget names, variable names and form method names.
You can download the fully working fo rm from the AVEVA Support website.

--- Page 176 ---
12 Series  20:12 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.setup form !!Unicode dialog dock left NoAlign VarChars size 41 5
  title |Form !!Unicode|
  
  -- set form members to support sharing of the callback methods   -- between the different language versions of the pages     
  member .EnglishColours is ARRAY
  member .RussianColours is ARRAY  member .ChineseColours is ARRAY
  member .ColourNames is ARRAY
  member .colourPara is GADGET  member .colourCombo is GADGET
  member .textField is GADGET


--- Page 177 ---
 Software Customisation Guide
Gadget Set
12 Series  20:13 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.          
  vdist 0.25
  hdist 0.5
  frame .Tabset TABSET 'tabset' anchor L+R+T wid 41
. . .


--- Page 178 ---
12 Series  20:14 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.20.2 Frame Gadgets
Frame gadgets provide visual grouping of gadgets on a form, and aid form layout. 
The grouping is more than visual: a frame is a genuine container and manages the gadgets
it contains, so gadgets are positioned relative to the frame’s origin rather than the form’sorigin.
When a container resizes it will ad just the layout of all its ch ildren, taking account of their
anchor  or dock  properties.
The frame gadget’s properties visible  and active  will automatically apply to all of its
children, but will not overwrite their corresponding property  values. So, for example, frame
.f1 contains button .b1  and f1 and b1 both have visible = true . 
The command:
!!form.f1.visible = false
will cause the frame and all its contained gadgets to be hidd en, but the query:
!value = !!form.b1.visible


--- Page 179 ---
 Software Customisation Guide
Gadget Set
12 Series  20:15 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.will still return true.
20.2.1 Defining a Frame
You define a frame using a command sequence beginning with the command frame  and
ending in exit .
All the gadgets defined after the frame  command and before exit  will be included in and
contained by the frame.
The following example defines Frame1 and its gadget collection. The frame sub-type
<frame-type> is either one of the suppo rted types TABSET, TOOLBAR, PANEL,
FOLDUPPANEL, or omitted for a 'normal' or 'tabbed page frame'.
frame .frame1 <frame-type> '<frame-tag>'
paragraph .Message1 text 'This frame contains toggle
buttons'
PATH DOWN
toggle .Bold 'Bold' 
PATH RIGHTtoggle .Italic 'Italic'
toggle .Underline 'Underline' 
exit
Frame Size
During form definition, once a frame is positio ned on the form the origin remains fixed but
the frame automatically expands downwards and to the right to contain any gadgets addedto it. You cannot add gadgets to it at negative coordinates relative to the frame’s origin. You
can optionally declare a minimum size for the frame. For example:
Frame frame1 ‘frame 1’ SIZE 10 20
This is relevant only for NORMAL  and TABSET  frames; for TOOLBAR  frames, the gadgets
appear as a single row in the order defined i.e. gadget positions are ignored.
20.2.2 Frame Radio Groups
A FRAME may have a set of RTOGGLE gadgets defined directly within it which act in
concert as a radio group.
An example of a FRAME  with a directly defined radio group looks like this:

--- Page 180 ---
12 Series  20:16 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The radio group action only applies to FRAME  gadgets of type NORMAL, PANEL,
FOLDUPPANEL .
You can add RTOGGLE  to a FRAME  with the usual positioning and layout commands. 
The FRAME  has a value member, VAL, which is the index of currently selected RTOGGLE
for the radio group. You can use this to change the selected RTOGGLE . 
Similarly, you change the value of the FRAME  by setting the VAL member of any of the
group’s RTOGGLE s to true.
Note that the FRAME  group value may be set to zero, indicating that there is no selected
RTOGGLE . Similarly if the selected RTOGGLE  value is set to false, then it becomes
deselected and the FRAME  value will then be zero.
The default value for an RTOGGLE  gadget is FALSE , and the default value for a FRAME
gadget is zero, i.e. no selected RTOGGLE .
Frame Callbacks
The FRAME  gadget can have an assigned callbac k, which is executed when the radio
group selection is changed, i.e. whenever the user selects an unselected radio-toggle. Asthere is only a SELECT action supported, it  can be either a simple callback or an open
callback.
The form definition below is a simple TV  and radio station selector, shown above. 
setup form !!FRGTest dialog noAlign
title |Select a program|Frame .rg1 |TV and Radio|
path downtext .choice tagwid 6 |Selection:| width 12 is STRINGrToggle .rad1 tagwid 7 |BBC 1| States '' 'BBC 1'path rightvalign centre rToggle .rad2 tagwid 7 |BBC 2| States '' 'BBC 2'rToggle .rad3 tagwid 7 |Anglia| States '' 'Anglia'rToggle .rad4 tagwid 7 |Chan 4| at xmin.rad1 ymax.rad1 
States '' 'Chan 4'
rToggle .rad5 tagwid 7 |Radio:| States '' 'radio'option .Radio width 10 


--- Page 181 ---
 Software Customisation Guide
Gadget Set
12 Series  20:17 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.exit
button .cancel |Cancel| at xmin form ymax form + 0.2 CANCEL button .ok | OK | at xmax form - size OK
- set focus to button to ensure to ensure Windows does not 
set it to first Rtoggle 
!this.keyboardFocus = !this.ok
exit
Note: The form’s keyboard focus is  initially placed on the OK button to prevent it being
assigned (by Windows) to the first RTOGGLE  rad1  (effectively the first interactive
gadget on the form as the text field Selection  is read-only)
The form constructor method assigns a simple callback, the form method
RGroupSelectionChanged(),  to the frame rg1 (radio group). It then initialises the
gadget values and selects the second RTOGGLE  as the default selection.
define method .FRGTest()
-- Constructor-- Frame radiogroup with simple callback!this.rg1.callback  = '!this.RGroupSelectionChanged( )'
-- set result field read-only
!this.choice.setEditable(false)-- Radio choices
!this.rad5.setTooltip(|select your Radio option|) 
!radio[1] = 'Q103'!radio[2] = 'Hereward'
!radio[3] = 'Cambridge'
!radio[4] = 'ClassicFM'!radio[5] = 'Caroline'
!this.Radio.dtext = !radio
!this.Radio.setTooltip(|change your Radio option|)!this.Radio.callback = '!this.selectProgram(!this.rad5)'
-- set initial value
!this.rg1.val = 2!this.RGroupSelectionChanged( )
Endmethod
The group callback uses the FRAME ’s VAL member to get the current selected index and
hence the current RTOGGLE  and its OnValue  member value. If the selected RTOGGLE’S
value is ‘radio’ then the selected program is read from the RADIO  option gadget. Finally the
selected program string is displayed in the Selection  (read-only) text gadget.
define method .RGroupSelectionChanged( )

--- Page 182 ---
12 Series  20:18 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.-- Service radiogroup select event
!Frame = !this.rg1
!index = !Frame.val
!rTog  = !Frame.RToggle(!index)!value = !rTog.onValue
-- Do some application actions
if( !value eq 'radio' ) then
!value = !this.Radio.selection('dtext')
endif
!this.choice.val = !value
endmethod
The callback on the RADIO  option gadget, detects if the ‘Radio:’ RTOGGLE  rad5  is current
and if so it deselects it leaving no  current selection, and clears the Selection  text field.
define method .selectProgram( !rtog is GADGET )
-- Select new program from option list
if( !this.rg1.val eq !rtog.index ) then
-- rtog is current, so deselect it within group
!this.rg1.val = 0
!this.choice.clear()
endif
endmethod
20.2.3 Managing Pages in Tabset Frames
Within a Tabset frame, whenever the user inte ractively selects a new tab a HIDDEN event is
raised for the previous tabbed page frame and then a SHOWN event is raised for the newone, which pops to the front. The HIDDEN  and SHOWN callbacks are only executed for
tabbed page frames which provide an Open callback.
If you want to manage tabbed pages that are also radio groups, then you must supply an
open callback so you can differentiate the SELECT  (RTOGGLE ) event and the (page)
SHOWN  event.
Setting a tabbed page frame's VISIBLE property, e.g. !this.TabbedPage.visible = true ,
selects it and gives it focus, but does not raise HIDDEN or SHOWN events.
The example below shows a typical form method you could use as a PML open callback to
handle frame events for any frame gadgets defined on a form:
define method .frameEvents(!frame is GADGET, !event is
STRING)
-- Frame events open callback handler
if( !event eq 'SELECT' ) then

--- Page 183 ---
 Software Customisation Guide
Gadget Set
12 Series  20:19 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.--Handle radio button selection
!selection = !frame.val
...
elseif( !event eq 'SHOWN' ) then
-- tabbed page selected
-- modify page content
...
endif
endmethod
20.2.4 Managing the Fold Up Panel
The form shown below is a docking dialog which has five FOLDUPPANEL gadgets, the first
two are collapsed (hidden) and the second two are expanded (shown). Each one has a titlebar which displays the panel's tag text, and an ic on which allows the pane l to fold-up or fold-
down when clicked.
The default state is 'unfolded' and the EXPANDE D property allows the user to initialise a
panel to unfolded (true) or folded (false).
When the panel expands or collapses, any gadgets which lie below the panel and between
(or partially between) the panel's horizontal limits will be moved down  or up the form.
If the form's AutoScroll attribute is select ed, then a scroll bar will automatically appear
whenever gadgets have been moved off the bottom of the form, so that the entire form isalways accessible.

--- Page 184 ---
12 Series  20:20 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Fold Up Panel Events
HIDDEN and SHOWN events are ra ised whenever the user interactively folds or unfolds the
panel. These events are only fired if an Open callback is defined for the foldup frame. Tomanage FoldUpPanels which are also radio groups, then you must supply an open callbackso that you can differentiate the panel's SELECT, HIDDEN and SHOWN events.
20.3 CONTAINER Gadget
The Container gadget allows the hosting of an  external Control, e.g. a PMLNet, control
inside a PML defined form. It allows the user to add an external .Net control, which mayraise events that can be handled  by PML. In order to customise the context menus of the
.Net control, the Container may have a PML pop up menu assigned to it. This is shown when
the .Net control raises a 'popup' event.
A CONTAINER gadget can be created by
container .NET  indent PMLNETControl  dock fill
The following section contains the PML code for an example form !!MyNetForm.By default the Container will be will have a drawn surrounding box, but you can select
NOBOX or INDENT which produces a 3-D indented surround.


--- Page 185 ---
 Software Customisation Guide
Gadget Set
12 Series  20:21 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The Dock and Anchor attributes  are supported to allow intelligent resize behaviour. The
enclosed Control must s upport resizing and is usually set as Dock fill, so that it follows size
changes of the Container.
The following restrictions apply:
• Tagtext can be specified but is never displayed.
• Positioning must be specifie d before size (<vshape>).
• Currently only Controls of type PMLNet are supported.
20.3.1 Example of Container Gadget
This section creates a form, MYNETFO RM, which hosts a PMLNet control. 
First you will need to have created your PMLNet control - See .Net Customisation
Reference Manual. 
In this example the control is called MyNetC ontrol, and comprises a text label, a toggle
(NET), a button (Colour) and a PDMS explorer, as shown in the picture.
MyNetControl supports three events, namely OnCheck, OnPopup and OnColour.
• OnCheck - raised when the NET toggle is c licked. Callbacks keep the PML toggle and
the .NET toggle in step.
• OnPopup - raised when the right mouse button is pressed while the cursor is over the
background of the control. Callbacks edit and show the PML popup menu.
• OnColour – raised when the user selects a colour from the standard Winforms colour
picker (as pictured), which is shown when th e colour button is pressed. Callback prints
the RGB components of the selected colour.
The PML code to create and manage the form is given below. Purple is used to highlight the
PMLNet commands, the rest is just standa rd PML2. It includes rudimentary callback
methods to service the PMLNet controls events.


--- Page 186 ---
12 Series  20:22 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.In your Appware you need an import command (to load the dll containing your
PMLNetControls)
import 'PMLNetTest'
This is usually done once only, probably in application start-up macro. You can have it in
your form, but you will then nee d to handle the er ror which will occur if the import is
executed more than once:
import 'PMLNetTest'
handle (1000,0)-- PMLNetTest dll already loadedendhandle
-- MyNetForm.pmlfrm: Test form hosting a PMLNet Control
setup form !!MyNetForm size  25 20 dialog dock right
using namespace 'Aveva.PDMS.PMLNetTest'
member .MyCtrl is MyNetControl
!this.FormTitle = 'My PMLNet Form'path down
-- define PML Container to host .Net controlcontainer .NET  indent PMLNETControl  dock fill
-- define PML Frame
frame .PMLFrame 'PML' dock top
paragraph .PMLMessage text 'This frame contains a PML toggle button' wid 25toggle .PMLToggle 'PML ' 
exit
-- define PML popup menu
menu .PMLPopup popup
!this.PMLPopup.add( 'CALLBACK', 'Attr ibutes', '!this.attributesMenu()' )
!this.PMLPopup.add( 'CALLBACK', 'More', '!this.moreMenu()' )!this.PMLPopup.add( 'CALLBACK' , 'Last', '!this.lastMenu()')
exit
------------------------ MYNETFORM Constructor----------------------define method .MyNetForm()
using namespace 'Aveva.PDMS.PMLNetTest'
-- create instance of .Net control
!this.MyCtrl = object MyNetControl()
-- add .Net control to PML container
!this.NET.control = !this.MyCtrl.handle()
-- add PML event handlers to .Net control,  to service (some of) the events it raises
!this.MyCtrl.addeventhandl er('OnCheck',  !this, 'NETToggleCallback')
!this.MyCtrl.addeventhandl er('OnPopup',  !this, 'NETPopupCallback')
!this.MyCtrl.addeventhandle r('OnColour', !this, 'NETColourCallback')

--- Page 187 ---
 Software Customisation Guide
Gadget Set
12 Series  20:23 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.-- add callback to the context menu, so we can edit the menu before it gets popped up
!this.PMLPopup.callback = '!this.editMenu()'
-- add PML callback for PML Toggle
!this.PMLToggle.callback = '!this.PMLTo ggleCallback(!this.PMLToggle.val)'  
endmethod
------------------------ Callback methods----------------------define method .NETPopupCallback( !x is REAL, !y is REAL)
-- service the .Net control’s popup event!this.NET.popup = !this.PMLPopup!this.NET.showPopup( !x, !y )
endmethod
define method .editMenu()
-- Edit the popup menu which is about to be shown!this.PMLPopup.add( 'CALLBACK', 'New field', '$p this is a new field' ) 
endmethod
define method .attributesMenu()
-- service the menu field$P attributesmenu callback executed
endmethod
define method .moreMenu()
-- service the menu field$P moremenu callback executed
endmethod
define method .lastMenu()
-- service the menu field$P this.Lastmenu callback executed
endmethod
define method .NETToggleCallback(!checked is BOOLEAN)
-- service the ‘checked’ event for the toggle in the .Net control-- keep PMLtoggle in step!this.PMLToggle.val = !checked
endmethod
define method .NETColourCallback(!red is REAL, !green is R EAL, !blue is REAL)
-- service the ‘colour selected’ event for the button in the .Net control
$P NetColour Callback executed: RG B = ( $!red, $!green, $!blue )
endmethod
define method .PMLToggleCallback(!checked is BOOLEAN)
-- service the PML toggle callback-- keep .NETtoggle in step!this.MyCtrl.val(!checked)
endmethod

--- Page 188 ---
12 Series  20:24 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.20.4 Paragraph Gadgets
Paragraph gadgets allow a text or a pixmap  to be displayed on a form. This gadget has no
associated name-tag and no call-back command: it is passive so cannot be selected by theuser.
A paragraph gadget can contain text or a pixmap. Once it has been defined, a textual
paragraph  cannot be changed to a pixmap paragraph  or vice versa.
Paragraph gadgets support the DOCK  and ANCHOR  attributes.
20.4.1 Textual Paragraph Gadgets
A textual paragraph  gadget is defined by the paragraph  command.
A paragraph gadget’s size may be s pecified explicitly in terms of width  and height , or
defined implicitly by the initial value, or content. Once it has been defined, the size of the
gadget cannot be changed.
An initial value of a paragraph gadget can be set using the TEXT  keyword.
You do not need to set the value in the setup form  sequence: you can leave it until a
value is assigned to its val member, but you must give a textual paragraph gadget an initial
size if you do not give it an initial text value. 
paragraph .message text 'Text string'
paragraph .message AT . . . text 'Text string' width 16 lines 7paragraph .message AT . . . background 2 width 20 lines 2
For multi-line paragraphs the text is line-wrapped and formatted into the available space. It
can contain explicit newlines to achieve the desired format.
20.4.2 Pixmap Paragraph Gadgets
A pixmap paragraph  gadget has a fixed width and length that may be specified explicitly in
terms of width and height in pixels of the lar gest pixmap that is to be displayed, or defined
implicitly by the initial value. Once it ha s been defined, the size of the gadget cannot be
changed. The default size for a pixmap is 32x32 pixels.
paragraph .picture AT . . .
pixmap /filenameparagraph .picture AT . . .
pixmap /filename width 256 height 200
The pixmap may be changed at any time by assigning a new value to the .val member:
!!MyForm.picture.val = /newfilename
20.4.3 Textual Paragraph Gadgets
The background colour may optionally be set using the BACKGROUND  keyword and a
colour specification.

--- Page 189 ---
 Software Customisation Guide
Gadget Set
12 Series  20:25 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.20.5 Button Gadgets
When the user presses a button gadget  (control button) it will us ually display a child form
or invoke a call-back - typically a PML Form method.  
Buttons have a tag-name or pixmap which is shown within the button rectangle. The tag,
pixmap, call-back, and child form are all optional.
(See Gadgets that Support Pixmaps  for more about pixmaps). 
For example:
button .SubForm 'More . . .' FORM !!ChildForm 
button .SubForm pixmap /filename FORM !!ChildForm button .Calculate 'Calculate' CALLBACK
‘!this.CallbackFunction()’
You can specify the width of the BUTTON  independently of any tag text string it contains
using the WIDTH  syntax. You can also define its height with the HEIGHT  syntax, allowing
you to define textual BUTTON s taller than a single character in height.
For example:
Button .btn1 |reject selection| at ... width 10 height 1.5
Note: The BUTTON ‘s tag is always centre-alig ned within the define area.
20.5.1 Buttons of Type Toggle
Buttons can optionally be used in toggle m ode, where they show visually differentiated
pressed  and unpressed  states, similar to TOGGLE  gadgets.
Buttons with Pixmaps
For these buttons, the Unselected  and Selected  pixmaps swap whenever the button is
pressed, so alternating between the two im ages in the pressed and un-pressed states. 
Textual Buttons
Toggle buttons will highlight wh en pressed. For example on to olbars they will turn from blue
to orange when pressed, and go back to blue again when un-pressed.
The syntax to select the new mode is toggle , which can be anywhere after the button
name and before the button control type or associated form, e.g.
Button .B1 TOGGLE pixmap /Unselected.png /Selected.png /
Inactive.png width 16 height 16 tooltip...
The button’s value-member !button.val  is a BOOLEAN  and reflects the button’s state,
having the value TRUE  when the button is pressed and FALSE  when it is not.
20.5.2 Buttons of  type LINKLABEL
The Linklabel, provides a purely  textual button presentation, i. e. it has no enclosing box. It is
often used to indicate a link to some application item, e.g. a hyperlink to a file, a link to anassociated form. They do cause validation of any modified text fields of the form wheneverthey are pressed.

--- Page 190 ---
12 Series  20:26 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The tag text is shown in a different colour to all other gadget's tag text. The link label gadget
highlights by underlining when the mouse cursor passes over it. Pressing it causes aSELECT event to be raised and runs any associated call back.
Linklabels have the following restrictions:
• They don't support change of background colour.
• They don't support 'pressed' and 'not pressed' value.• They can have popup menus, though this is not recommended.• They don't have Control Types e.g. OK, CANCEL etc.
The sub-type of any Button gadget can be queried using the it's Subtype method.
20.5.3 Form Control Attributes
A button may optionally have a form control attribute , such as OK, which takes effect after
the callback command is invoked.
It is convenient, but not essential, to give a button the same PML name and displayed tag
name as its control attribute.
If no form control attribute is specified, the effect of the button depends entirely on the
callback or the showing of a child form.
You can only have one of each type of control attribute on any form, apart form APPLY  which
may be used on several buttons.
Control Attribute Purpose
OK Allows the user to approve the current gadget settings
and action the form. The form nest’s OKCALL  callbacks
are run (see Form OK and CANCEL Callbacks ) and the
nest is hidden. Any callback on the OK button is ignored.
APPLY Similar to OK in that the gadget settings are approved
and the form is actioned but not removed from the screen.There may in fact be several APPLY  buttons for different
sections of form (ideally each section within its ownFrame). A form with one or more APPLY  buttons should
also be given a DISMISS  button for removing it from the
screen.
CANCEL Allows the user to decides not to proceed with the form.
The form nest’s CANCELCALL  callbacks are run and the
nest is hidden. All gadget values are reset to their initialsettings or to the values established at the last APPLY . 
RESET Returns the values of all gadgets on the form to the
values they had when the form was displayed. If the userhas since pressed an APPLY  button, the form gadgets
are reset to the values they had when the APPLY button
was last pressed. The callba ck is then invoked in which
your PML code should ensure that anything that needsundoing is indeed undone. 
HELP Invokes online help.

--- Page 191 ---
 Software Customisation Guide
Gadget Set
12 Series  20:27 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The effect of OK and CANCEL  on gadgets is more extensive if a form family is involved, as
described in Free Forms and Form Families .
Examples:
button .Ok AT . . . 'OK' CALLBACK '!!MyOkFunction()' OK
button .Apply 'Apply' CALLBACK '!!MyApplyFunction()'  APPLY
button .Cancel 'Cancel' CALLBACK '!!MyCancelFunction()'  CANCELbutton .reset AT . . . 'Reset' RESET
button .help AT . . . 'Help' HELP
20.5.4 Defining a Dismiss Button 
To define a dismiss button , use a command like this:
button .Dismiss 'Dismiss' CANCEL
Note that this button deliberately does not have a callback. When this button is pressed, the
form nest is removed from the screen and its CANCELCALL  callbacks executed.
20.6 Toggle Gadgets
TOGGLE  gadgets are used for independent on/off settings as opposed to a radio group. A
TOGGLE  should be given a tag name or pixmap, which is displayed to the right of the
TOGGLE  button.
The three TOGGLES  are defined by the following lines. 
toggle .Bold 'Bold' 
toggle .Italic 'Italic'toggle .Underline 'Underline' 
They are named Bold , Italic  and Underline , and they are tagged with corresponding text,
enclosed in quotes.
More examples:
toggle .Italic 'Italic' AT . . . 
toggle .GridOn pixmap /filename callback '!!MyFunction()'
The value of a toggle gadget is set and used via the .val member which is a BOOLEAN
value:
!!MyForm. Italic.val = TRUE
if ( !!MyForm.GridOn.val ) then
...
else...
endif
The default value for a toggle is FALSE .

--- Page 192 ---
12 Series  20:28 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.20.7 RToggle Gadgets
The RTOGGLE  gadget is very similar to the TOGGLE  gadget, but is allowed only in
FRAME s, where they operate together to form a set of radio buttons, only one of which can
be selected at any one time.
You can add RTOGGLE  gadgets to a FRAME  with the usual layout and positioning
commands. The RTOGGLE  gadgets are implicitly numbered 1, 2, 3, … n as they are added.
RToggle Callbacks
The RTOGGLE  gadget can have an assigned callb ack, which is executed whenever its
selected status is changed. When the group se lection is changed, by the user clicking an
unselected radio button, the current button (if any) is unselected and the new button is
selected. An open callback (PML function or form method) is necessary as the eventsUNSELECT  and SELECT  need to be reported.
The PML code below shows a modification to our example form, which makes use of open
callbacks on the RTOGGLE s instead of a simple callback on the FRAME  radio group. The
Constructor  and the RgroupSelectionChanged  methods are modified accordingly. 
Note: The behaviour of the two versions is iden tical. Both mechanisms are equally valid,
and are provided to minimise the work required in replacing the RGROUP  and
(deprecated) RADIO  gadgets.
define method .FRGTest()
-- Constructor-- Frame radiogroup
-- set result field read-only
!this.choice.setEditable(false)--TV and Radio with open callbacks
!this.rad1.callback = '!this.RGroupSelectionChanged(' 
!this.rad2.callback = '!this.RGroupSelectionChanged(' this.rad3.callback = '!this.RGroupSelectionChanged(' 
this.rad4.callback = '!this.RGroupSelectionChanged('
this.rad5.callback = '!this.RGroupSelectionChanged('-- Radio choices
!this.rad5.setTooltip(|select your Radio option|) 
!radio[1] = 'Q103'!radio[2] = 'Hereward'
!radio[3] = 'Cambridge'
!radio[4] = 'ClassicFM'!radio[5] = 'Caroline'
!this.Radio.dtext = !radio
!this.Radio.setTooltip(|change your Radio option|)!this.Radio.callback = '!this.selectProgram(!this.rad5)'
-- set initial value

--- Page 193 ---
 Software Customisation Guide
Gadget Set
12 Series  20:29 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!this.rad2.val = true
!this.RGroupSelectionChanged( !this.rad2,'SELECT' )
endmethod
define method .RGroupSelectionChanged( !rtog is GADGET, !event
is STRING )
-- Service specified radio-toggle events
if( !event eq 'UNSELECT' ) then
-- Do some application actions!this.choice.clear()
elseif( !event eq 'SELECT' ) then
!value = !rtog.onValue-- Do some application actions
if( !value eq 'radio' ) then
!value = !this.Radio.selection('dtext')
endif
!this.choice.val = !value
endif
endmethod
Order of Event Generation
Events for the radio group FRAME  and its radio-toggles happen in the following order, when
an RTOGGLE  is selected:
UNSELECT  on previously selected RTOGGLE  (if any)
SELECT  on new RTOGGLE
SELECT  on FRAME
20.8 Option and Combobox Gadgets
The OPTION  and COMBOBOX  gadgets offer a single choice from a list of items. Clicking
the down-arrow icon opens the drop-down list to allow a selection of a field from the choices.The currently selected field is highlighted.
The two gadget types are similar, the main differences being:
• Option gadget's display text field cannot be edited.
• Combobox gadget's display text field is editable, just like a TEXT gadget.
• Combobox does not support the display of pixmaps.
The drop-down list is very similar to a Sing le Choice List Gadget and supports DTEXT,
RTEXT, ZEROSELECT and NORESELECT proper ties. The same methods are used to
manage the list's content. In just the same way it also allows UNSELECT and SELECTevents.
When the user presses the option gadget, the entire set of items is shown as a drop-down
list and the user can then select a new item by clicking the option required.

--- Page 194 ---
12 Series  20:30 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.There is always a selected value unless the option list is empty.
You can use the Add methods to add a single new entry to be appended to OPTION
gadgets:
Add( !Dtext is STRING ) 
Add( !Dtext is STRING, !Rtext is STRING )
Where Dtext  is the text to be displayed in the option list, and Rtext  is the replacement text
for the new field.
If Rtext  is not specified, it will be set to the Dtext  string by default.
20.8.1 Textual Option Gadgets
The width of a textual option gadget, in grid units, must be specified. A tag name is optional
and is displayed to the left of the gadget. 
option .Colour 'Colour'  width 10
The current value in a textual option gadget is scrollable using the left- and right-arrow keys.
This means you can specify a gadget that’s narrower than the options displayed in the drop-down list.
The OPTION  gadget actually contains two parallel lists of the same length, the display
values  (or Dtext  ) and the replacement values  (or Rtext ). The list of display values must
be supplied by assigning an array of values to the gadget's Dtext  member. This is the list of
choices displayed to the user.
In Examples , the lines in the default constructor method define the Colour  option gadget
values as follows:
!ColourArray[1]='Black'
!ColourArray[2]='White'!ColourArray[3]='Red'
!ColourArray[4]='Green'
!ColourArray[5]='Blue'!This.Layout2.Colour.Dtext=!ColourArray
Other examples:
option .Colour 'Colour:' AT . . .  callback '!!MyFunc()'  width
20
20.8.2 Combobox Gadgets
A COMBObox is a combination of an option gadget  and text field. It can be defined by the
command
combo .Colour  tagwid 5  'Colour'  scroll 20  width 5 
When the ComboBox is editable(default), wit h the drop-down list closed, the user can
search for a required option by typing the first few letters into the display field and clickingthe down-arrow. The list will open with the first ma tching option highlighted . This is useful for
large lists.

--- Page 195 ---
 Software Customisation Guide
Gadget Set
12 Series  20:31 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The display field is accessible to the user, who ca n edit the contents by typing or pasting text
into the field. If the user clicks ENTER while the gadget's text field has focus and has been
modified, a VALIDATE event is raised. You ca n trap this event by assigning a PML Open
callback to the gadget. This allows you to give meaning to the action of typing text into the
display field. The Open callback is necessary to differentiate the VALIDATE event from theSELECT and UNSELECT events.
On receipt of the VALIDATE event, your callback method can retrieve the displayed text by
means of the DisplayText  method and decide what action is associated. Additionally you
can assign a popup menu to the gadget, which gives the user the choice of several actions.
For example, you might append the current di splay text to the drop-down list as a new
choice, possibly ensuring that there are no duplicate entries. An assigned popup menucould allows options to be removed from the drop-down list and the editable status of thecombobox to be toggled.
(PML example code is available as User Manual example Layout2.pmlfrm which can be
obtained from AVEVA's support web site.)
20.8.3 Pixmap Option Gadgets
The gadget-shape must be specified, using the WIDTH  keyword and either HEIGHT  or
ASPECT . A tag name is optional and is displayed to the left of the gadget. 
The display text should be set to pixmap’s filename and assigned to the Dtext  member: 
!CircleDtextsArray[1] = '/directory/circle/cenrad'
!CircleDtextsArray[2] = '/directory/circle/3pts'
!!MyForm.Circle.Dtext = !CircleArrayoption .Circle1 AT . . .  callback '!!MyFunc()'  PIXMAP width
256 height 128
option .Circle2 AT . . .  callback '!!MyFunc()'  PIXMAP width
256 aspect 2.0
The replacement-texts, if needed, are set by assigning an array of values to the Rtext
member.
!CircleRtextsArray[1] = 'Specify centre and radius'
!CircleRtextsArray[2] = 'Pick three points on the
circumference'
!!MyForm.Circle.Rtext = !CircleArray
20.8.4 Setting and Getting the Current Selection
The default selection is the firs t value in the list. You can exp licitly set the currently selected
value by means of the option gadget's select()  method:
!!Layout2.Colour.select('Dtext','Orange')
!!MyForm.Circle.select('directory/circle/cenrad')
You can read  the current selection using the selection()  method. This will return the
replacement-text (or the display-text if replacement-texts were not defined):
!SelectedText = !This.List.Selection() 
The .val member reads the index number of the currently selected value:

--- Page 196 ---
12 Series  20:32 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!ChosenNumber = !!Form.List.Val
The clear()  method will discard both displa y- and replacement-text lists:
!!MyForm.Colours.clear()
20.9 Slider Gadgets
The SLIDER  gadget allows you interactively to generate values in a specified range, at
specified steps. PML supports both vertical and horizontal SLIDERS .
An example SLIDER  definition is:
Frame .fr2 |Slider 2| at xmin form ymax anchor All width 20
text .t2  wid 3 is REAL
slider .sl2  vertical  anchor All  range -50 +50 step 5 val 0
height 5 
exit
20.9.1 Event Callbacks
The SLIDER  gadget responds to left-mouse SLIDER  START , MOVE , and stop events at
which it executes the gadget’s callback if one is defined. 
We recommend you use an open-callback (PML func tion or form method) as it includes the
action ‘START’ , ‘MOVE’  or ‘STOP’ . For example the form method . serviceSlider  would
have the signature
define method .serviceSlider( slider is GADGET, action is
STRING )
The callbacks for action START  and MOVE  are not followed by an automatic update, for
efficiency reasons, so you may need to follow some gadget modifications carried out in thecallback with a !gadget.refresh(),  e.g. modifying a TEXT  gadget to track the
SLIDER ’s current value.
The MOVE  callback is generated at each step increment in the SLIDER ‘s range.
20.10 Line Gadgets
The LINE gadget gives th e ability to display horizontal or ve rtical lines to separate groups of
gadgets on a form, for increased clarity of intent. The line's presentation reflects the colourof the current Windows scheme.


--- Page 197 ---
 Software Customisation Guide
Gadget Set
12 Series  20:33 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.A Line gadget can be defined by line .horiz  'H-Line'  Horiz  width.f3 height.t1
The line's width and height can be set either specifically or in terms of the width of other
gadgets on the form. 
Setting the height for a Horizontal separator or  the width for a Vertical separator causes the
line to be drawn across the middle of the implied area. This allows for equal spacing oneach side of the separator line. If the width or height is omitted then a default value is
assumed.
The line's Dock and Anchor attributes allow it  to be dynamic and respond to interactive
changes in form size.
The Line has the following restrictions:
• The tag text is never displayed.
• It cannot not appear in toolbar frames.• It is not interactive and has no associated value.• It supports the standard default gadget members and methods only.
20.11 Numeric Input Gadget
The NUMERICINPUT gadget allows numeric in put within a specified range, with given
granularity. It has Up/Down arrow icons whic h control incrementing and decrementing the
displayed value by the specified increment, within the range. The tag text is alwaysdisplayed. 
Additionally it is possible to ty pe in the required value, which is adjusted to the nearest valid
value in the range. The default initial valu e is the minimum value of the range and the
maximum value is adjusted so that the ra nge is an integral number of steps.
It is not possible to provide user formatt ing of the values displayed by the gadget.
It has the following properties and methods:
The NumericInput gadget supports SELECT an d MODIFIED events, and users may provide
a callback method to service these events. Note that often no callback is required, and the
numeric input value is merely read and used by other gadgets of the form.
A SELECT event is raised whenever the user c licks ENTER while the numeric input display
field has focus. Typically this happens after th e user has typed in a required value, but will
also apply if the user enters the field after modifying the values using the up/down arrows.
The callback can be a simple or an Open callback.
A MODIFIED event is raised fo r each modification of the displayed value using the up/down
arrows. Modified events are only reported if they are enabled and the user has provided anval is REAL - value of the numeric input.
range is array of REAL - a real array with members Start, End and step (>0).
ndp is REAL - (read only) the number of decimal places. If zero then all
values will be integer.
editable is BOOLEAN - enable/disable abilit y to edit the displayed value.
modified  is BOOLEAN - enable/disable modified events.
setRange (!range is array of REAL, !ndp is REAL)

--- Page 198 ---
12 Series  20:34 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Open callback, as this allows differentiati on from the SELECT events. The default state is
modified events disabled.
20.12 List Gadgets
A list gadget  allows the user to make single or mult iple selections from  many alternatives.
The list of choices is scrollable if the list is too long to be displayed all at once.
A LIST  gadget is thus appropriate if you have a long  list of choices, or if you are constructing
the list dynamically (at run time), especially if  you cannot predict how many choices there
will be.
You must specify whether the g adget is a single or multiple-choice list, and give the width
and height of the displayed portion. 
The length defines  the number of choices that will be  visible within th e gadget. You may
optionally specify a text tag to be displayed at  the top-left above the gadget, the position on
the form and a callback command.
Typically you enter text values into the list us ing an array of strings and assigning to its
Dtext  member.
list .List 'Select some of these' MULTIPLE width 15 height 8
!Elements[1]= 'Element 1'
!Elements[2]= 'Element 2'!Elements[3]= 'Element 3'
!Elements[4]= 'Element 4'
!Elements[5]= 'Element 5'!Elements[6]= 'Element 6'
!This.List.Dtext= !Elements
More examples:
list .Components SINGLE  width 10 height 15list .Components 'Colour:' AT . . .  MULTIPLE width 10 height 15
list .Elements 'Elements to be deleted' callback '!this.Delete'
MULTIPLE  width 10 length 15
As with the option gadget, the list gadget actu ally contains two parallel lists, of the same
length, one containing display values ( Dtext ) and the other containing replacement values
(Rtext ).
The Dtext  values must  be supplied, but the replac ement values are optional.
If you don’t supply the Rtext  values they will default to the Dtext  values. The Rtext  values
are often used to assign callback strings to each field of the list.
Resetting a list gadget's display-texts auto matically deletes the existing display and
replacement-texts and clears any current sele ctions. For example, the contents of gadget
List of Figure 20:2.: The tabbed pages of a complex form  could be replaced by:
!Choices[ 1 ] = 'Tea'!Choices[ 2 ] = 'Coffee'
!Choices[ 3 ] = 'Chocolate'

--- Page 199 ---
 Software Customisation Guide
Gadget Set
12 Series  20:35 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!This.List.Dtext = !Choices
You can replace the list’s Rtext  with a new array of the same length without disturbing the
current Dtext s:
!newRtext[1] = ‘drink6’
!newRtext[2] = ‘drink4’
!newRtext[3] = ‘drink12’!This.List.Rtext = !newRtext
You can use the new Add methods to add a single new entry to be appended to LIST  and
SELECTOR  gadgets:
Add( !Dtext is STRING ) 
Add( !Dtext is STRING, !Rtext is STRING )
Where Dtext  is the text to be displayed in the option list, and Rtext  is the replacement text
for the new field.
If Rtext  is not specified, it will be set to the Dtext  string by default.
20.12.1 Single Choice List Gadgets
You can set and get the current selection in a single -choice list using the display-text,
replacement text, or .val member. For example:
!This.List.val =2 - selects second list field
!This.List.Select( 'Dtext', 'Coffee' )!This.List.Select( 'Rtext', 'drink4' )
!fieldNumber = !This.List.val
!Rtext = !This.List.selection()
!Dtext = !This.List.selection(‘Dtext’)
Zero-Selections and Single Choice List Gadgets
You can also define a single-choice list-gadget to allow zero-selections..The list syntax allows you to define the gadget with the SINGLE ZEROSELECTIONS
keyword to indicate that the list is single ch oice with no mandatory selected field, e.g.
list .List  |Cars|  Anchor all  single zerosel    width 25
length 10
The val member now allows programmatic de-selection of the current field.For Single choice lists the keyword NORESELECT disables UnSelect and Select events
when the currently selected field is clicked with the mouse, for example:
list .l1 |List gadget| zeroSel noReselect width 15 length 5
tooltip 'single choice list'
For ZeroSelection lists it is now possible to interactively deselect the selected field by
clicking in unused rows or after the last column.
Single choice List gadgets support UNSELECT ev ents. Typically when a field is selected, an
UNSELECT event is raised for the previously  selected field (if any) and then a SELECT

--- Page 200 ---
12 Series  20:36 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.event is raised for the new field. An UNSELECT event is raised whenever a selected field is
interactively deselected.
Notes:
1. UNSELECT events are not notified to PML un less an open callback has been specified
(so that SELECT and UNSELECT even ts can be differentiated). 
2. Typically the UNSELECT action allows Appware to manage consequences of
deselection for any dependent gadgets or forms.
3. It is recommend that you do not change the List's selection programmatically in an
UNSELECT event.
See the Software Customisatio n Reference Manual for more information.
20.12.2 Multiple C hoice List Gadgets
You can read  the current selections in a multiple-choice list using the selection()
methods. This will return  the replacement-texts:
!Xarray = !This.List.selection() - returns selected replacement
texts by default
!Xarray = !This.List.selection(‘Dtext’) - returns selected
display texts
To read the index numbers of the currently se lected fields of a multi-choice list gadget:
!ChosenNumbersArray = !!Form.List.Val
You can read back the current Dtext s or Rtext s as an array or simply as strings:
!array = !This.List.Dtext - get all the Dtexts
!string = !This.List.Rtext[3] - get Rtext of the third list
field
You can select fields of this list ei ther singly (additive) or by array of Dtext  or Rtext , using its
select()  methods:
!This.List.select(‘Rtext’, ‘Tea’)!This.List.select(‘Dtext’, !array)
Callbacks on Multi-Choice List Gadgets
At PDMS11.6 we introduced su pport for Extended Selection M ode for multi-selection lists,
whereby CTRL  and SHFT  keys can qualify the list select ion. As a result a whole set of
UNSELECT  events followed by a whole set of SELECT  events can result from a single
(atomic) user action. These events are pres ented in sequence, but AppWare cannot tell
where the sequence starts or ends.
At PDMS11.6, problems may arise if a mult i-selection list is pr ogrammatically changed
during the list callback. Modifying the list content or its selection during the sequence cancause unexpected results or even software crashes.
At PDMS11.6Sp1 we nave introduced new START  and STOP  batch actions to bracket the
sequence of UNSELECT  and SELECT  event actions.
For maximum upwards compatibility, the START  and STOP  batch actions are only notified
to PML if the user has assigned an open callba ck, since this is the only way that different
event types (actions) can be differentiated.

--- Page 201 ---
 Software Customisation Guide
Gadget Set
12 Series  20:37 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.AppWare which used simple callbacks and worked at PD MS11.6 will continue to work
because START  and STOP  events will not be notified to it.
AppWare which used open callbacks and worked at PDMS 11.6 will continue to work if the
SELECT  and UNSELECT  meta-events were explicitly di fferentiated in the callback, as
shown below, because the new START  and STOP  events will be ignored
Define method .listSelectionChanged( !list is GADGET, !action
is STRING )
. . .
if( !action eq ‘SELECT’ ) then
. . .
elseif( !action eq ‘UNSELECT’ then
. . .
endif
. . .
endmethod
If you experience a change in behaviour, then you may need to rewrite your callback to
explicitly handle the new START  and STOP  events and modify the list content or its
selection only on receiving the STOP  event action.
For newly written AppWare we strongly advis e you use open callbacks to service multi-
selection list gadgets.
20.12.3 Multi-Column List Gadgets
You can simulate a multi-column  list using spaces and tabs if you are using a fixed-width
font. But if you are using a proportionally spaced font, then you cannot do this and
guarantee the column s will always line up.
The list gadget may have multiple columns as shown in the following example, which is also
a single-choice, zero-selection list. The column  widths can be interactively modified using
the mouse cursor in the headings row.
Figure 20:3. Multi-Co lumn List Gadget


--- Page 202 ---
12 Series  20:38 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The number of columns is deduced from the List 's data. If the user specifies a set of (1 or
more) column headings before the list is populated, then this will determine  the number of
columns. If no headings are pre-specified then the number of columns is deduced from the
display text of the List's first row. This pr ovides upwards compatibilit y for existing Appware
using single column lists.
A List gadget's headings can be replaced afte r the list has been populated. If the new
headings specify the same number of column s then the headings are replaced but the List's
data fields and selection remain unchanged. If the number of columns is different, then the
list is replaced by an empty list with the new headings. Invoking the Clear() method will clear
the list's data fields and rebuild the current headings.
The column headings, and hence the number of  columns, for the list are assigned as an
array of STRING :
!This.List.SetHeadings( !headings )
The Dtexts  for each column of each row of the list can be provided as a PML array, where
each element is an array of STRING . This can be row oriented or column oriented.
!This.List.SetRows( !rows )
!rows is an array of ‘row arrays’, and its size determines the number of rows in the list.
!This.List.SetColumns( !columns )
!columns is an array of ‘column arrays’, a nd its size must match the number of columns of
the list. The size of all the co lumn arrays must be the same and determines the no of rows in
the list.
The default width of each column is determined by the longest header or Dtext  value
supplied. Rtext  values for each row are supplied as for single column lists.
Selection within the list ap plies to the entire row not individual cells, but rows of the list can
be selected on the basis of a column’s Dtext :
Select( !column is REAL, !dtext is STRING )
This selects the first list ro w whose column has the given Dtext . If the list is a multi-choice
list then repeated use of this method will add sele cted rows to the list.
Note: For a multi-column list gadget each row’s Dt ext string is held as a ‘horizontal tab’
character separated string of column data, matching the column headings (asopposed to a simple string for single column list). The standard list members val,
Dtext, Dtext[n] and methods  Select( ‘Dtext’, …), Selection( ‘Dtext’ ) work on multi-
column lists with the following limitations:
• Querying Dtexts will return the tab separated strings.
• Supplying Dtext to populate the list or invoke selectio ns will require tab
separated strings as input.
See the Software Customisatio n Reference Manual for more information.
Popup-Menus on Multi-Column List Gadgets
List gadgets with a popup menu  assigned to them will pop up  the menu wh en the right-
mouse button is released when the cursor is over the list title or any list selection field.
For multi-column lists ri ght-mouse in a list field will first select that fi eld, and unselect any
other selected fields, before the popup appears. This selection behaviour does not occur for
single column lists.

--- Page 203 ---
 Software Customisation Guide
Gadget Set
12 Series  20:39 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The use of popup menus on list gadgets can be confusing so use them with care.
20.13 Database Selector Gadgets
A database selector  is a special kind of list gadget. It provides a mechanism for displaying
the current database element along with its owner and members. The user can also interactwith a selector to change the current element. 
A single-choice selector  permits only one selected value at a time. A typical example is the
PDMS  Members List .
A multiple-selector could be used to display the results of querying database attributes or to
select a group of elements for modification.
Its definition is similar to list gadgets.
selector .Mem 'members:' SINGLE width 12 height 8 DATABASEselector .Mem SINGLE width 12 height 8 DATABASE OWNERS
selector .Mem SINGLE width 12 height 8 DATABASE MEMBERS
selector .Mem AT . . .  SINGLE width 12 height 8 DATABASE AUTO
selector .Mem  AT . . .  MULTIPLE width 12 height 8 DATABASE 
selector .Mem callback '!this.MyList(' MULTIPLE width 12 height
8 DATABASE 
The DATABASE  keyword is mandatory.
The owners  and members  keywords are optional.  By default, a database selector displays
the current element together with elements both above it and below it in the databasehierarchy. If present, the owners  keyword specifies that only  elements above the current
element are shown. If present the members  keyword specifies that only elements below the
current element are shown.
If auto  is specified, the selector  automatically refreshes its displayed contents whenever
the current element of the database changes. If absent, the contents of a selector remain as
they were when the gadget was initially displaye d until the gadget is explicitly refreshed by
your PML code. The auto  keyword and the multiple  keyword cannot be used together.
To set and get selected values for a selector  use the select() and selection()
methods, and the .val members, as you do for lists. For example, to access the currently
selected value of a single-selector gadget:
!element = !This.Members.selection()
Note that for a selector gadget, the Rtext  and Dtext  are always the same as one another. 
20.14 Text Gadgets
A text gadget is a box that can display a value and into which the user may type a value, or
edit an existing value.
To type into a text gadget on a form it must have the keyboard focus  to receive the
keystrokes typed by the user. The user can move the focus to another text gadget byselecting it with the mouse or stepping from one gadget to the next using the TAB key.
text .number AT . . . width 10 is REAL

--- Page 204 ---
12 Series  20:40 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.text .name 'Name:' callback '!!MyFunction' width 10 scroll 100
is STRING 
text .active 'Active:' callback '!!MyFunction' width 10 is
BOOLEAN
text .bore 'Bore:' width 10  is BORE  format !!FormatBore
text .password 'Password:' AT . . . width 10 NOECHO is STRING
You must:
• Specify the WIDTH , which determines the maximum number of character spaces
visible. Optionally you may specify a larger SCROLL  width, which is the maximum
number of characters that the gadget can hold, and scroll through. The default scroll-
width is 132 characters. The maximum is 256 characters.
• Specify a data type using IS which determines how a value assigned to the gadget will
be displayed and how a value typed by the user will be inte rpreted by your PML code.
You may also supply a FORMAT  object which specifies in detail how a value is to be
displayed or interpreted (see below).
You may optionally
• Specify a tag name to be displayed to the left of the gadget.
• Specify a callback command.• Specify a position on the form.• Specify a NOECHO  keyword that indicates any characters typed should be displayed
as stars: a typical use would be a gad get for the user to enter a password.
• Give the text gadget an initia l value, which will be the value accessed by your PML
code if it is not modified by the user. To set an initial value for a te xt input gadget, use its
.val member:
This.name.val = 'PIPE-1'
• Specify whether the text displayed is editable interactivel y or is read only.
When you type into a text gadget its background color changes from white to beige to
indicate that has been modified. Its content is actioned when you press Enter  while the
text gadget has focus, or if you press a button on the form.
When a field is actioned its content is read and validated according to the field’s type (see
Validating Input to Text Fields ). If an error is detected, t hen the field’s background colour
changes to gold to indicate an error and focus is returned to it so that the user can correctthe error. If no error was detected then the text gadget’s callback (if any) is executed 
To get the current value of a text input gadget:
!Value = !This.name.val
The data type of the variable !Value will be the same as the type of the text gadget. To get
the textual value use:
!string = !Value.String()
To set the keyboard focus so that  keystrokes come to this gadget:
!This.name.SetFocus()
20.14.1 Controlling Text Gadgets’ Editing
Text fields have a member Edit able (read/write), which controls  the user's ability to edit the
displayed text interactively, e.g.
!this.myTextField.editable = false

--- Page 205 ---
 Software Customisation Guide
Gadget Set
12 Series  20:41 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Makes the field read only.
Modified Events for Text Gadgets
When the user finishes modifying the field by clicking ENTER  while the field has focus, or
pressing any button on the form, the field co ntent is validated. If valid, then the field’s
callback (if any) is noti fied (executed) of a SELECT  event, and the field returns to ‘white’
again indicating that it is no longer modifi ed. Otherwise an error is detected, the field’s
background colour becomes ‘gold’ and focus is returned to it for further modification.
The setEditable method allows PML to be notified when the displayed text is modified by
user interaction
setEditable( !attribute is STRING, !value is REAL )
Currently the only attribute supported is HANDLEMOIFY  which may have the integer values:
•0  MODIFIED  events off (default).
• 1 Generate MODIFIED  event at first user modification only.
Note: MODIFIED  events are not notified to PML unless the field is editable, modified
events are enabled and an open callback has been specified (so that MODIFIED  and
SELECT  events cannot be differentiated)
Typically, the first MODIFIED  event is used to allow AppWare to gain control and modify the
properties (e.g. ACTIVE  status) of dependent gadgets, which possibly the user should not
have access to unt il the text field’s VALIDATE  and SELECT  events have been handled.
The code fragment below defines an RTOGGLE  that allows a user specified TV program to
be typed into an associated TEXT  gadget. 
rToggle .rad6 tagwid 7 |TV:| States '' 'TV'
text .TV width 10 is STRING
!this.rad6.callback = '!this.RGroupSelectionChanged('
-- set open callback on text field and option list
!this.TV.callback = '!this.selectProgram('!this.Radio.callback = '!this.selectProgram('
- handle first Modified event only
!this.TV.setModified( ‘handleModify’, 1 )
The extended (open) callback selectProgram( , shown below, inte lligently handles the
TEXT  gadget and OPTION  list. The open callback RGroupSelectionChanged  sets the
value of the ‘TV’ RTOGGLE  from the TEXT  gadget.
define method .selectProgram( !gad is GADGET, !event is STRING )
-- Select new program from option list or text input field
if( !gad.type( ) eq 'TEXT' ) then
-- Control active state of R-toggle according to modified
state of textfield
!rtog = !this.rad6
if( !event eq 'MODIFIED'  ) then
-- deactivate R-toggle
!rtog.active = false

--- Page 206 ---
12 Series  20:42 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.elseif( !event eq 'SELECT' ) then
-- reactivate R-toggle
!rtog.active = true
endif
else
-- select radio program from option list
!rtog = !this.rad5
endif
if( !this.rg1.val eq !rtog.index ) then
-- deselect current selection!this.rg1.val = 0
!this.choice.clear()
endif
endmethod
define method .RGroupSelectionChanged( !rtog is GADGET, !event
is STRING )
-- Service specified radio-toggle eventsif( !event eq 'UNSELECT' ) then
-- Do some application actions
!this.choice.clear()
elseif( !event eq 'SELECT' ) then
!value = !rtog.onValue
-- Do some application actions
if( !value eq 'radio' ) then
!value = !this.Radio.selection('dtext')
elseif( !value eq 'TV' ) then
!value = !this.TV.val
endif!this.choice.val = !value
endif
endmethod
20.14.2 Copying and Pasti ng into Text Fields
The text gadget supports the standard copy and paste mechanisms:
• Use the mouse Select  button  to copy and the mouse Adjust  button  to paste. 
• Use shortcut keys, for example: Ctrl C  to copy, Ctrl V  to paste.
• Use the system Edit popup menu
Pasting into a field acts like typi ng in, and will set the text field’s Modified  appearance.

--- Page 207 ---
 Software Customisation Guide
Gadget Set
12 Series  20:43 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Note that user defined Popup menus are not su pported on Text gadget s because they clash
with the system-supplied Edit menu.
20.14.3 Formatting in Text I nput Gadgets: Imperial Units
The FORMAT  object manages the information needed to convert the value of an object or
type to a STRING , and vice versa. 
The FORMAT  object for a specific data type is normally a global PML Variable used for all
text gadgets of that type. 
For example, you can create the FORMAT  object for a REAL  object, so that a distance is
displayed in feet-and-inches  with fractions (rather t han decimals) with a maximum
denominator of 4:
!!RealFMT = object  FORMAT()
!!RealFMT.DIMENSION =  'L'
!!RealFMT.UNITS =  'FINCH'!!RealFMT.FRACTION = TRUE
!!RealFMT.DENOMINATOR = 4
!!RealFMT.ZEROS =  'FALSE'
See the Software Customisation Reference Manual  for more information on the FORMAT
object.
The TEXT  gadget is created with type REAL  and assigned a FORMAT  object for converting
values to and from text:
text  .Dist  'Distance:'  width 10  is REAL   format !!RealFMT
When we assign a value in millimetres  to the text gadget:
!!Form.Dist.val = 3505.2
The display-text of 11' 6  will be shown in the text gadget.
To switch from displaying feet-and-inches  to displaying mm all that is necessary is to
change the setting of the units  member of the format object RealFMT  from FINCH  to MM.
The associated format also dete rmines what can be typed into  the field. If the associated
format is FINCH  or MM then you can enter distances in either inches or feet and inches.
For example:
Note that in every case the text field value is actually held in millimetres  so that the
command:
q var !!Form.Dist.valChosen Units Typed-in Value Displayed Value
FINCH 138 11' 6
INCH 138 138
INCH 11' 6 138
MM 3505.2 3505.2

--- Page 208 ---
12 Series  20:44 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.prints
3505.2.
You can use the format object in your PML code when converting a value to a STRING :
!StringValue = !!Form.Dist.val.String(!!RealFMT)
20.14.4 Unset Text Fields
All of text fields displayed a text string representing the value of a variable or object of a
given Type. The string representing an unset value is ‘ Unset’.
See Unset Variable Representations  and UNSET Values and UNDEFINED Variables  for a
discussion of unset variables.
Note: Some older style ‘untyped’ PML1 text fields use the (null) string ‘’ to represent unset
values for numeric fields. You should  avoid using these old style fields.
You can force an unset value for any text field (of any type) using:
!Ths.MyTextclear()
You can also assign an unset value to a text field:
! = REAL() - defines an unset variable type REAL! = STRING() - defines an unset variable type STRING
!This.MyText = !x
You can check for an unset text gadget of any type using the BOOLEAN
method unset():
If( !This.MyText.val.Unset()) then
-- value of text is unset
...
endif
20.14.5 Validating Input to Text Fields
The text field gadget has an optional validatio n callback member which the user can specify:
!textfield.ValidateCall = <callback string>
When a text input field is action ed (by modifying it and pressing ENTER , or when a button
on the form is pressed or the form's OKcall  is executed), it is automatically checked to
ensure that the typed-in value matches the field's TYPE  and its FORMAT  constraints. If so,
then the user's VALIDATECALL  is actioned.
The VALIDATECALL  is used to apply any checks you want. If an error is  encountered then
the callback raises the error and returns.
Note: The validation callback must not attempt to change the value of the text field. It
should just detect and raise an error.
When an error is raised, an error alert is displayed and the text field is left with keyboard
focus and error highlight. No further form or gadget callbacks are executed and the form isnot dismissed from the screen. The User ca n then modify the field and re-action it.

--- Page 209 ---
 Software Customisation Guide
Gadget Set
12 Series  20:45 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The VALIDATECALL  is a standard callback, and so it can be a single command, a PML
function, method or macro, or an open PML method or function. For an open callback, forexample:
!textField.validateCall = ‘!this.textvalidate(‘
the corresponding method must be:
define method .1textvalidate( !textin is GADGET, !action is
STRING )
where the action string will be 'VALIDATE'.
An Example of Text Validation:
The form !!ValidForm  has two text fields of types REAL  and STRING .
There are limits on the values that can be typed into each field: the tooltips on each field
explain the constraints. 
The textvalidate  method determines from its !textin  parameter which field is being
validated, and applies the constraints that have been defined. The Handle block traps anyunexpected PML errors generated by the validat ion code. The first if-block of the validation
code checks that th e text field is not unset. This also prevents the possibility of unexpected
errors in the validation code.
 -- $Header: /dev/eventlayer/PMLLIB/validform.pmlfrm 1     17/
09/04 13:37 Robin.langridge $
-- PDMS Customisation User Guide
-- Form ValidForm - Demonstrate text field validation
setup form !!ValidForm dialog 
TITLE |Text Handling|
HDIST 3
text .T1 |Real| at wid 8 is REAL tooltip'range 0.0 to 100.0'
text .T2 |String| wid 12 is STRING tooltip'anything but FRED'
button .CANCEL at XMIN FORM YMAX FORM CANCELbutton .OK at XMAX FORM - SIZE YMAX FORM - SIZE OK
exit
define method .ValidForm()
-- constructor
!this.t1.validatecall = '!this.textvalidate('
!this.t2.validatecall = '!this.textvalidate('!this.OKcall = '!this.printValues()'
Endmethod
define method .textvalidate( !textin is GADGET, !action is
STRING )
-- validate the given field contents
-- General form of Validation Callback
-- !action will contain 'VALIDATE'

--- Page 210 ---
12 Series  20:46 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.onerror golabel /Errors
label /Errors
--  Include handle block for any unexpected PML errors
handle ANY
-- Example: can get errors from evaluation of the String field
-- with an 'unset'value
return error 1 'Invalid input'
endhandle
-- Validation code -------------------------------------
-- Check for unset field first (to avoid possible unexpected
errors)
if( !textin.val.unset() ) then
-- validation callback Failed
return error 2 'Field is unset'
else
 !field = !textin.name()
if(!field eq 'T1') then
-- TYPED field must check range
!x = !textin.val
if(!x lt 0.0 or !x gt 100.0) then
return error 1 'value must be in range [0.0 to 100.0]' 
endif
elseif(!field eq 'T2') then
-- any string but FRED
if(!textin.val eq 'FRED') then
return error 4 'value must not be FRED'
endif
endif
endif
endmethod
define method .printValues()
!r = !this.t1.val
!s = !this.t2.val
$p values $!r and $!s
Endmethod
20.14.6 Setting the Valu e of a Text Field
A special SetValue()  method allows you to set the value of a field programmatically, with
full interactive checking applied:

--- Page 211 ---
 Software Customisation Guide
Gadget Set
12 Series  20:47 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved..setValue( !value is ANY, !doCallback is BOOLEAN )
• If the value’s type fails to match the field type, a trappable error is raised.
• If the types match, the value is validated and the VALIDATECALL  is run, if there is one.
• If the value is invalid then a tr appable error is raised. If the field is shown then it is set 'in
error', and the focus is returned to it so that the user can edit the value.
• If the value is valid then the method executes the field callback if ! doCallback  is true.
20.15 TextPane Gadgets
A textpane gadget  provides a box on a form into which a user may type and edit multiple
lines of text or cut and paste text from elsewhere on the screen. 
The contents of the textpane can be set and queried by your PML code. Optionally the text
contents can be made non-editable. 
You must specify the initial shape of the ga dget. Optionally you may also supply a form
position and a tag to be displayed to the top-left of the gadget.
textpane  .text  'Text:'  AT . . .  width 10  height 20
textpane  .text  'Text:'  AT . . . height 20  aspect 0.5
The value of a textpane is its current contents as an array of strings, where each element of
the array corresponds to a line of text in the gadget.
To make the textpane’s contents read-only, use the seteditable  method:
!This.text.seteditable(FALSE)
To clear the current contents of a textpane gadget:
!This.text.clear()
To move the keyboard focus to this textpane gadget:
!This.text.setfocus()
To enquire how many lines of text a text pane gadget currently contains, use the count
method:
!Nlines = !This.text.count
To set line 21 in a textpane gadget to 'Hello World ':
!This.text.setline( 21, 'Hello World' )
To read the current contents of line 21 as a string variable:
!Line = !This.text.line(21)
To set the entire contents of the text pane gadget to an array of strings:
!Lines[1] = 'Hello World'
!Lines[2] = ' '!Lines[3] = 'Goodbye World'
!This.text.val = !Lines
To read the entire contents of the textpane gadget as an array of strings:
!LinesArray = !This.text.val

--- Page 212 ---
12 Series  20:48 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.To set the current cursor position within a textpane gadget to line 21, character 15 you can
use:
!This.text.setcurpos(21, 15)
or
!ArrayRowColumn[1] = 21
!ArrayRowColumn[2] = 15
!This.text.SetCurPos( !ArrayRowColumn )
To read current cursor posit ion within a textpane gadget:
!ArrayRowColumn = !This.text.CurPos()
20.15.1 Fixed Width Font
The Textpane gadget definition has a new keyw ord ‘FixChars’ to force the use of a fixed
width font. 
This allows the text pane to be used to show simple reports laid out using the space
character.
The chosen font is Courier New  (TrueType), because it has a reasonable selection of
character glyphs (nowhere near as extens ive as the default variable width font Arial
Unicode MS ).
.--------<--------.
 /|
>-- TEXTPane gname --+-- tagtext---------|
 +-- <fganch> -------| +-- <fgdock> -------|
 +-- <fgpos> --------|
 +-- FIXCHARS -------| +-- CORE -----------* Core managed gadget '-- <vshap> --->
Example
SETUP FORM !!textbug  dialog dock right NoAlign VarChars
   TITLE |Text input and output (!!textbug)|. . .
   -- Text pane --------------------------------------------
   Path down   hdist 1
   vdist 0.1
   --Default: variable spaced font
   textpane .tp1 |text pane| at xmin form anchor l+r+t wid 43 hei 9
. . .
define method .initialise()  -- initialise on show
  -- add data into textpane
    !s[1] = | 1 Ford       Escort|    !s[2] = | 2 Ford       Fiesta|
    !s[3] = | 3 Vauxhall   Nova|

--- Page 213 ---
 Software Customisation Guide
Gadget Set
12 Series  20:49 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.    !s[4] = | 4 Vauxhall   Astra|
    !s[5] = | 5 Vauxhall   Lotus|
    !s[6] = |16 LandRover  RangeRover   £62000|
    !s[7] = |17 LandRover  Defender     £23999|  !this.tp1.val = !s
. . .
Variable Spaced Font
Fixed Space Font
--Force fixed spacing font
textpane .tp1 |text pane| at xmin form anchor l+r+t FixChars wid 43 
hei 9
20.16 Fast Access to Lists, Selectors and Textpanes using 
DO Loops
Sometimes you may have large quantities of data  in list, selector or textpane gadgets and
you may find that accessing the data using the selection()  methods may be very slow. 
The PML textpane mechanism allows fast access to these gadgets.


--- Page 214 ---
12 Series  20:50 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.With a textpane gadget you can use do list  so that the do counter takes th e value of the
replacement-text for each of the currentl y selected rows of the list in turn:
do !field list !!FormA.listC
$P Selected field replacement-text is $!field 
enddo
For a selector gadget you must use do selector  so that the do counter takes the
displayed value of each of the currently selected rows of the list in turn:
do !field selector !!FormA.SelectorB
$P Selected field replacement-text is $!field 
enddo
For a textpane gadget you must use do pane  so that the do counter takes the value of
each of the displayed lines in turn: 
do !line pane !!FormA.TextPaneD
$P Text line value is $!line 
enddo
Note: That on exit from the loop PML destroys the do variable for each of these gadget
types.
20.17 View Gadgets
Horizontal and vertical scro ll bars will appear as necessary.
The types of view gadgets supported are:
• ALPHA views for displaying text ou tput and/or allowing command input.
• PLOT views for displaying non-interactive 2D plotfiles. 
• Interactive 2D graphical views
• Interactive 3D graphical views
See Manipulating VIEWS , for details on how to manipulate the 2D and 3D interactive
views.
20.17.1 Defining a View Gadget
A view is defined by the command sequence view … exit:
view .MyView AT . . . viewtype
height 10 width 20 
contents
attributes
exit
The command sequence may optionally be given on a single line, without the exit :
view .MyView AT . . .  viewtype  height 10 width 20 contents
attributes
Where the contents  and attributes  that depend on the type of View.

--- Page 215 ---
 Software Customisation Guide
Gadget Set
12 Series  20:51 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.You do not have to set any attributes and we re commend that you set the view’s attributes in
the form’s default constructor method rath er than in the form setup definition.
20.17.2 Resizable View Gadgets
When the size of the form is changed by the operator, the size of a view gadget is
automatically adjusted to fill the space available in its container . The origin of the view (the
top left-hand corner) always remains fixed in position and the view’s bottom right-handcorner adjusts according to the available space.
Note that view gadgets do not support the ANCHOR and DOCK  attributes. If you want a
view that has these behaviours, you can place it in a frame gadget that you declare with the
attribute you desire. Si nce the view will expand to fill the frame, it will be as if you had an
anchored or docked the view gadget.
20.17.3 Pop-up Menus in Views
When you create a view, it will automatically be created with a defau lt popup menu, which
will enable users to cont rol the attributes of the View, su ch as the action of the mouse
buttons, and whether borders are displayed.
You can assign popup menus to view gadgets using the gadget’s setpopup()  method,
with the name of the popup menu as the argument to the method. For example:
!MyForm.MyView.setpopup( !MyForm.pop1 )
Note: The standard graphical view forms in AVEVA products are normally supplied with
fully customised popup menus, so you should not assign your own ones to theseviews
20.17.4 Defining Alpha Views
view .Input AT . . . ALPHA
height 20 width 40 channel COMMANDS
exit
view .InputOutput AT . . . ALPHA 
height 20 aspect 2.0 
channel REQUEST
channel COMMANDS
exit
Borders and scroll bars cannot be turned off and the area they occupy is in addition to the
size you specify for the gadget.
To define the data channel  via which the gadget derives it s alphanumeric content, use the
channel  command:

--- Page 216 ---
12 Series  20:52 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.To set the keyboard focus so that  keystrokes come to this gadget:
!This.InputOutput.SetFocus()
To clear the text output region of an alpha view use:
!This.InputOutput.clear()
It is not an error to have no associated channels when an alpha gadget is created.
Removing the Requests IO-channel from Alpha View Gadget
To delete the ‘requests’ channel from an alpha view gadget us the command:
!alpha.removeRequests()
This command will also dissociate the view fr om the current PDMS Requests IO-channel if
necessary. 
Thus request output  will no longer go to this alpha view.
The method is valid only on a form that has been mapped to the screen, and will cause an
error (61, 605) if used during form definition.
Note that you can add the channel back again by assigning to the gadget’s .channel
member:
!alpha.channel = ‘Requests’
This adds the ‘requests’ channel to the gadge t, and causes it to become the current PDMS
requests region , if the form is mapped, and displaces any previous association.
When the user clicks on an alpha view it will automatically associate itself with the PDMS
requests channel or the commands channels, or both, according to its current channelsettings.
The Alpha view gadget supports multiple lin e copy and paste of text. The simple command
window form below shows the appearance. channel COMMANDS causes the alpha view to have a command input
field and displays command lines and errormessages in the scrollable output region
channel REQUESTS displays the output resulting from commands, in
particular, queries in the scrollable output region

--- Page 217 ---
 Software Customisation Guide
Gadget Set
12 Series  20:53 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The bottom-most empty blank line is the command input line, where the user can type in,
and execute the next command by pressing the 'enter' key.
The Alpha view allows the following operations:
1. Double-click of any displayed line will copy that line to the command input line ready for
editing and execution.
2. You can use standard techniques to select text in the view and then use the right-
mouse menu to copy your selection.
3. You can use the right-mouse menu to pa ste a selection into the command line. Each
line of the pasted selection is executed in turn as if you had typed it in, except the last
line, which becomes the command input line ready for editing and execution.
4. You can use the right-mouse menu to paste a selection as a macro. The set of pasted
lines are captured to a temporary file which is then executed as PML macro. Theselected lines are not echoed into the view's display.
5. Pasting of multiple lines is abor ted if an error alert is displayed.
6. You can drag and drop a PML file into the view, and it will then execute as a PML
macro.
7. The right mouse menu also allows you to clear the contents of the view and to change
the size of text in the view's display.
20.17.5 Graphical Views
There are two types of Graphical view, namely 2D and 3D.
Different applications use 2D and 3D graphical views in different ways so each specific view
gadget must be qualified by a view subtype which identifies its usage (or application).
The Forms and Menus system supports a standard 2D view subtype PLOT  view, which is a
non-interactive view capable of displaying PDMS PLOT files.
Specific PDMS applications support their own view subtypes, for example:
• DESIGN uses 3D view subtype VOLUME  and 2D view subtype COMPARE
• DRAFT uses 2D view subtype AREA  and 3D view subtype VOLUME .
Both 2D and 3D view types support a set of common members and methods. Some
key ones are described below, befo re each subtype is dealt with.


--- Page 218 ---
12 Series  20:54 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.For a full list of View members and methods, see the Software Customis ation Reference
Manual .
View Borders
Graphical views have optional sliders or scrollbars which allow modification of the view’s
geometric transformation. They can be turned on or off using the .borders( !Boolean)
method. If the border is switch ed off, the actual display area  expands to fill the available
space.
Aspect Ratio and View Gadgets
Note when specifying the aspect ratio for a vi ew that the corresponding ratios for ISO
drawing sheet sizes are 0.7071  for portrait format and 1.414  for landscape format. 
View Colours
Graphical views have two colours associated with them, namely the background colour
and the highlight colour .
Setting Background and Highlight Colours
These can be set using the Background  and Highlight  members, either as integer colour
indices or as colour name text strings:
!view.Background = ‘black’
!view.Background = 2 
The highlight colour is the colour used to highlight selected items in the view. You can set it
by
!view.Highlight = ‘white’ 
!view.Highlight = 1
Some view subtypes ignore this attribute.
Getting Background and Highlight Colours
You can get the background and highlight colour indices from the member variables or you
can use the Highlight()  and Background() methods that return the value of the
respective property as a name string.
For instance, using the example above:
!colourname = !view.Background()
Would give us the string “ black ”, and 
!colourindex = !view.background
Would give us the integer colour index value 2.
Cursor Types
When the mouse cursor enters a graphical vi ew, the View gadget determines what cursor
type should be displayed for the user, or the representation to be assumed during agraphical interaction.
Some of he types of cursor available are:

--- Page 219 ---
 Software Customisation Guide
Gadget Set
12 Series  20:55 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Figure 20:4. Available Cursor Types
Note: The initial cursor type for VOLUME  views is a Pointer, and you cannot re-define this.
You can specify the initial setting for the cursor type in a 2D view when you define the view
gadget.
The default values for initial cursor types for PDMS  2D view types are:
You may use the CURSortype attribute  command to set an initial cursor type within the
gadget definition. For example:
Cursor  POINTER
20.17.6 Defining PLOT Views
setup form !!MyForm . . .
...
view .Diagram  AT . . .  PLOT height 20 width 40
 ..
exit
define method !!MyForm( )
-- form constructor method...
-- Initialise plot view gadget
!this.diagram.borders = false!this.diagram.background( ‘darkslate’ )POINTER
NOCURSOR
PICK
PICKPLUS
CROSSHAIR.
.
2D View Gadget Cursor Type
PLOT CROSSHAIR
DRAFT CROSSHAIR 
COMPARATOR POINTER 

--- Page 220 ---
12 Series  20:56 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!this.diagram.add( ‘plot1-1’ )
...
endmethod
The area occupied by borders and scroll bars is within the area you specify for the gadget If
the border is switched  off, the actual display area expa nds to fill the available space. 
When borders are turned off, the PLOT view becomes fixed and you cannot zoom or pan
within it. This may be useful if you are using PLOT views as if they were paragraphs; for
example, as decoration or for information.
To define the contents  of the view specify the PLOTFILE  pathname with the .add()
method.
To remove a PLOT from the current PLOT view, use the .clear()  method. This will leave
the view empty. If you want to replace the di splayed PLOT with another one then just re-use
the .add()  method with th e new PLOT file.
20.17.7 Defining DRAFT’ s Area (2D) Views
setup form !!MyForm . . .
...
view .DrawingAT . . .AREA
height 20 width 40
put /SITE1/SHEET
limits 200 100 TO 600 500
exit
...
exitdefine method !!MyForm( )
-- form constructor method
...-- Initialise AREA view gadget
!this.drawing.borders = true
!this.drawing.background( ‘beige’ )!this.drawing.highlight( ‘red’ )
...
endmethod
The area occupied by borders and scroll bars is within the size you specify for the gadget.
To define the colour items are displayed in when picked with the left-hand mouse button,
use the .sethighlight()  method with one of the standard DRAFT colour numbers or
colournames.
The contents of the view may be any valid 2D graphical element, such as a DRAFT  SHEET ,
VIEW , LIBRARY , etc. To define the contents of the view, use the put command thus:

--- Page 221 ---
 Software Customisation Guide
Gadget Set
12 Series  20:57 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.If you put new content into an area view that already contains a drawing, the original content
will be replaced  by the new, not added to it.
Note: There is currently no .put()  method! So to replace th e view contents you will need
to use the old PML1 syntax:edit view !!MyForm.drawing AREA put /site/sheet2
The maximum limits for the drawing, such that only part of the specified content is drawn
(giving, in effect, a window on the overall content area), may be set using the limits
keyword as above or using the .limits()  member in the form’s constructor method, as
follows:
!box[1] = 200
!box[2] = 100
!box[3] = 600 
!box[4] = 500!this.drawing.limits = !box
where the limits define two opposite corners of the required area in sheet co-ordinates.
For a full list of VIEW  members and methods, see the Software Customisation Reference
Manual.  
20.17.8 Defining DESIGN’s  Volume (3D) Views 
setup form !!MyForm . . .
... view .ModelAT . . .VOLUME
height 20 width 40
limits autolook east
exit
...
exit
define method !!MyForm( )
-- form constructor method...
-- Initialise 3D view gadget
!this.model.borders = falseCommand Effect
put CE Draws the current element
put /SITE1/SHEET Draws the named Sheet element

--- Page 222 ---
12 Series  20:58 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!this.model.background( ‘darkslate’ )
!this.model.shaded( true )
!this.model.projection( ‘PERSPECTIVE’ )
!this.model.radius( 100 )!this.model.range( 500.0 )
!this.model.direction( !dir )
!this.model.eyemode( .false. )!this.model.through( !thru )
!this.model.walkthrough( true )
!this.model.step( 25 )...
endmethod
The area occupied by borders and sliders is within  the area you specify for the gadget.
To enable colour-shaded  representation use the .shaded()  method. By default a wireline
representation .shaded(false)  is used.
All aspects of the 3D view transformation may be specified:
To enable PERSPECTIVE  mode use the .projection(‘PERSPECTIVE’)   method. By
default the projection is PARALLEL .
The view direction is controlled via the 3D view’s .direction  member. This is a 3 element
array of REAL , representing a direction vector in model space ( DEAST , DNORTH , DUP  ).
So to look east  you would specify:
!dir[1] = 1.0!dir[2] = 0.0
!dir[3] = 0.0
!this.model.direction = !dir
The 3D view gadget labels the view direction information in 'ENU' (E ast-West, North-South,
Up-Down) format within the view status line and scroll borders, by default. The
LABELSTYLE member allows the user to specify either 'ENU' or 'XYZ' labelling. In the 'XYZ'
scheme the form of the view direction display in the status line isx<bearing>y<elevation>z , where the bearing angle is in the range [-180, 180] and the
elevation angle is in the range [-90, 90]. The corresponding scroll bars are labelled "-Y  -X  YX  -Y" and "-Z  0 Z".
The 3D view's bearing and elevation members ca n also be used to set the view direction (if
the elevation is Up or Down then changing the bearing will have no effect on the view
direction).
The centre of interest or through point  of the 3D view is controlled via the .through
member. This is a 3 element array of REAL , representing a position in model space ( EAST ,
NORTH , UP). 
!thru[1] = 1000.0
!thru[2] = 5600.5
!thru[3] = 500.0

--- Page 223 ---
 Software Customisation Guide
Gadget Set
12 Series  20:59 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!this.model.through = !thru
The .radius()  method specifies the radius of the view in current units - an imaginary
sphere around the through point.
The .range()  method specifies how far away from the Through point you want the Eye
point to be.
To enable WALKTHROUGH  mode specify .walkthrough(true)  together with the
walking step size in current units using the .step()  method.
For a full list of View Members and methods, refer to Software Customisation Reference
Manual  for further information.
Setting Aspects of the View Transformation by Syntax
The commands below allow aspects of the view  transformation to be set using the old
syntax:
edit view !!MyForm.Model VOLUME  
followed by one of the following modifiers:
View Limits
Each volume view needs to know what region of the design model is to be displayed (the 3D
view limits). The DESIGN  application has the notion of a current limits box. Unless youModifier Effect
ELEVATION EAST Looks from  the East.
LOOK EAST Looks towards  the East.
LOOK N45W75D Looks towards  specified direction.
LOOK THROUGH E10 N50 U85 Looks through  specified point.
LOOK THROUGH /A1 Looks through  named elements origin.
LOOK THROUGH ID @ Prompts for cursor pick on Through-point.
LOOK THROUGH ID VALV @ Prompts for cursor pick on Valve for through-point.
LOOK FROM E10 N50 U85 looks from  specified point (defines eye position)
LOOK FROM /A1 Looks from  named element (as eye position).
LOOK FROM ID @ Prompts for cursor pick on from-point.
LOOK FROM ID VALV @ Prompts for cursor-on Valve for from-point.
LOOK TOWARDS E10 N50 U85 Looks towards  the given direction.
LOOK TOWARDS /A1 Looks towards  named element .
ISOMETRIC 3 Looks in specified isometric direction.
PLAN Looks down (default).

--- Page 224 ---
12 Series  20:60 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.specify otherwise, the limits set for a new view gadget will default to the DESIGN  current
limits box (as set by, say, the LIMITS  or AUTOLIMITS  commands in DESIGN ).
In addition, each volume view has an AUTO  flag associated with it, which determines
whether or not th at view will be updated aut omatically whenever the DESIGN  current limits
box is changed.
To define the view limits and the way in which they are to be updated, use the old syntax:
edit view !!MyForm.Model VOLUME 
followed by one of
You can set the limits box for a view, subject to the current AUTO  flag using the .limits()
method:
-- limits brick set as array of REAL [E1, E2, N1, N2, U1, U2]!brick[1] = 1000.0
...
!brick[6] = 1560.4!this.model.limits( !brick )
In DESIGN  you may change the current limits box at any time by using one of the command
formats
AUTOLIMITS N1000 E2500 U0 TO N3000 E5000 U2000
AUTOLIMITS /EQUI2 /EQUI4
Any volume views which have LIMITS AUTO  set will be redrawn to match the new limits.
Mousemode
3D views have a mousemode  member which can be set to Zoom , Pan, Rotate , or Walk
Saving and Restoring 3D Views
3D views have two methods which are used to save and restore up to four views, until the
user leaves DESIGN :
!!view.saveview( !n ) 
!!view.restoreview( !n )Modifier Effect
LIMITS AUTODisplay limits updated automatically to match
current view limits (default).
LIMITS LOCAL Display limits initially set to current view limitsbut not updated automatically.
LIMITS LOCAL N1000 E2500 U0 
TO N3000 E5000 U2000Display limits initially set to specified
positions and not updated automatically.
LIMITS LOCAL /EQUI2 /EQUI4 Display limits initially set to enclose thespecified elements and not updatedautomatically.

--- Page 225 ---
 Software Customisation Guide
Gadget Set
12 Series  20:61 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Where  1 <= !n <= 4.

--- Page 226 ---
12 Series  20:62 Software Customisation Guide
Gadget Set
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 227 ---
 Software Customisation Guide
Alert Objects
12 Series  21:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.21 Alert Objects
The ALERT  object provides a simple way of giving a warning or getting a response from the
user, avoiding the necessity of creating a separate form.  Where an alert needs a simple
acknowledgement by the user, this can be achieved by pressing the spacebar or the Enter
key on the keyboard.
Note: Alerts are always blocking : they prevent interaction wit h any other form until they
have been actioned.
Below are some examples of how yo u can define different kinds of alerts :
Code Effect
!!Alert.Error( 'You cannot do this!' 
)Defines a simple error alert
with an acknowledge button atthe current cursor position:Note that the result, which isalways 'YES' , has here been
discarded
!!Alert.Message( ‘Saving your data 
now')Displays a message alert  with
an acknowledge button at thecurrent cursor position:
!!Alert.Warning( ‘Do not press this 
button again!' Displays a warning alert  with
an acknowledge button at thecurrent cursor position: 
!Answer = !!Alert.Confirm( ‘You can’t 
be serious!’ )Displays a confirm alert  at the
current cursor position.
This example comes up with
two buttons: ‘ YES’  and ‘ NO’ ,
delivering the correspondingtext as the string result.

--- Page 228 ---
12 Series  21:2 Software Customisation Guide
Alert Objects
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.21.0.1 Position of Alerts
By default, an Alert is automatically positioned when it is displayed so that it is under the
cursor. Optionally, two more arguments may be supplied to specify the screen position at
which an alert is to appear:
!!Alert.Error( 'You cannot do this!' , 0.25, 0.1)
This shows the alert with its origin one quarter of the way across from the left hand side of
the screen and one tenth of the way down from the top. 
21.0.2 Input Alerts
This allows the user to obtain textual input from the operator via a blocking alert whichoverrides all other interactive activities. T he alert can be summoned by the alert methods:
!!Alert.Input( !prompt is STRING, !default is STRING) is
STRING
!!Alert.Input( !prompt is STRING, !default is STRING, Xpos
is REAL, Ypos is Real) is STRING
!prompt  is displayed to prompt the operator and !default  is offered as the default value in
the alert’s text input field.
Xpos , Ypos  define the alert’s top left hand corner in normalised screen co-ordinates.
Note: This function has been added to provide the GUI equivalent of the command
Var !x read
which is only valid in tty mode . 
To achieve flexible, user-friendly interfaces , the input alert should be used sparingly
because of its blocking nature.!Answer = !!Alert.Question( ‘OK to 
format entire disc?’ )Displays a question  alert  at
the current cursor position:This example comes up withthree buttons: ‘ YES’ , ‘NO’ and
‘CANCEL’  delivering the
corresponding text as thestring result.
!Answer = !!Alert.Input( ‘Type Item 
code: ’,'P10101' )Displays an input  alert  at the
current cursor position: 
The first string appears as the
prompt, and the second stringis the default entry in the textbox if the user does not supplya value.  Code Effect

--- Page 229 ---
 Software Customisation Guide
FMSYS Object and its Methods
12 Series  22:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.22 FMSYS Object and its Methods
The FMSYS object  (Forms and Menus System object) is a mechanism for providing
methods which are not specific to the standard objects, such as forms, gadgets, menus etc.
The FMSYS  methods perform a variety of system-oriented tasks.
22.1 Managing the Default Form Layout Mode
The FMSYS object provides the methods:
.SetDefaultFormLayout(layout is STRING).DefaultFormLayout( ) is STRING
which allow users to set and query the default layout mode.This can be used to help test any existing app ware which is using setu p form !!formname . .
. ,in either mode to determine which forms need layout adjustment.
For example:
!!FMSYS.SetDefaultFormLayout(‘VarChars’)
will cause any forms (without a VarChars or FixChars keyword) whic h are loaded and shown
to use the new variable character widths layout . If you kill and re-show a previously shown
(unqualified) form, it will have th e new layout, so it is easy to compare the difference.
In VarChars Mode
Forms which have avoided alignment by space-padding (e.g. by using TagWidth and Width)
should not be adversely affected. There may be some overall reduction in form width. 
Possible problems are:
• Padding of text with spaces to achieve alignment of a se t of gadgets will no longer work
(note, this was not recommended anyway).
Some uses of Align Right may fail with the message “ Attempt to place gadget off limits of
form ”, because the actual sizes of the aligne d gadgets will have chan ged relative to one-
another.
Minimal adjustment could be just adding t he FixChars keyword to restore the old
presentation, but a layout revamp would obviously be better.
22.2 Swapping Applications
You can swap to a new application using the SetMain  method:
!main = !!FMSYS.SetMain( !newmain )

--- Page 230 ---
12 Series  22:2 Software Customisation Guide
FMSYS Object and its Methods
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!!FMSYS.SetMain( !main )
22.3 Progress and Interrupt Methods
Form and Gadget callbacks may take a long time to execute, so it is often desirable to use
the Progress Indicator field on the Main Window's  status bar (along the bottom) to indicate
continuing progress to the user. Additionally for some callback operations it may be possible
and desirable to allow the user to interrupt the operation and choose  to cancel it. The
FMSYS methods Progress, setProgress, Interrupt and setInterrupt allow this to beachieved. 
Your callback which provides the desired operat ion, must be cyclical so that there is some
repeated access point where you can report progress (approximately as a percentage of thetotal task), and check to see if the user has clicked a stop button which you have provided
on some displayed form.
In your callback function you must first notify  the system of the iden tification of the stop
button using the FMSYS  method SetInterrupt :
!!FMSYS.setInterrupt(!!fmstop.stopButton )
Then at an appropriate point in the callback, check to see if
the stop button has been pressed using the FMSYS Interruptmethod, and exit with a message if it has:
-- Initialise progress bar!!FMSYS.setProgress(0)
do !next from 1 to 50
...!!RoutePipe( !next, . . . )    $*Route next pipe
...
-- Update the progress bar - first update the percentage
completion
!percent = ...!!FMSYS.setProgress( !percent )
-- Check if user pressed interrupt button
if ( !!FMSYS.Interruppt() ) thenreturn error 1 'Processing aborted'
endif
enddo
Following is the PML code for a simp le interrupt form  !!fmstop.pmlfrm:
$* F&M test harness: Stop form for interrupt management
setup form !!fmstop dialog NoAlign
title 'STOP (!!fmstop)'
path downpara   .stopText  text |Press to quit task|  width 20button .stopButton |Quit| width 25 height 2
exit

--- Page 231 ---
 Software Customisation Guide
FMSYS Object and its Methods
12 Series  22:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.define method .fmstop()
--Constructor
-- define callbacks!this.firstShownCall = |!this.stopButton.background =
'red'|
endmethod
22.4 Refreshing View Gadgets
You can refresh all View gadgets using the Refresh  method:
!!FMSYS.Refresh()
22.5 Checking References to Other Forms
By default, when a form is loa ded, all the references from it to other forms are checked to
make sure that the other forms exist. If you are experiencing performance problems, youcan switch the reference checking off using the CheckRefs  method:
!!FMSYS.CheckRefs( true )
Using this method can signifi cantly improve performance.
22.6 Splash Screen
There are occasions when the PDMS entry screen, known as a splashscreen, may be left
on the screen when PDMS fails to start up, for example, if it has not been correctly installed,
or there are network problems. 
To ensure that this screen is removed from the display, you can use the SplashScreen
method:
! !FMSYS.SplashScreen( false )
22.7 Default Form Positioning
By default, MDI forms  are placed at the maximum (right-hand side) of the main PDMS
window and dialog forms are placed at the mi nimum (left-hand side) of the PDMS window. 
To switch off default positioning, use the DocsAtMaxScreen  method:
!!FMSYS.DocsAtMaxScreen( false )
This method may be useful for wid e screen and twin screen devices
22.8 CurrentDocument() Method
This method returns the current Docum ent of the application framework as a FORM  object.
If there is no current document then the returned form has value Unset . 
It has the following declaration:
!!FMSYS.currentDocument( ) is FORM

--- Page 232 ---
12 Series  22:4 Software Customisation Guide
FMSYS Object and its Methods
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.This method should be useful when constructing callbacks for menus or gadgets which are
not on the current document form, i.e. where the context is not the current form or view
gadget, e.g. callbacks from the Main menu system or from pullright menus on Addin  forms. 
!myDocument = !!FMSYS.currentDocument()
22.9 LoadForm() Method
The method LoadForm  allows force loading of a form defin ition and/or the ability to get a
reference to a form object by name.
The method’s signature is:
!!Fmsys.loadForm( !formname is STRING ) is FORM
If the form exists then the method returns a refe rence to the form object. If it doesn’t exist,
then an attempt is  made to force load its definition.
If this fails then an unset form reference is  returned. You can chec k for this using the Unset
method on the form object.
22.10 Cursor Function Support
The F&M system prevents a cursor function from  being executed if there are no displayed
graphical views which support cursor functions, and raises the usual 'quit' error (61, 528):
'User exit from submode ' so that Appware can handle the effective 'quit', and then
raises error (61, 115): ' Invalid command when GRAPHICS OFF or no suitable
view available ', which will alert the user unless tra pped by the Appwar e. However, only
the Appware knows exactly which graphical vi ews can handle the specific cursor command,
so the OKCurfnView methods have been provided  to allow Appware to use this knowledge
intelligently.
Methods provide are:
Query whether graphical views of the specif ied view type are displayed. Graphical view
types supported are: 'G2D'; 'G3D'; 'A NY' and any view subtype is implied.
OKCurfnView( !viewtype is STRING ) is BOOLEAN
Query whether graphical views of the specif ied view type and subtype are displayed.
Graphical view types supported are: 'G2D'; 'G3D'; 'ANY'. View subtypes supported are:
'ANY' and for 
G2D: 'NORMAL' (Draft); 'PLOT'; 'ISOSPOOL'G3D: 'NORMAL' (Design)
OKCurfnView( !viewtype is STRING , subtype is STRING ) is BOOLEAN
Example using FMSYS OK CurfnView methods:
The following code snippet shows an example of use within a form method:
define method .runCurfn( !curfn is string )
-- run specified cursor function
if( !!fmsys.OKCurfnView('g2d', 'normal') ) then
-- valid view exists, so run cursor function$!curfn@
else

--- Page 233 ---
 Software Customisation Guide
FMSYS Object and its Methods
12 Series  22:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.-- no valid view
return error 1 |No suitable displayed 2D views forcursor function '$!curfn$@'|
endif
endmethod
Notes:
1. OKCurfnView('g2d') is equivalen t to OKCurfnView('g2d', 'ANY')
2. OKCurfnView('ANY ', 'NORMAL') will look for both 2D Draft and 3D Design views
22.11 Setting the Default Format Object for Text Fields
The SetDefaultFormat method is used to provide a default global format object to be used to
format typed text fields when no specific format is defined at design time. TheSetDefaultFormat method can only be called once to avoid inconsistency across appware.
Call the method as follows:
.SetDefaultFormat(!!fmt is FORMAT)
where !!fmt must be a global variable.
After calling the method the value can later be retrieved by  referencing the DefaultFormat()
method as follows:
!text=!myVar.String(!!fmsys.DefaultFormat())

--- Page 234 ---
12 Series  22:6 Software Customisation Guide
FMSYS Object and its Methods
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 235 ---
 Software Customisation Guide
PML Add-ins
12 Series  23:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.23 PML Add-ins
A PML add-in can:
• appear as an application on the main menu bar;
• define menus and toolbars;• add menu fields and toolbars to applications;• remove menu fields from applications;• cause functions to be run when starting  or switching between applications.
Each existing AVEVA application is implemented as a PML add-in.
It is important to distinguish between an add-i n that defines an application and one which
just modifies an existing application. An ap plication add-in must have an entry in the
Applications main menu so that it can be switched to.
This chapter describes mechanisms to allow a number of cooperating applications to be
added into a module. Each AppWare application is a PML Add-in. Users can add their ownapplications or add additional functionality to applications using PML Add-ins.
Warning : These mechanisms are still being devel oped and so may c hange at future
releases of PDMS. Even though we will make every effort to preserve the validity of added-
in functional code, we recommend you isolat e the definition of PML Add-ins from the
functional code of your applications to minimise the impact of any such changes.
It is important to distinguish between an add-in that defines an application and other add-
ins. An application appears on the Applicatio ns menu and can be switched to, whereas an
add-in simply provides a means of adding functionality to a module.
23.1 Application Switching
The application switching me chanism makes use of the following objects to control
applications, toolbars, forms, and menus.
Object Description
appCntrl Controls applications’ switching
appDefn Each application has an appDefn  object that stores
information about that application.
appTbarCntrl Controls visibility of tool bars and which toolbars are
active in each application

--- Page 236 ---
12 Series  23:2 Software Customisation Guide
PML Add-ins
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.A feature of Application Switching  is serialisation , which allows the working environment
to be saved and then restored to its previous state on entry to PDMS; that is, the currentapplication is stored and reloade d on entry. The visibility and position of toolbars and forms
is also preserved.
The new system of add-ins makes it unnece ssary to swap the main form when changing
between applications. Instead, the menu items and toolbars are all contained on one mainform; they are then shown only when the appropriate application is active.
23.1.1 Main Form
The main form is now stored as a PML Form. 
For DESIGN, this is !!appDesMain  and for DRAFT it is !!appDraMain . These contain the
basic gadgets and menu-options common to all applications in the module. All others arecreated using add-ins.
We recommend that you create add-ins to modify the main form rather than editing the
standard product code.
23.1.2 Callbacks
Each application can now have different types of callback, which are run at different times:
23.1.3 Defining an Add-in
Each add-in is specified by an add-in definition file, with pathname
%PDMSUI%\<module>\ADDINS\<addin> , where <module>  is the module name e.g.
DES, and <addin>  is the addin name e.g. MYADDIN . This is similar in format to the entries
in the old APPLICATIONS  file. Each line contains a key and description, separated by a
colon.
Some keys are available to all add-ins; others  can be used only for applications, since they
refer to menu text, gadgets and callb acks specific to that application.appMenuCntrl Controls which menus and menu fields are available in
each application
appFormCntrl Controls those forms which register themselvesObject Description
Callback When Executed
module startup calls Runs when PDMS first starts.
startup calls Runs the first time the application loads.
switch calls Runs every time PDMS swit ches into the application.

--- Page 237 ---
 Software Customisation Guide
PML Add-ins
12 Series  23:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Keys Available to all Add-ins
The following can be used by all add-ins.
The following keys are only used for applicatio ns, i.e. add-ins that have a menu option on
the Applications menu and can be switched to.Key Description
Name The unique identifier of the add-in, e.g. GEN, DES. This key
is compulsory.
Title Text description of the add- in (if the add-in defines an
application, the title appears in the title bar of the mainwindow when the application is loaded)
ShowOnMenu Determines whether the add-in has an entry on the
Applications menu, i.e. whether the add-in defines anapplication (false by default).
Object Add-in object: user-defined object type used to help define
the add-in, e.g. APPGENERAL
ModuleStartup Callback run when the PDMS module first starts
StartupModify Name of application to modify and the callback run when an
application is first started, separated by a colon.
e.g. EQUI:!!equiAppStartupCall().
SwitchModify Name of application to modify and the callback to run when
the application is switched to, separated by a colon.
e.g. PIPE:!!pipeAppSwitchCall()
Key Description
Menu Entry for application on the a pplications menu (the title is
used if this isn’t specified)
Directory Name of the application directory under
%PDMSUI%\module
Synonym Synonym created for the director y (only used if the directory
is specified)
Group Group number (applications with the same group number
are put into a submenu together)
GroupName Description of submenu to appear on main menu

--- Page 238 ---
12 Series  23:4 Software Customisation Guide
PML Add-ins
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.To make it easier for user-defined add-ins to modify existing applications, it is possible for an
add-in to add a startup or switch call to an application. You can do this by adding the lines ofthe following form to the add-in file.
startupModify: APPNAME: callback
switchModify: APPNAME: callback
where APPNAME  is the name of the application to m odify and callback is the callback to be
assigned to it. 
If an application with name APPNAME  is not defined, the callback is not run.
23.1.4 Add-in Object
A user-defined object type, the add-in object, is used to define toolbars and menus for an
add-in. An instance of this object is created and its methods are run at specific points.
The method .modifyForm()  of each add-in object is called during definition of the main
form so that add-ins may create their own toolbars on the main form; .modifyMenus()  is
called when starting PDMS to create menu options.
For applications, .initialiseForm()  is called when switching to the application.
It is not mandatory for all these methods to be present, and if one is not present, execution
continues as normal. It is possible to specify no object if you wish only to use the other
properties of the add-in.
23.1.5 Initialisation
The add-in definitions are loaded from file during PDMS startup using the function!!appReadAppDefns(!module is STRING) , where !module  is the 3-letter identifier for
the module. 
This creates the global !!appCntrl  object, which holds information about the add-ins.
After reading the definitions of all add-ins , !!appCntrl  assigns all callbacks to the
applications. 
For backward compatibility, if an add-in is an application, a directory is specified for the
application and the file module\directory\INIT  exists, then this file is added as aGadgets Integer specifying the gadgets that appear on main form for
this application:
1 - no gadgets2 - sheet/library gadgets3 - sheet/library and layer gadgets4 - sheet/library and note/vnote gadgets
Type Type of application for user applications. Valid values are
DRA, DIM, LAB, USR1, USR2, USR3, USR4, USR5.
SwitchCall Callback to be run every time t he application is switched to.
StartupCall Callback run when the application first starts.Key Description

--- Page 239 ---
 Software Customisation Guide
PML Add-ins
12 Series  23:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.startup-call. Similarly, if the file module\directory\ISYSTEM  exists, it is added as a
switch call.
23.2 Menus
Each add-in is able to specify menus that can be shown, along with the application in which
they can be shown. Menus are created by running the .modifyMenus()  method of the
add-in object when PDMS first starts.
23.2.1 APPMENU Object
The APPMENU  object provides a means of adding me nu fields to menus using the usual
PML 2 syntax while allowing the menu controllin g object to retain information about the
fields created. This information is used to show and hide menu fields depending on the
application.
23.2.2 Addition of Menu Items
To add menu fields to an application, proceed as follows:
Create an APPMENU  object:
!menu = object APPMENU('menuName')
This associates the object with the menu na med menuName on the main form, creating the
menu if it does not already exist. 
Add items to the menu using the methods of the APPMENU  object.
The arguments for these methods are exactly the same as the menu creation functions
provided by PML. A unique fieldname for each field in a menu can be specified.
You may specify a field name when adding menu  items in this way; if no field name is
specified, then the Dtext  of the menu field is used as the field name. To add to the end of the
menu, use the commands
!menu.add('<FieldType>', '<Dtext>', '<Rtext>', {'<FieldName>'})
!menu.add('SEPARATOR', {'<FieldName>'}).
Note: If a menu field with the same  field name is already present, the field will not be
added. This is so two add-ins can define  the same menu fiel d, and it will appear
independently of whether one or both add-ins are present.
This method does not always add an item to the end of the menu. If a function tries to
add a menu field with the same field name as one that’s already present, the nextmenu field created (unless it’s inserted explicit ly before or after another field or it’s a
separator) will appear af ter the existing field.  The reason for this is to preserve the
intended order of the fields.
To insert a new field relative to existing named field, use
!menu.insertBefore('<TargetFieldName>', '<FieldType>',
'<Dtext>', '<Rtext>' {, '<FieldName>'})
!menu.insertAfter('<TargetFieldName>', '<FieldType>',
'<Dtext>',  '<Rtext>' {, '<FieldName>'})

--- Page 240 ---
12 Series  23:6 Software Customisation Guide
PML Add-ins
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!menu.insertBefore('<TargetFieldName>', 'SEPARATOR' {,
'<FieldName>'})
!menu.insertAfter('<TargetFieldName>', 'SEPARATOR' {,
'<FieldName>'}).
To register the APPMENU  object with !!appMenuCntrl , specifying the applications in
which the menu field should be visible, use:
!appMenuCntrl.addMenu('APP', !menu)
It is possible to add menu fields from an APPMENU  object to every application. The
application name 'ALL'  has been reserved for this purpose.
23.2.3 Removing Menu Items
The APPMENU  object can also be used to remove menu fields from an application. The
method .remove(!fieldName is STRING)  hides the field with unique field name
!fieldName .
The following commands can be used to remove the field named removeField  from the
menu menuName  in the general application.
!menu = object APPMENU('menuName')
!menu.remove('removeField')
!!appMenuCntrl.addMenu(!menu)
23.2.4 Modifying the Bar Menu
The APPBARMENU  object provides similar functions for the bar menu of the main form. To
create additional menus on the bar menu, proceed as follows:
Create an APPBARMENU  object:
!bmenu = object APPBARMENU()
This automatically associates the object with the bar menu on the main form.
You can then change the contents of the bar menu using the following commands.
Command Description
!bmenu.add(!dtext is STRING, !menuName is ST
RING)Adds a menu to the end of the bar
menu, use the command. Thisadds the menu !menuName  to
the bar menu with label !dtext .
The menu is automatically
positioned before the Window andHelp menus if they are present.
!bmenu.insertBefore('<TargetMenuName>', '<Dt
ext>', '<MenuName>')
!bmenu.insertAfter('<TargetMenuName>', '<Dtex
t>', '<MenuName>')To insert menus relative to
existing menus, use

--- Page 241 ---
 Software Customisation Guide
PML Add-ins
12 Series  23:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.23.3 Toolbars
Toolbars are defined by creating a frame of  type toolbar on the main form, using the
following syntax.
frame .toolbarName toolbar 'Toolbar description'
[PML commands to define buttons, toggle gadgets, option
gadgets and text gadgets]
exit
It is not possible to add toolbars to a form once it has been created, so all toolbars must be
defined before any application is started. The method .modifyForm() of the add-in object
is run during building of the form so that each add-in can add its own toolbars.
23.3.1 Toolbar Control
Toolbar visibility in different applic ations is controlled by the object APPTBARCNTRL . A
global instance !!appTbarCntrl  is created when starting PDMS.
Each toolbar is registered with a list of  applications in which it can be active. !!appTbarCntrl
then controls the acti ve state and visibility of the tool bar as applications are switched.
Toolbars can be shown and hidden using the popup menu which appears when you rightclick on a toolbar or menu bar of the main form. If a toolbar is shown in one application, then
it will be shown in all other applic ations for which it is registered.
To register a toolbar, use the command
!!appTbarCntrl.addToolbar(!toolbarName is STRING,
!appName is STRING, !visible is BOOLEAN),
where !toolbarName  is the name of the toolbar frame , !appName  is the name of the
application to register the toolbar in and !visible  is whether the toolbar is visible by
default.
Instead of registering a toolbar in multiple a pplications individually, an array of applications
can be specified:
!!appTbarCntrl.addToolbar(!toolbarName is STRING,
!appNames is ARRAY, !visible is BOOLEAN)
registers the toolbar for all applications in the array !appNames .
The application name 'ALL'  has been reserved so that toolbars can be registered in every
application. To register a to olbar in all applications, use!bmenu.remove(!menuName is STRING To remove the menu menuName
from the bar, use
!!appMenuCntrl.addBarMenu('APP', !bmenu) Register the APPBARMENU
object with !!appMenuCntrl ,
specifying the applications inwhich the menu should be visible.Command Description

--- Page 242 ---
12 Series  23:8 Software Customisation Guide
PML Add-ins
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!!appTbarCntrl.addToolbar(!toolbarName is STRING, 'ALL',
!visible is BOOLEAN)
where !toolbarName  is the name of the toolbar and !visible  is whether it is visible by
default.
The command
!!appTbarCntrl.addToolbar(!toolbarName is STRING)
is a shorthand way of registering the toolbar to be visible in all applications, making it
visible by default.
Any toolbars on the main form that are not registered are automatically detected and hidden
by default. They are registered to be active in all applications.
23.3.2 Removing Gadget s from a Toolbar
It is possible to show a toolbar in an application but only show some of its gadgets. In this
case, the user must register which gadge ts are hidden in that application. 
To do this, use
!!appTbarCntrl.hideGadgets(!gadgets is STRING, !appName
is STRING),
where !gadgets  is a space-separated list of the gadgets to hide and !appName  is the
name of the application in which to hide them.
23.3.3 Deactivating Gadgets on a Toolbar
To grey out gadgets on a toolbar in a given application, use 
!!appTbarCntrl.deactivateGadgets(!gadgets is STRING,
!appName is STRING),
where !gadgets  is a space separated list of the gadgets to inactivate and !appName
is the name of the application in which to hide them.
23.4 Forms
The APPFORMCNTRL  object allows contro l of the behaviour of forms on application
switching and re-entering PDMS. A global instance !!appFormCntrl  is created when PDMS
starts.
If a form is to be controlled, it must register  itself with the object during the constructor
method.
23.4.1 Registering a Form
The most complete syntax for registering a form is
!!appFormCntrl.registerForm(!form is FORM, !visibleInApps
is ARRAY, !requiredApps is ARRAY, !showOnStartup isBOOLEAN, !showOnSwitch is BOOLEAN)
where !form  is the form to be registered, !visibleInApps  is an array containing the
applications the form should be visible in, !requiredApps  is the applications that must
have been loaded in order for the form to be displayed, !showOnStartup  is whether

--- Page 243 ---
 Software Customisation Guide
PML Add-ins
12 Series  23:9 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.the form is re-shown on  entry to PDMS if it was shown on exit and !showOnSwitch  is
whether the form is re-shown  when switching to an app lication if it was previously
shown in that application.
If !visibleInApps  is an empty array, then the form will be visible in all applications.
However, this can be simplifie d for most forms that do not need all this information stored
about them.
The command:
!!appFormCntrl.registerForm(!form is FORM)
registers the form so that it is re-shown on startup if it is shown when PDMS exits. It
does not depend on any other applications and its visibility is not otherwise controlled.
23.4.2 Hiding Forms when Exiting Applications
Previously, the main form was swapped when switching applications. Forms opened as
children of the main form were hidden when switching out of an application.
Since the main form is no longer swapped  when switching applications, this no longer
occurs so !!appFormCntrl  controls the hiding of forms. When switching between
applications, if a form is shown as a child of th e main form and is not registered to be shown
in the new application, then it is hidden. (Descendants of this form will therefore also be
hidden.)
Dockable forms are shown as free forms, so will be not be closed. However, the effect can
still be achieved by register ing the form in ju st one application with the argument
!showOnSwitch  set to false:
!visibleInApps[1] = 'APP'!!appFormCntrl.registerForm(!form, !visibleInApps, ARRAY(),
false, false)
The form will be hidden when s witching from the application 'APP'  and will not be shown
next time the application is started.
23.4.3 Storing Data Between Sessions
APPFORMCNTRL  also provides a means for forms to store data so that they can restore
their state next time the module is load ed. For each form that is registered,
APPFORMCNTRL  calls the .saveData  method of the form when leaving PDMS: the form
can return an array of strings of data to be st ored. When the form is next shown, it can
retrieve this data us ing the following method:
!data = !!appFormCntrl.getFormData(!form is FORM).
The contents of the array !data  will be the strings in the array returned by the .saveData
method when PDMS exited. If no data has bee n stored for that form, it will be an empty
array
You can also use the command:
data = !!appFormCntrl.getFormData(!formName is STRING) 
 if only the name of the form that stored the data is known.
Note: The form must be able to cope if no data is returned.  This will happen the first time
PDMS is run or if the form was not open t he previous time the user exited PDMS.

--- Page 244 ---
12 Series  23:10 Software Customisation Guide
PML Add-ins
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The following example shows a form that stores the state of some of its gadgets between
sessions.
setup form !!testForm
title 'Test of form data storage'
text .name 'Name' width 10 is STRINGtoggle .toggle 'Toggle'
exit
define method .testForm()
-- register form with form controlling object
!!appFormCntrl.registerForm(!this, ARRAY(), ARRAY(), true,
true)
-- retrieve data if available!data = !!appFormCntrl.getFormData(!this)
-- restore name and state of toggle if data present
if (!data.empty().not()) then
!this.name.val = !data[1]
!this.toggle.val = !data[2].boolean()
endif
endmethod
define method .saveData() is ARRAY
!return[1] = !this.name.val!return[2] = !this.toggle.val.string()
endmethod
23.5 Converting Existing User-defined Applications
Previously, applications for each module were defined by an entry in the
module\DFLTS\APPLICATIONS  file. A separate main form  for each application was built
using the module\GEN\FSYSTEM  file; application-specific gadgets and menus were added
by calling the module\application\DBA R file from the FSYSTEM  file.
In order that new applications can be added more easily and independently of each other,
application definitions are now stored in the directory module\DFLTS\APPDEFNS . There is
one file per application, which uses the same format as the old APPLICATIONS  file with the
extensions discussed previously.
23.5.1 Replacement of the DBAR File
Each add-in has a corresponding object, the type of which is specified in  the add-in file, that
adds toolbars and menu entries for that add-in. The functionality of the DBAR  file has been
replaced by the methods of the add-in object.
The method .modifyMenus()  of the application object is called to add items to the menus.
This replaces all sections of the DBAR  file where menu fields are added. Menu fields must
be added using an APPMENU  object - see Menus  - otherwise they will be visible in all

--- Page 245 ---
 Software Customisation Guide
PML Add-ins
12 Series  23:11 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.applications. The APPMENU  object must then be register ed with the application in which
the menu fields are to be visible,  otherwise they will never be shown.
The method .modifyForm() is called to make modifications to the main form, specifically
to add toolbars, during form definition. This replaces the label /DATA section of the DBAR
file. Exactly the same syntax can be used here, but if you wis h alter any gadgets after they
have been created you must refer to the main form explicitly rather than using the keyword
!this , which will refer to the object.
Toolbars can be registered - see Toolbar Control  - any unregistered toolbars will be hidden
by default and will not be controlled.
23.5.2 Menu Name Clashes
Menu names and menu field names must be checked against existing applications toensure there is no clash. To avoid clashes,  it is recommended that each user-defined
application prefixes the names of the menus it creates and the fields it creates on existing
menus with the name of the application.
23.5.3 Converting the DBAR File
In order to use an ex isting application, the DBAR  file must be converted from the existing
format. If the DBAR  file contains only PML 1 syntax for creating menu items, the object
CONVERTDBAR  can be used to create the corresponding add-in object.
To convert an existing DBAR  file, create a CONVERTDBAR  object with the following
parameters:
!convert = object CONVERTDBAR(!module is STRING,
!appNameStr is STRING, !outputDir is STRING, !addinFileDiris STRING)
where !module  is the name of the module in which the add-in is used, !appNameStr
is the name of the application (e.g. ‘ PIPE’ ), !outputDir  is the directory in which to put
the add-in object and !addinFileDir  is the directory in whic h to put the add-in file.
Then run the .convert()  method of the object to perform the conversion:
!convert.convert().
This creates the add-in object and corresponding add-in file. Information about the existing
application is stored in the %PDMSUI%\module\DFLTS\APPLICATIONS  file. This
information is read and used to create the add-in file. Therefore, the application being
converted must have an entry in the APPLICATIONS  file in the current PDMSUI  path.
23.6 Example Application
23.6.1 Adding a Menu Field
It is simple to use a PML add-in to add a field to a menu in PDMS. The following example
shows how to add an extra field to the Query  menu in the Design Pipework  application. 
Create an APPMENU  object corresponding to the menu.
!menu = object APPMENU('sysQry')
Add the required field to the menu

--- Page 246 ---
12 Series  23:12 Software Customisation Guide
PML Add-ins
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!menu.add('CALLBACK', 'Query Owner', 'q owner', 'QueryOwner')
Register the APPMENU  object with !!appMenuCntrl , so the menu is visible in the Pipework
application
!!appMenuCntrl.addMenu(!menu, 'PIPE')
The same method can be used to add fields to any menu descended from the bar menu ofthe main form.
A sample add-in object definitio n, which must be put in the PMLLIB  path, is shown below.
define object APPADDQUERYMENUFIELDendobject
define method .modifyMenus()
!this.queryMenu()
endmethod
define method .queryMenu()
-- define APPMENU object associated with the Query menu
!menu = object APPMENU('sysQry')
-- add field to query the owner of the current element
!menu.add('CALLBACK', 'Query Owner', 'q owner', 'QueryOwner')-- register the APPMENU object to be visible in the Pipework
-- application
!!appMenuCntrl.addMenu(!menu, 'PIPE')
endmethod
The corresponding add-in definition file, which is put in the DES\DFLTS\ADDINS  directory,
contains:
Name: ADDQUERYMENUFIELDObject: APPADDQUERYMENUFIELD
23.6.2 Creating a Custom Delete Callback
Users may want to replace the callback for the CE option on the Delete  menu in DESIGN
with a customised callback. This can be done using an add-in, without modifying the AVEVA
supplied files. To apply the changes in a ne w version of PDMS, the files can simply be
copied across.
Create an APPMENU  object corresponding to the Delete  menu.
!menu = object APPMENU('sysDel')
Hide the menu field CE on this menu
!menu.remove('CE')
Insert a new menu option to replace it
!menu.insertAfter('CE', 'CALLBACK', 'Delete',
'!!customDelete()', 'customDeleteCE')
Register the object with !!appMenuCntrl  so the menu item is replaced in all applications.

--- Page 247 ---
 Software Customisation Guide
PML Add-ins
12 Series  23:13 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.!!appMenuCntrl.addMenu(!menu, 'ALL')
The callback of the Delete  button on the main toolbar can also be modified.
!!appDesMain.mtbDeleteCe.callback = '!!customDelete()'
A sample add-in object definitio n, which must be put in the PMLLIB  path, is shown below.
define object APPCUSTOMDELETE
endobjectdefine method .modifyForm()
-- change callback on Delete toolbar button
!!appDesMain.mtbDeleteCe.callback = '!!customDelete()'
endmethod
define method .modifyMenus()
!this.deleteMenu()
endmethod
define method .deleteMenu()
!menu = object APPMENU('sysDel')-- replace CE option on menu with custom delete function
!menu.remove('CE')
!menu.insertAfter('CE', 'CALLBACK', 'CE', '!!customDelete()',
'customDelete')
-- we want the menu to be replaced in all applications, so
-- register this object in all applications
!!appMenuCntrl.addMenu(!menu, 'ALL')
endmethod
The corresponding add-in definition file, which is put in the DES\DFLTS\ADDINS  directory,
contains:
Name:CUSTOMDELETE
Object:APPCUSTOMDELETE

--- Page 248 ---
12 Series  23:14 Software Customisation Guide
PML Add-ins
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 249 ---
 Software Customisation Guide
Core Managed Objects
12 Series  A:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.A Core Managed Objects
This material is chiefly for A VEVA developers and not users, because it requires cooperation
between AppWare and core-software.
The mechanisms described below allow PML defined forms, menufields and gadgets which
are subsequently managed by core code. It should be noted that the use of core code
managed forms, menufields and gadgets requires well planned co-operation betweensoftware and AppWare.
It is permissible to have a mixture of PM L and CORE managed gadgets on a PML managed
form.
A CORE managed form may also have some PML managed gadgets and menufields, but
extreme caution should be adopted in this case. Making a form core managed involvesconsiderable effort in the supporting core code, as it bypasses most of the F&M form
management support.
A.1 Form Core Support
PML defined forms now have a new qualifier at tribute ‘control type’, with values PML or
CORE. A form is PML managed by default, but can be declared core managed by means ofthe ‘CORE’ keyword in the FSETUP  command. This is applicable to any form type except
MAIN  forms, for example:
SETUP FORM !!myform blockingdialog resi CORE
When a form is first displayed, if it is de clared as core managed, then F&M builds the
DRUID widget, and then notifies core code so that it can take over the form’s management.This is guaranteed to precede any core gadget or core menu notifications.
Core code may plug in its ow n callback functions to DRUID for certain form events which will
then no longer go to F&M.
Typically core code will ne ed to manage the following:
• Form UI_QUIT event.
•T h e  OK, CANCEL , and APPLY  buttons if present.
• Showing and hiding the form.
In general the PML form definition for a core managed form should not define the following
PML callbacks:
•I N I T C A L L
•A U T O C A L L• OKCALL• CANCECALL.

--- Page 250 ---
12 Series  A:2 Software Customisation Guide
Core Managed Objects
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.If OK, CANCEL  or APPLY  buttons are present they should also be declared as CORE
managed.
A.1.1 FORM Core Code Interface
F&M will call the following routin e, which must be provided by the core code, to notify core-
code of each form with CORE  control type:
CORFRM ( int FORM, int WMID, int FTYPE, int LSTR, string
FORMNAME )
where:
•FORM  is the F&M handle for the form element
•WMID  is the DRUID  driver handle for the form. This will allow the core-code to provide
its own callbacks for the form, and to organise the form’s core managed gadgets andmenus.
•FTYPE  is the form’s type ( DIALOG , BLOCKINGDIALOG , DOCUMENT ).
•FORMNAME  is a name-string unique to the app lication-module. It has a length of
LSTR.
The following F&M routines will be useful fo r core code manageme nt of PML forms with
core managed gadgets:
A.2 Gadget Core Support
PML defined forms may now have a mixture of PML managed and core code managedgadgets.
A new gadget qualifier attribute ‘control type’, with values PML or CORE has been
introduced. 
The following gadgets can be declared to be CORE controlled or PML controlled during their
definition: 
•B U T T O N
•TEXTIN  
• TOGGLE•PARAGRAPH  (doesn’t have a callback)
•TEXTPANE  (doesn’t have a callback)Command Effect
FLDFRM ( int LNAM, string FNAME, 
int FORM )Load named form from a definition
file. FORM  is a handle to the
created form object.
FDSCOR ( int FORM, int IERR) Display the given form. IERR  is a
PML error token. It takes the value0 when there was no error.
FHDCOR ( int FORM, boolean CANCEL 
)Hide the given form. If
CANCEL=true  it means the form
was cancelled. Ot herwise it was
OK’ed

--- Page 251 ---
 Software Customisation Guide
Core Managed Objects
12 Series  A:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.•FRAME  
•LIST   (single, multi and option)
•SELECTOR  (single, multi)
Alpha and Graphical view gadgets are not candidates for this mechanism.
These gadgets’ definition graphs now support the ‘CORE’ qualifier:
When a form is first displayed its gadgets ar e created. If a gadget is declared as core
managed then F&M, builds the DRUID widget, sets its active, visible and selected states,and then calls core code to allow it to take over the gadget callback. 
Core code may plug in its own callback functi on to DRUID so that events on that gadget will
go directly to core code and will no longer go to F&M. Core code will t hen be responsible for
managing the gadgets state in conjunct ion with PML AppWare. For gadgets with no
callback, the core code may merely wish to read values from or write to the gadget. Youmust exercise great care to avoid clashe s between AppWare and software management.
TEXTPANE  and PARAGRAPH  gadgets do not have a callback. 
A.2.1 GADGET Core Code Interface
F&M will call the following routin e, which must be provided by the core code, to notify core-
code of each gadget with CORE control type:
CORGDT ( int GADGET, int WMID, int GTYPE, int LSTR, string
GDTNAME )
where:
• GADGET is the F&M handle for the gadget element
• WMID the DRUID driver handle for the gadget . This will allow the core-code to provide
its own callback for the gadget.
• GTYPE is the gadget type as defined above.• GDTNAME an application module unique gadget name string of length LSTR
The element GADGET is owned by  an F&M FORM element, so its owner (in this case the
form) element can be obtained from:
FQUOWN( int GDTELT, int FORM, int OWNER ).
The following F&M routines may be useful for core code management gadgets:
Query immediate owner and owning form of given element ELT (gadget, menu, menufield
etc.):
FQUOWN ( int ELT, int FORM, int OWNER ).-------<---.
/|
<gadget>--+-- tagtext --| gadget tag
||+-- <fgpos> --| gadget position
||+-- CORE -----| Core managed gadget
||..
.

--- Page 252 ---
12 Series  A:4 Software Customisation Guide
Core Managed Objects
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.where:
•FORM  and OWNER  are returned arguments.
• FORM/GADGET/MENU/ME NUFIELD/ELT/OWNER is the F&M handle for an element.
•IERR  is a PML error token, where 0 means no error.
A.3 Menufield Core Support
A menufield is PML managed by default, but can be declared to be CORE controlled during
its definition.
Menufield creation syntax now has the ‘CORE’ qualifier.Add/Insert methods now allow any menufield ty pe to be pre-pended with ‘CORE’ to indicate
a core managed field. 
!menu.Add( ‘CORECALLBACK’, ‘<Dtext>’, ‘ ’, ‘<FieldName>’ )
!menu.Add( ‘CORESEPARATOR’, ‘<Dtext>’, ‘ ’ , ‘<FieldName>’  )!menu.Add( ‘COREMENU’, ‘<Dtext>’, ‘ ’ , ‘<FieldName>’  )
The F&M menu fields are mapped to DRUID MenuItem widgets at the first UI_FILL_MENU
or UI_UPDATE_MENU  event. At this point F&M, builds the DRUID menufield widget, sets its
active, visible and selected states, and then calls core code to allow it to take over the field. 
Core code will plug in its own callback function into DRUID so that ev ents on that field will go
directly to core code and will no longer go to F&M. Core code will now be responsible for
managing the menu field’s state in conjunction with PML AppWare.
A.3.1 MENUFIELD co re code interface
F&M will call the following routin e, which must be provided by the core code, to notify core-
code of each field with CORE control type:
CORMNU ( int FLDELT, int WMID, int FTYPE, int LSTR, string
FLDNAME )
where:
•FLDELT  is the F&M handle for the field
•WMID  is the DRUID driver handle for the field. This will allo w the core-cod e to provide
its own callback for the menu item.
•FTYPE  is the field type (0-4). These values correspond to the following types:
CALLBACK , TOGGLE , SEPARATOR , MENU , FORM .
•FLDNAME  is the core-code/AppWare agreed menu field name string of length LSTR
F&M will provide the following inte rface for core-code to manag e the menufiel d state: Menu
field active, visible, checked.
FSTMFA( int FLDELT, logical ACTIVE, logical UPDATE=.TRUE. )FSTMFV( int FLDELT, logical VISIBLE, logical UPDATE=.TRUE. )
FSTMFT( int FLDELT, logical CHECK, logical UPDATE=.TRUE. )
The last example will be i gnored by non-toggle fields
Note that the FLDELT  element is owned by an F&M MENU  element, so it’s owning menu
and form elements can be obtained from:
FQUOWN( int FLDELT, int FORM, int OWNER )

--- Page 253 ---
 Software Customisation Guide
Core Managed Objects
12 Series  A:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.A.3.2 PML Defined Menufields Manage d by Application Framework Addins
It is a requirement that all forms can be shown from the main menu bar of the application
framework. For non F&M forms, i.e. the new C# defined forms the following procedure isnecessary.
Define PML menu in normal way, but agree menufield names between AppWare and
software (Addin). Do not assign a PML callback or declare the field as CORE. 
When the menufield is created, DRUID raises  a ‘menu field created‘ event which must be
subscribed to by the appropriate Addin so ftware. This event will supply the field name.
When the Addin receives the event with its ag reed field name, it must add its own callback
to the menu item. This callback will typically display the appropriate Addin specific form.

--- Page 254 ---
12 Series  A:6 Software Customisation Guide
Core Managed Objects
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.

--- Page 255 ---
 Software Customisation Guide
Manipulating VIEWS
12 Series  B:1 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.B Manipulating VIEWS
This Appendix tells you how to interact with the 2D and 3D View gadgets.
B.1 Manipulating 2D Views
This section describes the standard mechan isms provided by the Forms and Menus
software for manipulating a 2D view using the mouse buttons, number keypad and function
keys.
The mouse buttons are referred to as:
•MB2  (adjust)
•MB3  (popup)
If you press MB3  when the cursor is over the vi ew canvas, the popup view menu is
displayed. This will either be the default me nu supplied by th e Forms and Menus
software, or an application-spec ific version if provided, either by AVEVA or by your own
customisation.
This section describes the default menu.
Zooming  is done using:
•T h e  MB2  (adjust) mouse button.
• The numeric keypad.•PageUp , PageDown  and Home  keys
Panning is done using:
• The view scrollbars.
• The numeric keypad.
Note the Reset Limits  option on the View  popup-menu, which will re turn to the initial
view limits.
Zooming Using the Mouse Button MB2
To zoom in and out:
• Move the cursor to a corner of an imaginary box enclosing the area of interest. Hold
down MB2 , move the mouse to the diagonally opposite corner and release the button.
• Click MB2  to zoom out from the cursor position by factor of 1.5.
• Hold down Shift  and click MB2  to zoom in on the cursor position by factor of 1.5.
• Hold down Ctrl as well to double the zoom factor.

--- Page 256 ---
12 Series  B:2 Software Customisation Guide
Manipulating VIEWS
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Zooming Using Page Up, Page Down and Home Keys
These keys will be particularly useful on, for ex ample, laptop keyboards,  which frequently do
not have a numeric keypad:
Panning Using the View Scrollbars
The view scroll bars enable you to pan across the view:
• The slider bubble pans continuous ly according to speed of movement.
• The arrowheads move the bubble by approximately 1/100 of the bar per click.• Click in the slider trough to  move the bubble by approximat ely 1/10 of the bar per click.
• Hold down Ctrl and click in the slider trough to pan to the opposite side in one step.
Manipulating 2D Views Us ing the Numeric Keypad
Panning Using Alt and the Arrow Keys
Each click pans the view by 1 step distance, where a step is half the size of the current
displayed window.
• Holding down Ctrl does 10 steps.Key Effect
4, 6, 8, 2 Rotate LEFT , RIGHT , UP, DOWN , in 10 degree steps.
Ctrl gives 45 degree steps.
Shift  gives 1 degree steps.
Ctrl with Shift  gives 4.5 degree steps.
Page Up Zoom in on view centre (zoom by 1.5).
Ctrl speeds up to zoom by 2.5.
Shift  slows down to zoom by 1.2.
Page Down Zoom out on view centre (zoom by 1.5).
Ctrl speeds up to zoom by 2.5.
Shift  slows down to zoom by 1.2
Home Zoom fully out to view limits.
78 9
Zoom in x 1.5 on view centre Pan down by half view
widthZoom in x 2.5 on view
centre
45 6
Pan left by half view width Zoom out to view limits Pan right by half view
width
12 3Zoom out x 1.5 on view centre Pan up by half view
widthZoom out x 2.5 on view
centre

--- Page 257 ---
 Software Customisation Guide
Manipulating VIEWS
12 Series  B:3 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.• Holding down Shift  does 0.1 step.
D View, Save and Restore View Methods
2D views now have 4 view stores that allow storage and retrieval of the current view state.
They can be accessed by the saveview()  and restoreview()  methods:
!myview.SaveView(  !storeNumber )
!myview.RestoreView( !storeNumber )
where !StoreNumber  must be in the range 1 to 4.
If the view’s picture is deleted or changed th en the view-stores are all cleared. The stored
view settings should survive saving and restoring to a binary-save file.
B.2 Manipulating 3D Views
This section describes the standard mechan isms provided by the Forms and Menus
software for manipulating a 3D view using the mouse buttons, number keypad and function
keys.
The mouse buttons are referred to as:
•MB2  (adjust)
•MB3  (popup)
If you press MB3  when the cursor is over the view canvas, the popup view menu  is
displayed. This will either be the default me nu supplied by th e Forms and Menus
software, or an application-spec ific version if provided, either by AVEVA or by your own
customisation.
This Section describes the default menu.
View controls using the mouse are analogue. Th ey work best when the redraw time is not
too large, so that you get rapid feedback. With long redraw times (large models), you mayfind that the keyboard digital controls are easier to use. 
Status Line
The view parameters are displayed in the status line , just below the view. For example:
n25w12d Pers<36  Model  Rotate Fast
Where the fields have the following meanings:
Field Meaning
n25w12d The current direction, with angles in degrees
Pers<36 The current perspective field of view, in degrees, or else
parallel.
Model This is either Eye or Model . 
It controls whether rotations keep the from-point fixed (eye
point), or the through-point fixed (centre of interest).

--- Page 258 ---
12 Series  B:4 Software Customisation Guide
Manipulating VIEWS
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Popup Menu
Pressing MB3 displays the popup view menu when the cursor is over the view canvas.
This will either be the de fault menu supplied by the Forms and Menus  software, or an
application-specific version if  provided, either by AVEVA or by your own customisation.
This Section describes the default menu.
The Zoom , Pan, Rotate  and Walk  options select a mouse mode. Rotate This is the current mouse mode for view adjustments
(Adjust  or MB2 ). This mode may be Zoom , Pan, Rotate  or
Walk .
Fast This is the current value of the gearing modifiers for view
adjustment. 
Pressing Ctrl  displays Fast
Pressing Shift  displays Slow
Pressing both  displays Medm .
Otherwise the field is blank. These modifiers apply to both mouse adjustments and
keypad actions. In general, Fast  is about 10 times faster,
and Slow  is about 10 times slower. However, for rotations
and zooms different values are used.
This field displays Rest  when the Alt key is pressed, and
Save  when Alt and Ctrl are pressed together.  This relates
to saving and restoring view  settings, described below.
Menu option Function Key
Zoom F2Pan F3
Rotate F5
Walk F6Options > Eye
ShadeBordersPerspF7
F8F9F4  (F10)
Restore > R n Alt n (n is 1, 2, 3  or 4 on
keypad)
Save > S n Alt Ctrl n (n is 1, 2, 3  or 4 on
keypad)Field Meaning

--- Page 259 ---
 Software Customisation Guide
Manipulating VIEWS
12 Series  B:5 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.The Options  pullright toggles the states of Eye/Model , Shaded /Wireline , Borders  On/Off,
and Perspective /Parallel . 
These actions may also be achieved by pres sing the relevant Function Button while the
view canvas has keyboard focus.
The Restore  and Save  pullrights allow up to four view settings to be saved and restored. To
save the current view  settings, choose S1, S2, S3 or S4 from the Save  menu.  To restore a
previously saved setting, choose R1, R2, R3, or R4 from the Restore  menu. These
functions are also available using Alt, Ctrl, and the keypad numerals 1 to 4 while the canvas
has keyboard focus.
Mouse Modes
Mode Navigation
Zoom  (F2). Press Adjust  down over the view canvas, and then,
keeping the button down, move the mouse upwardsto zoom in, and down wards to zoom out.
This changes the perspective angle, or the view
scale in parallel views. It does not change the eyepoint or the view direction. Use Ctrl or Shift  to speed
up or slow down.
Pan (F3). Press Adjust  over the canvas, and then, keeping the
button down, move in any direction to shift the line ofsight in that direction. The current view direction isnot changed. 
Note that the picture moves the opposite way to the
mouse movement; it is the observer that is being
moved.
It may be useful to think of moving the mouse
towards the part of the picture you wish to see. UseCtrl or Shift  to speed up or slow down.
Rotate  (F5). Press Adjust
 and keep it down, then move left/right
to change the bearing of the view direction, or up/down to change the elevation.
The initial movement of the mouse determines which
is changed, and only that component of the view
direction is modified.
To modify the other component, the mouse button
must be released and then pressed down again,while moving in the other direction. 
Walk  (F6). Press Adjust  button and keep it down, then move up
to walk forwards, or down to walk backwards, alongthe line of sight. Use Ctrl or Shift  to speed up or
slow down.
Eye (F7). View rotations keep the from- point fixed, and in
Model mode rotations keep the through-point fixed.Use Ctrl or Shift  to speed up or slow down.

--- Page 260 ---
12 Series  B:6 Software Customisation Guide
Manipulating VIEWS
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.In all modes, clicking MB2  will shift the point under the cursor  to the centre of the view. In
perspective, the from- point will be maintained, and the view  direction and through-point will
be modified.  In parallel, the view directio n will be maintained, a nd the from- and through-
points moved. The only except ion to this rule is in Pan Mode , when the view direction is
never modified.
Manipulating 3D Views Us ing the Numeric Keypad
Important: Some keyboards have auto-repeat on keypads and function-buttons.
When the keyboard focus is in the vi ew, the following functions are available.
Saving views: Use Alt and Ctrl and keypad numerals 1, 2, 3, or 4.
Restoring views: Use Alt and keypad numerals 1, 2, 3, or 4.Function Keys78 9
Zoom in x 1.5 on view centre Rotate in 10-degree
stepsZoom in x 2.5 on view centre
45 6
Rotate in 10-degree steps Zoom out to view limits Rotate in 10-degree steps
12 3
Zoom out x 1.5 on view centre Rotate in 10-degree
stepsZoom out x 2.5 on view
centre
Key Effect
4, 6, 8, 2 Rotate Left, Right, Up, Down , in 10 degree steps. 
Ctrl gives 45 degree steps, 
Shift  gives 1 degree steps
Ctrl with Shift  gives 4.5 degree steps.
7, 1 Zoom in/out, changing the view radius by a factor of 1.5. Ctrl
does two steps at once 
Shift  does 1/4 of a step.
Using them both does 1/2 a step
9, 3 Walk in or out, by 1  step-distance (user selectable). 
Ctrl does 10 steps
Shift  does 1/10 of a step.
Key Effect
F2 Select Zoom  mouse mode
F3 Select Pan mouse mode

--- Page 261 ---
 Software Customisation Guide
Manipulating VIEWS
12 Series  B:7 © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Arrow Keys (Up, Down, Left, Right)
The arrow keys change the line of sight as in Pan mode, by 1 STEP distance.Ctrl Arrow does 10 STEPs Shift Arrow does 1/10 of a STEP.The following changes have been made to allow consistency with ReviewLE and to improve
usability on 'lap top' keyboards which fr equently do not have the Numeric Keypad.F4 Toggle between Perspective  and Parallel
F5 Select Rotate  mouse mode
F6 Select Walk  mouse mode
F7 Toggle rotations mode between Eye and Model
F8 Toggle between Shaded  and Wireline
F9 Toggle between Borders  Off and Borders  On (sliders)
F10 (if available) Toggle between ENU & XYZ display modes
Key and Mode Effect
PageUp  and PageDown Keys Walk  in or out.
Perspective Walk  in or out by 1 step-distance.
Ctrl Walk  in or out by 10 step-distances.
Shift Walk  in or out by 1/10 step-distance.
Parallel Zoom  in or out, changing view radius by a
factor of 1.5.
Ctrl Zoom  in or out two step-distances at once
Shift Zoom  in or out 1/4 of a step-distance.
Ctrl + Shift Zoom  in or out 1/2 a step-distance.
Alt Zoom  in or out regardless of projection type.
For a perspective view this allows the user
to choose the perspective view angle for useduring the walk through sequence.
Arrow Keys Rotate  Left, Right , Up, and Down  in 10-
degree steps. 
Ctrl Rotate  in 45 degree steps.
Shift Rotate  in 1 degree steps.
Ctrl + Shift Rotate  in 4.5 degree steps.
Alt Pan Left, Right , Up, 
Down . Moves line of
sight as in Pan mode , by 1 step-distance.

--- Page 262 ---
12 Series  B:8 Software Customisation Guide
Manipulating VIEWS
© Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Notes:
• There is no syntax to set the mouse mode, or to enquire it. 
•T h e  eye mode  can be selected by setting Walkmode  On, and Model  by setting
Walkmode  Off.
• If your keyboard focus is set by moving the cursor into a window without having to click
a mouse button,  it is possible to get the state of the Ctrl and Shift  keys confused.  If
you move the mouse into the view, press Ctrl, press Adjust , move the mouse out of
the view, release Adjust , then release Ctrl, you will still be in Fast mode , as shown in
the status line. To remedy this, move the cu rsor back into the view, and then press and
release Ctrl.Alt + Ctrl Rotate  by 10-step-distances.
Alt + Shift Rotate  by 1/10 of a step-distance.
Numeric Keypad Keys 
4, 6, 8, 2  Rotate  Left, Right , Up, Down , in 10 degree
steps.
Ctrl Rotate  in 45 degree steps.
Shift Rotate  in 1 degree steps.
Ctrl&Shift Rotate  in 4.5 degree steps.
Alt Pan Left, Right , Up, Down .
Moves line of sight as in Pan mode, by 1
step-distance.
Alt + Ctrl Rotate  by 10-step-distances.
Alt + Shift Rotate  by 1/10 of a step-distance.
Numeric Keypad Keys 
7, 1 Zoom  in or out, changing view radius by a
factor of 1.5.
Ctrl Zoom  in or out by two step-distances at a
time.
Shift Zoom  in or out by 1/4 step-distance at a
time.
Ctrl + Shift Zoom  in or out by 1/2 step-distance at a
time.
Numeric Keypad Keys 
9, 3 Walk  in or out.
Perspective Walk  in or out, by 1 step-distance.
Ctrl Walk  in or out, by 10 step-distances.
Shift Walk  in or out, by 1/10 step-distance.
Parallel For parallel  projection  reverts to Zoom  in or
out.

--- Page 263 ---
Index
12 Series © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Index page i Software Customisation Guide
Symbols
!This notation   . . . . . . . . . . . 2:11 , 13:2, 13:3
$M command   . . . . . . . . . . . . . . . . . . . . . 7:1
Numerics
2D views - see Views   . . . . . . . . . . . . . 20:53
3D views - see Views   . . . . . . . . . . . . . 20:53
A
Abbreviations
don’t use!   . . . . . . . . . . . . . . . . . . . . . 3:2
Aborting forms  . . . . . . . . . . . . . . . . . . . . 15:6
Absolute positioning   . . . . . . . . . . . . . . 17:10
ALERT object   . . . . . . . . . . . . . . . . . . . . 21:1
Alert objects:position  . . . . . . . . . . . . . . . 21:2
Alignment of gadgets   . . . . . . . . . 17:2 , 17:6
Alpha log  . . . . . . . . . . . . . . . . . . . . . . . . 12:4
ALPHA views
see Views  . . . . . . . . . . . . . . . . . . . 20:50
Applications  . . . . . . . . . . . . . . . . . 22:1 , 22:3
Apply button   . . . . . . . . . . . . . . . . . . . . 20:26
Area view gadget   . . . . . . . . . . . . . . . . 20:56
Arguments  . . . . . . . . . . . . . . . . . . . . . . . . 2:6
type . . . . . . . . . . . . . . . . . . . . . . . . . . 2:8
Array methods  . . . . . . . . . . . . . . . . . . . . . 6:2
Array variables   . . . . . . . . . . . . . . . . . . . . 2:2
evaluating ( only)   . . . . . . . . . . . . . . . 8:4
Arrays   . . . . . . . . . . . . . . . . . . . . . . . . . . . 6:1
appending to  . . . . . . . . . . . . . . . . . . . 6:3
creating  . . . . . . . . . . . . . . . . . . . . . . . 6:1
creating using VAR  . . . . . . . . . . . . . . 8:1
deleting  . . . . . . . . . . . . . . . . . . . . . . . 6:3deleting elements  . . . . . . . . . . . . . . . 6:3
delimiters  . . . . . . . . . . . . . . . . . . . . . 6:4
elements   . . . . . . . . . . . . . . . . . . . . . 6:1
gaps in  . . . . . . . . . . . . . . . . . . . . . . . 6:1
heterogeneous  . . . . . . . . . . . . . . . . . 6:1
length of string elements   . . . . . . . . . 6:4
multidimensional   . . . . . . . . . . . . . . . 6:2
reading  . . . . . . . . . . . . . . . . . . . . . . 11:2
referring to  . . . . . . . . . . . . . . . . . . . . 6:1
sorting   . . . . . . . . . . . . . . . . . . . .6:4 , 6:6
sparse   . . . . . . . . . . . . . . . . . . . . . . . 6:1
splitting text into  . . . . . . . . . . . . . . . . 6:3
subscripts  . . . . . . . . . . . . . . . . . . . . . 6:1
subtotalling  . . . . . . . . . . . . . . . . . . . . 6:9
writing   . . . . . . . . . . . . . . . . . . . . . . 11:2
ARRAYWIDTH function  . . . . . . . . . . . . . 6:4
Assignment   . . . . . . . . . . . . . . . . . . .4:3 , 9:1
AT command   . . . . . . . . . . . . . . .17:3 , 17:10
Attributes   . . . . . . . . . . . . . . . . . . . . . . . . 2:1
AUTOLIMITS command
Volume view   . . . . . . . . . . . . . . . . 20:60
Auto-placement of gadgets   . . . . . . . . . 17:6
B
Background colour  . . . . . . . . . . . . . . . 20:54
Bar menus   . . . . . . . . . . . . . . . . . . . . . . 16:2
Boolean expressions   . . . . . . . . . . . .5:1 , 5:2
Boolean IF constructs   . . . . . . . . . . . . . . 5:2
Boolean operators   . . . . . . . . . . . . . . . . . 4:2
Boolean variables  . . . . . . . . . . . . . . . . . . 2:2
Built-in variable types  . . . . . . . . . . . . . . . 2:2
Button gadgets  . . . . . . . . . . . . . . . . . . 20:25

--- Page 264 ---
 Software Customisation Guide
12 Series © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Index page iiC
Callbacks   . . . . . . . . . . . . . . . . . . 13:1 , 13:3
cancelcall   . . . . . . . . . . . . . . . . . . . . 15:6
form methods  . . . . . . . . . . . . . . . . . 14:1
functions  . . . . . . . . . . . . . . . . . . . . . 14:1
initialisation  . . . . . . . . . . . . . . . . . . . 15:6
okcall   . . . . . . . . . . . . . . . . . . . . . . . 15:6
open . . . . . . . . . . . . . . . . . . . . . . . . 14:3
PML expressions   . . . . . . . . . . . . . . 14:1
PML Functions  . . . . . . . . . . . . . . . . 13:3
Cancel button   . . . . . . . . . . . . . . 15:7 , 20:26
Case independence   . . . . . . . . . . . . . . . . 3:2
Case, in variable names  . . . . . . . . . . . . 13:2
CHANNEL command
Alpha view   . . . . . . . . . . . . . . . . . . 20:51
character
$ . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3:2
Child forms   . . . . . . . . . . . . . . . . . . . . . 15:10
Class  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2:1
CLEAR command
Plot view  . . . . . . . . . . . . . . . . . . . . 20:56
Colours
in views  . . . . . . . . . . . . . . . . . . . . . 20:54
Columns of text  . . . . . . . . . . . . . . . . . . . . 8:1
Comments  . . . . . . . . . . . . . . . . . . . . . . . . 3:1
Comparator operators  . . . . . . . . . . . . . . . 4:2
Compatibility  . . . . . . . . . . . . . . . . . . . . . . 1:3
COMPOSE command  . . . . . . . . . . . . . . . 8:1
Concatenation operator   . . . . . . . . . . . . . 4:3
Conditional construct   . . . . . . . . . . . . . . . 5:1
Constructor method   . . . . . . . . . . 2:11 , 2:12
Copies  . . . . . . . . . . . . . . . . . . . . . . . . . . . 9:1
Cursor types
in View gadgets   . . . . . . . . . . . . . . 20:54
D
Database attributes  . . . . . . . . . . . . . . . . . 9:3
Database Selector gadget   . . . . . . . . . 20:39
DB references  . . . . . . . . . . . . . . . . . . . . . 9:1
De-activating menu options   . . . . . . . . . 16:9
Deep Copy   . . . . . . . . . . . . . . . . . . . . . . . 9:1
Default constructor method  . . . . . . . . . . 2:11
Delimiters
arrays  . . . . . . . . . . . . . . . . . . . . . . . . 6:4
Delimiters, for text  . . . . . . . . . . . . . . . . . . 3:3
Diagnostics  . . . . . . . . . . . . . . . . . . . . . . 12:4
Directives   . . . . . . . . . . . . . . . . . . . . . . . 13:5
Dismiss button   . . . . . . . . . . . . . . . . . . 20:27
Displaying forms  . . . . . . . . . . . . . . . . . . 13:4
DO loops  . . . . . . . . . . . . . . . . . . . . . 4:3 , 5:4
breaking out of   . . . . . . . . . . . . . . . . . 5:5
nested  . . . . . . . . . . . . . . . . . . . . . . . . 5:6skipping commands  . . . . . . . . . . . . . 5:6
E
ELEVATION command   . . . . . . . . . . . 20:59
ELSE command  . . . . . . . . . . . . . . . . . . . 5:1
ELSEIF command   . . . . . . . . . . . . . . . . . 5:1
ENDIF command (PML)  . . . . . . . . . . . . . 5:1
Entry screen
removal from display   . . . . . . . . . . . 22:3
Error handling  . . . . . . . . . . . . . . . .10:1 , 12:1
Escape character  . . . . . . . . . . . . . . . . . . 3:2
Escape sequences  . . . . . . . . . . . . . . . . . 3:2
EVALUATE command   . . . . . . . . . . . . . . 8:4
Evaluating array variables   . . . . . . . . . . . 8:4
Events   . . . . . . . . . . . . . . . . . . . . . . . . . 14:3
Expressions   . . . . . . . . . . . . . . . . . . . . . . 4:1
boolean   . . . . . . . . . . . . . . . . . . .4:1 , 5:2
format  . . . . . . . . . . . . . . . . . . . . . . . . 4:1
if, do and =  . . . . . . . . . . . . . . . . . . . . 4:3
nesting  . . . . . . . . . . . . . . . . . . . . . . . 4:3
string   . . . . . . . . . . . . . . . . . . . . . . . . 4:1
text . . . . . . . . . . . . . . . . . . . . . . . . . . 4:1
type  . . . . . . . . . . . . . . . . . . . . . . . . . 4:1
Eye/Model toggle  . . . . . . . . . . . . . . . . . . B:4
F
File handling  . . . . . . . . . . . . . . . . . . . . . 11:1
File object  . . . . . . . . . . . . . . . . . . . . . . . 11:1
filename extensions  . . . . . . . . . . . . . . . . 3:3
Files
reading  . . . . . . . . . . . . . . . . . . . . . . 11:2
writing   . . . . . . . . . . . . . . . . . . . . . . 11:2
FMSYS object   . . . . . . . . . . . . . . . . . . . 22:1
Form attributes  . . . . . . . . . . . . . . . . . . . 15:3
Form control attributes  . . . . . . . . . . . . 20:26
Form definition file   . . . . . . . . . . . . . . . . 13:4
Form Family  . . . . . . . . . . . . . . . . . . . . 15:10
Form icon title  . . . . . . . . . . . . . . . . . . . . 15:5
Form initialisation
of forms   . . . . . . . . . . . . . . . . . . . . . 15:6
Form methods   . . . . . . . . . . . . . . .13:1 , 13:3
Form position  . . . . . . . . . . . . . . . . . . . 15:11
Form References  . . . . . . . . . . . . . . . . . . 9:1
Form Title  . . . . . . . . . . . . . . . . . . . . . . . 15:5
Form variables  . . . . . . . . . . . . . . . . . . . 15:9
FORMAT object  . . . . . . . . . . . . . . . . . 20:43
Forms
aborting   . . . . . . . . . . . . . . . . . . . . . 15:6
attributes   . . . . . . . . . . . . . . . . . . . . 15:3
defining   . . . . . . . . . . . . . . . . . . . . . 15:3
displaying  . . . . . . . . . . . . . . . . . . . . 13:4
free . . . . . . . . . . . . . . . . . . . . . . . . 15:10

--- Page 265 ---
 Software Customisation Guide
12 Series © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Index page iiihiding   . . . . . . . . . . . . . . . . . 13:4 , 15:12
introduction to  . . . . . . . . . . . . . . . . . 13:2
killing   . . . . . . . . . . . . . . . . . 13:4 , 15:12
loading   . . . . . . . . . . . . . . . . 13:4 , 15:10
members   . . . . . . . . . . . . . . . . . . . . 13:2
naming   . . . . . . . . . . . . . . . . . . . . . . 13:2
position  . . . . . . . . . . . . . . . . . . . . . 15:11
positioning   . . . . . . . . . . . . . . . . . . . 22:3
resizable  . . . . . . . . . . . . . . . . . . . . . 15:4
showing   . . . . . . . . . . . . . . . 13:4 , 15:11
size . . . . . . . . . . . . . . . . . . . . 15:3 , 15:4
type . . . . . . . . . . . . . . . . . . . . . . . . . 15:3
Frames   . . . . . . . . . . . . . . . . . . . . . . . . . 17:8
defining  . . . . . . . . . . . . . . . . . . . . . 20:15
nesting   . . . . . . . . . . . . . . . . . . . . . . 18:1
types  . . . . . . . . . . . . . . . . . . . . . . . . 18:1
Free forms  . . . . . . . . . . . . . . . . 15:10 , 15:11
Function arguments
constants in   . . . . . . . . . . . . . . . . . . . 9:2
Function keys   . . . . . . . . . . . . . . . . . B:1 , B:4
Functions   . . . . . . . . . . . . . . . . . . . . 2:1 , 3:1
arguments   . . . . . . . . . . . . . . . . . . . . 2:6
calling  . . . . . . . . . . . . . . . . . . . . . . . . 2:7
storing  . . . . . . . . . . . . . . . . . . . . . . . . 2:7
user-defined  . . . . . . . . . . . . . . . . . . . 2:7
G
Gadget
database selector  . . . . . . . . . . . . . 20:39
Gadget References  . . . . . . . . . . . . . . . . . 9:1
Gadgets
alignment   . . . . . . . . . . . . . . . 17:2 , 17:6
auto-placement  . . . . . . . . . . . . . . . . 17:6
button  . . . . . . . . . . . . . . . . . . . . . . 20:25
de-activating  . . . . . . . . . . . . . . . . . . 19:4
greying-out - see deactivating   . . . . 19:4
list . . . . . . . . . . . . . . . . . . . . . . . . . 20:34
making invisible   . . . . . . . . . . . . . . . 19:5
making visible  . . . . . . . . . . . . . . . . . 19:5
paragraph  . . . . . . . . . . . . . . . . . . . 20:24
positioning, relative  . . . . . . . . . . . . . 17:3
refreshing  . . . . . . . . . . . . . . . . . . . . 19:6
text input  . . . . . . . . . . . . . . . . . . . . 20:39
textpane   . . . . . . . . . . . . . . . . . . . . 20:47
toggle   . . . . . . . . . . . . . . . . . . . . . . 20:27
GOLABEL command   . . . . . . . . . . . . . . . 5:7
Greying-out - see deactivating   . . . . . . . 19:4
H
HALIGN command   . . . . . . . . . . . . . . . . 17:6
HDISTANCE command   . . . . . . . . . . . . 17:6
Help button   . . . . . . . . . . . . . . . . . . . . . 20:26Help options  . . . . . . . . . . . . . . . . . . . . . 16:4
Hiding forms  . . . . . . . . . . . . . . . .13:4 , 15:12
Highlight colour   . . . . . . . . . . . . . . . . . 20:54
I
Icon title for form   . . . . . . . . . . . . . . . . . 15:5
IF construct   . . . . . . . . . . . . . . . . . . . . . . 5:1
IF constructs
boolean   . . . . . . . . . . . . . . . . . . . . . . 5:2
nesting  . . . . . . . . . . . . . . . . . . . . . . . 5:2
If statements  . . . . . . . . . . . . . . . . . . . . . . 4:3
Imperial units
in text gadgets  . . . . . . . . . . . . . . . 20:43
Initialisation
of forms   . . . . . . . . . . . . . . . . . . . . . 15:6
Inserting bar menus  . . . . . . . . . . . . . . . 16:7
Inserting menu fields   . . . . . . . . . . . . . . 16:8
Integer variables - see Real variables   . . 2:2
Interactive 2D views - see Views  . . . . 20:50
Interactive 3D views - see Views  . . . . 20:50
ISOMETRICcommand  . . . . . . . . . . . . 20:59
J
Jumping to a labelled line  . . . . . . . . . . . . 5:7
K
Keyboard focus   . . . . . . . . . . . . . . . . . . 19:5
Killing forms   . . . . . . . . . . . . . . . .13:4 , 15:12
L
LABEL command  . . . . . . . . . . . . . . . . . . 5:7
Late evaluation of variables  . . . . . . . . . . 8:2
LIMITS command  . . . . . . . . . . . . . . . . 20:60
AREA view  . . . . . . . . . . . . . . . . . . 20:57
Line feeds  . . . . . . . . . . . . . . . . . . . . . . . . 8:5
Linking files   . . . . . . . . . . . . . . . . . . . . . . 3:4
Linking new form files  . . . . . . . . . . . . . . 13:5
List gadget   . . . . . . . . . . . . . . . . . . . . . 20:34
Loading forms   . . . . . . . . . . . . . . . . . . . 13:4
Logical operators   . . . . . . . . . . . . . . . . . . 4:1
LOOKcommand  . . . . . . . . . . . . . . . . . 20:59
Loops  . . . . . . . . . . . . . . . . . . . . . . . . . . . 5:4
M
Macros  . . . . . . . . . . . . . . . . . . . . . . .3:1 , 7:1
argument defaults   . . . . . . . . . . . . . . 7:3
argument separators   . . . . . . . . . . . . 7:2
arguments   . . . . . . . . . . . . . . . . . . . . 7:1
arguments, omitting  . . . . . . . . . . . . . 7:3

--- Page 266 ---
 Software Customisation Guide
12 Series © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Index page ivarguments, separating   . . . . . . . . . . . 7:3
naming   . . . . . . . . . . . . . . . . . . . . . . . 7:1
running  . . . . . . . . . . . . . . . . . . . . . . . 7:1
suspending  . . . . . . . . . . . . . . . . . . . 12:4
Members (of objects)   . . . . . . . . . . . . . . . 2:1
Menu bar
defining  . . . . . . . . . . . . . . . . . . . . . . 16:2
Menu Bars
inserting menus   . . . . . . . . . . . . . . . 16:7
Menus  . . . . . . . . . . . . . . . . . . . . . . . . . . 16:1
bar  . . . . . . . . . . . . . . . . . . . . . . . . . 16:2
de-activating options   . . . . . . . . . . . 16:9
defining  . . . . . . . . . . . . . . . . . . . . . . 16:3
help options   . . . . . . . . . . . . . . . . . . 16:4
inserting fields   . . . . . . . . . . . . . . . . 16:8
popup  . . . . . . . . . . . . . . . . . 16:5 , 16:11
toggle   . . . . . . . . . . . . . . . . . . . . . . . 16:6
window  . . . . . . . . . . . . . . . . . . . . . . 16:4
Meta events   . . . . . . . . . . . . . . . . . . . . . 14:3
Method overloading   . . . . . . . . . . . . . . . 2:12
Methods   . . . . . . . . . . . . . . . . . . . . . . . . . 2:1
constructor   . . . . . . . . . . . . . . . . . . . 2:12
on objects  . . . . . . . . . . . . . . . . 2:9 , 2:11
Module switching   . . . . . . . . . . . . . . . . . . 2:7
Mouse buttons   . . . . . . . . . . . . . . . . B:1 , B:4
Mousemode   . . . . . . . . . . . . . . . . . . . . 20:60
Multiple choice list gadgets  . . . . . . . . . 20:36
N
Naming conventions  . . . . . . . . . . . . . . . 13:2
Numeric Keypad Keys   . . . . . . . . . . . . . . B:2
O
Object class   . . . . . . . . . . . . . . . . . . . . . . 2:1
Object methods  . . . . . . . . . . . . . . . . . . . . 2:9
user-defined  . . . . . . . . . . . . . . . . . . 2:11
Object types   . . . . . . . . . . . . . . . 2:1 , 2:2, 2:3
Objects   . . . . . . . . . . . . . . . . . . . . . . . . . . 2:1
OK button   . . . . . . . . . . . . . . . . . 15:6 , 20:26
Operands   . . . . . . . . . . . . . . . . . . . . . . . . 4:1
Operators   . . . . . . . . . . . . . . . . . . . . . . . . 4:1
boolean  . . . . . . . . . . . . . . . . . . . . . . . 4:2
concatenation  . . . . . . . . . . . . . . . . . . 4:3
logical  . . . . . . . . . . . . . . . . . . . . 4:1 , 4:2
precedence  . . . . . . . . . . . . . . . . . . . . 4:2
Orientation   . . . . . . . . . . . . . . . . . . . . . . . 2:2
Overloading
methods   . . . . . . . . . . . . . . . . . . . . . 2:12
P
Panning  . . . . . . . . . . . . . . . . . . B:1 , B:3, B:4Paragraph gadgets  . . . . . . . . . . . . . . . 20:24
Parent forms  . . . . . . . . . . . . . . . . . . . . 15:10
PATH command  . . . . . . . . . . . . . . . . . . 17:6
Pausing a running file  . . . . . . . . . . . . . . 12:4
PERSPECTIVE mode   . . . . . . . . . . . . 20:58
Pixmaps  . . . . . . . . . . . . . . . . . . . . . . . . 19:3
PLANcommand   . . . . . . . . . . . . . . . . . 20:59
Plot view gadget  . . . . . . . . . . . .20:55 , 20:56
PML directives   . . . . . . . . . . . . . . . .3:4 , 13:5
PML Files  . . . . . . . . . . . . . . . . . . . . . . . . 3:1
pml index command  . . . . . . . . . . . .3:4 , 13:5
pml index file   . . . . . . . . . . . . . . . . . . . . . 3:4
pml rehash command  . . . . . . . . . . .3:4 , 13:5
pml reload form command  . . . . . . . . . . 13:6
pml scan command   . . . . . . . . . . . . . . . . 3:4
PML TRACE command   . . . . . . . . . . . . 12:3
PMLLIB environment variable   . . . . . . . . 2:7
pmlscan command  . . . . . . . . . . . . . . . . 13:6
Popup menu (view)   . . . . . . . . . . . . . . . . B:4
Popup menus  . . . . . . . . . 16:5 , 16:11 , 20:51
Popups  . . . . . . . . . . . . . . . . . . . . . . . . . 16:6
Position of forms   . . . . . . . . . . . . . . . . 15:11
Positioning gadgets   . . . . . . . . . . . . . . . 17:6
Procedures  . . . . . . . . . . . . . . . . . . . .2:6 , 2:7
PUT command
2D view   . . . . . . . . . . . . . . . . . . . . 20:56
Q
Querying
pathname of PML Files   . . . . . . . . . . 3:4
PML . . . . . . . . . . . . . . . . . . . . . . . . 12:5
R
RAW operator (array variables)  . . . . . . . 8:5
Read-only text gadgets   . . . . . . . . . . . 20:42
References  . . . . . . . . . . . . . . . . . . . . . . . 9:1
Refreshing gadgets   . . . . . . . . . . . . . . . 19:6
Relational operators  . . . . . . . . . . . . . . . . 4:2
RELOAD command   . . . . . . . . . . . . . . . 2:13
Reset button  . . . . . . . . . . . . . . . . . . . . 20:26
Result, of expression   . . . . . . . . . . . . . . . 4:1
RETURN ERROR command  . . . . . . . . 10:3
S
Sessions, as objects   . . . . . . . . . . . . . . . 8:4
SetDefaultFormat  . . . . . . . . . . . . . . . . . 22:5
Setup form command  . . . . . . . . . . . . . . 15:3
Showing forms  . . . . . . . . . . . . . . .13:3 , 13:4
Sorting
arrays  . . . . . . . . . . . . . . . . . . . . .6:4 , 6:6
Spaces  . . . . . . . . . . . . . . . . . . . . . . . . . . 8:5

--- Page 267 ---
 Software Customisation Guide
12 Series © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Index page vsplashscreen  . . . . . . . . . . . . . . . . . . . . . 22:3
Splitting text into array elements  . . . . . . . 6:3
Status Line   . . . . . . . . . . . . . . . . . . . . . . . B:3
Storing PML Files   . . . . . . . . . . . . . . . . . . 3:1
String variables  . . . . . . . . . . . . . . . . . . . . 2:2
Subtotallin g arrays   . . . . . . . . . . . . . . . . . 6:9
Suspending a running file  . . . . . . . . . . . 12:4
Swapping applications   . . . . . . . . 22:1 , 22:3
Synonyms  . . . . . . . . . . . . . . . . . . . . . . . . 7:4
System-defined variable types   . . . . . . . . 2:2
T
Text
columns   . . . . . . . . . . . . . . . . . . . . . . 8:1
validating   . . . . . . . . . . . . . . . . . . . 20:46
Text gadgets
formatting  . . . . . . . . . . . . . . . . . . . 20:43
imperial units   . . . . . . . . . . . . . . . . 20:43
Text in PML  . . . . . . . . . . . . . . . . . . . . . . . 3:3
Text input gadget   . . . . . . . . . . . . . . . . 20:39
Textpane gadget  . . . . . . . . . . . . . . . . . 20:47
THEN command (PML)  . . . . . . . . . . . . . . 5:1
Title, of form   . . . . . . . . . . . . . . . . . . . . . 15:5
Toggle gadgets  . . . . . . . . . . . . . . . . . . 20:27
Toggle options
on menus   . . . . . . . . . . . . . . . . . . . . 16:6
Tracing   . . . . . . . . . . . . . . . . . . . . . . . . . 12:3
U
Undefined variables   . . . . . . . . . . . . . . . 2:13
Unset variables  . . . . . . . . . . . . . . . . . . . 2:13
User-defined variable types   . . . . . . . . . . 2:2
V
Validating text fields   . . . . . . . . . . . . . . 20:46
VALIGN command   . . . . . . . . . . . . . . . . 17:6
VAR command   . . . . . . . . . . . . . . . . 6:6 , 6:9
Variable type  . . . . . . . . . . . . . . . . . . . . . . 2:2
Variables  . . . . . . . . . . . . . . . . . . . . . . . . . 2:1
array  . . . . . . . . . . . . . . . . . . . . . . . . . 2:1
boolean  . . . . . . . . . . . . . . . . . . . . . . . 2:1
creating  . . . . . . . . . . . . . . . . . . . . . . . 2:4
deleting  . . . . . . . . . . . . . . . . . . . . . . 2:14
global   . . . . . . . . . . . . . . . . . . . 2:3 , 2:14
in rules   . . . . . . . . . . . . . . . . . . . . . . . 8:2
late evaluation   . . . . . . . . . . . . . . . . . 8:2
local  . . . . . . . . . . . . . . . . . . . . . . . . . 2:3
names  . . . . . . . . . . . . . . . . . . . . . . . . 2:3
naming conventions  . . . . . . . . . . . . 2:14
PML 1  . . . . . . . . . . . . . . . . . . . . . . . . 2:1
real . . . . . . . . . . . . . . . . . . . . . . . . . . 2:1string   . . . . . . . . . . . . . . . . . . . . . . . . 2:1
type  . . . . . . . . . . . . . . . . . . . . . . . . . 2:1
undefined  . . . . . . . . . . . . . . . . . . . . 2:13
unset   . . . . . . . . . . . . . . . . . . . . . . . 2:13
VDISTANCE command   . . . . . . . . . . . . 17:6
View popup menu   . . . . . . . . . . . . . . . . . B:4
View radius  . . . . . . . . . . . . . . . . . . . . . 20:59
View range  . . . . . . . . . . . . . . . . . . . . . 20:59
Views   . . . . . . . . . . . . . . . . . . . . . . . . . 20:50
ALPHA  . . . . . . . . . . . . . . . .20:50 , 20:51
AREA, defining   . . . . . . . . . . . . . . 20:56
aspect ratio   . . . . . . . . . . . . . . . . . 20:54
AUTO flag   . . . . . . . . . . . . . . . . . . 20:60
background colour  . . . . . . . . . . . . 20:54
borders  . . . . . . . . . . . . . . . . . . . . . 20:54
colour shaded   . . . . . . . . . . . . . . . 20:58
colours  . . . . . . . . . . . . . . . . . . . . . 20:54
cursor types  . . . . . . . . . . . . . . . . . 20:54
defining   . . . . . . . . . . . . . . . . . . . . 20:50
direction  . . . . . . . . . . . . . . . . . . . . 20:58
eye/model toggle  . . . . . . . . . . . . . . . B:4
function keys   . . . . . . . . . . . . . . B:1 , B:3
highlight colour  . . . . . . . . . . . . . . . 20:54
limits  . . . . . . . . . . . . 20:59 , B:1, B:3, B:4
manipulating   . . . . . . . . . . . . . . B:1 , B:3
mouse buttons  . . . . . . . . . . . . . B:1 , B:3
mousemode  . . . . . . . . . . . . . . . . . 20:60
panning   . . . . . . . . . . . . . . .B:1 , B:3, B:4
perspective   . . . . . . . . . . . . . .20:58 , B:4
plot . . . . . . . . . . . . . . . . . . . . . . . . 20:56
popup menu  . . . . . . . . . . . . . . . . . 20:51
restoring  . . . . . . . . . . . . . . . . .20:60 , B:4
rotating  . . . . . . . . . . . . . . . . . . . . . . . B:4
saving   . . . . . . . . . . . . . . . . . .20:60 , B:4
shaded  . . . . . . . . . . . . . . . . . . . . . . . B:4
volume, defining  . . . . . . . . . . . . . . 20:58
walkthrough mode  . . . . . . . . . . . . . . B:4
zooming  . . . . . . . . . . . . . . .B:1 , B:3, B:4
VLOGICAL  . . . . . . . . . . . . . . . . . . . . . . . 8:2
Volume view gadget  . . . . . . . . .20:55 , 20:56
VTEXT   . . . . . . . . . . . . . . . . . . . . . . . . . . 8:2
VVALUE  . . . . . . . . . . . . . . . . . . . . . . . . . 8:2
W
WALKTHROUGH mode  . . . . . . . . . . . 20:59
White space  . . . . . . . . . . . . . . . . . . . . . . 6:4
Window menu   . . . . . . . . . . . . . . . . . . . 16:4
Z
Zooming  . . . . . . . . . . . . . . . . . .B:1 , B:3, B:4

--- Page 268 ---
 Software Customisation Guide
12 Series © Copyright 1974 to current year.
AVEVA Solutions Limited and its subsidiaries. All rights reserved.Index page vi